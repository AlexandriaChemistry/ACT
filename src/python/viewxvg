#!/usr/bin/env python3

import tkinter
import matplotlib
import matplotlib.pyplot as plt
matplotlib.use('TkAgg')
import os, argparse
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation

def interpret_legend(line):
    legval = None
    legkey = "title"
    if line.find(legkey) >= 0:
        legval = line[line.find(legkey)+len(legkey)+1:].strip()
        legval = legval[1:-1]
        return legkey, legval
    
    for axis in [ "x", "y" ]:
        legkey  = axis+"axis"
        legkey2 = "label" 
        if line.find(legkey) >= 0 and line.find(legkey2) >= 0:
            legval = line[line.find(legkey2)+len(legkey2)+1:].strip()
            legval = legval[1:-1]
            return axis+"label", legval
    legkey = "legend"
    if line.find(legkey) >= 0 and line[0] == 's':
        legval = line[line.find(legkey)+len(legkey)+1:].strip()
        legval = legval[1:-1]
        return "label", legval
    return None, None
    
def read_xvg(filename):
    legends = {}
    labels  = []
    xdata   = []
    ydata   = []
    numwords = None
    with open(filename, "r") as inf:
        for line in inf:
            nhash = line.find("#")
            if nhash == 0:
                line = line[:nhash]
                continue
            
            nleg = line.find("@")
            if nleg >= 0:
                myline = line[nleg+1:].strip()
                if len(myline) > 0:
                    legkey, legval = interpret_legend(myline)
                    if legkey and legval:
                        if legkey == "label":
                            labels.append(legval)
                        else:
                            legends[legkey] = legval
                continue
            
            # Ignore multiple sequential sets for now
            w = line.split()
            if None == numwords:
                numwords = len(w)
            if len(w) == numwords:
                xdata.append(float(w[0]))
                if len(ydata) == 0:
                    for nw in range(1,len(w)):
                        ydata.append([float(w[nw])])
                elif len(ydata) == len(w)-1:
                    for nw in range(1,len(w)):
                        ydata[nw-1].append(float(w[nw]))
    return labels, legends, xdata, ydata
    
def parseArguments():
    parser = argparse.ArgumentParser(
      prog='viewxvg',
      description=
"""
Braindead script to quickly plot xy files produced by e.g. GROMACS.
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: viewxvg -f filename1 filename2 -follow')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=None)
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s)", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    axislabelfontsize=12
    parser.add_argument("-alfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=16
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=8
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    linestyle="solid"
    parser.add_argument("-ls", "--linestyle", help="What kind of line style: solid, dash, dashdot, None, default "+linestyle, type=str, default=linestyle)
    parser.add_argument("-mk", "--marker", help="Use markers for data sets", action="store_true")
    parser.add_argument("-pdf", "--pdf", help="Save plot as pdf file", type=str, default=None)
    parser.add_argument("-sq", "--square", help="Make the plot square with equal axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    
    return parser.parse_args()

def get_min_max(data):
    if len(data) == 0:
        return 0, 1
    else:
        mmin = data[0]
        mmax = data[0]
        for i in range(1,len(data)):
            mmin = min(mmin, data[i])
            mmax = max(mmax, data[i])
        return mmin, mmax
        
args = parseArguments()
fig, ax = plt.subplots()

def plot_once():
    legends = {}
    ax.clear()
    have_labels = False
    for fn in args.filename:
        label, legend, xdata, ydata = read_xvg(fn)
        if args.square:
            ax.set_aspect('equal', adjustable='box')
            xxmin, xxmax = get_min_max(xdata)
            for kkk in range(len(ydata)):
                yymin, yymax = get_min_max(ydata[kkk])
                mmin = min(xxmin, yymin)
                mmax = max(xxmax, yymax)
            delta = (mmax-mmin)/20
            mmin -= delta
            mmax += delta
            plt.xlim(mmin, mmax)
            plt.ylim(mmin, mmax)
        if args.logy:
            ax.set_yscale('log')
        for leg in legend.keys():
            legends[leg] = legend[leg]
        have_labels = have_labels or len(label) > 0
        if args.bar:
            print("Doing bar graphs")
            for y in ydata:
                ax.bar(xdata, y, width=0.8/len(ydata), bottom=0.0, align="center", label=fn)
        else:
            print_label = len(label) == len(ydata)
            mylabel     = None
            if args.marker:
                markers = [ "+", "x", ".", "v", "s", "o" ]
                for n in range(len(ydata)):
                    if print_label:
                        mylabel = label[n]
                    ax.plot(xdata, ydata[n], label=mylabel, ls=args.linestyle, marker=markers[n % len(markers)])
            else:
                for n in range(len(ydata)):
                    if print_label:
                        mylabel = label[n]
                    ax.plot(xdata, ydata[n], label=mylabel, ls=args.linestyle, marker=None)

    if "title" in legends:
        plt.title(legends["title"], fontsize=args.titlefontsize)
    if "xlabel" in legends:
        ax.set_xlabel(legends["xlabel"], fontsize=args.axislabelfontsize)
    if "ylabel" in legends:
        ax.set_ylabel(legends["ylabel"], fontsize=args.axislabelfontsize)
    if args.legendfontsize > 0 and have_labels:
        xlegend = 0.01
        ax.legend(loc='upper left', bbox_to_anchor=(xlegend, 1), fontsize=args.legendfontsize)
    if args.pdf:
        # Print just once!
        fig.savefig(args.pdf, bbox_inches='tight')
        args.pdf = None
        
def animate(t):
    plot_once()
    plt.gcf().autofmt_xdate()
    plt.tight_layout()

if __name__ == '__main__':   
    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    if args.filename:
        if args.follow:
            ani = FuncAnimation(plt.gcf(), animate, interval=5000)
        else:
            plot_once()
        if not args.noshow:
            plt.show()
