#!/usr/bin/env python3

# OpenMM python example script for running Alexandria force fields
# in OpenMM using a user-selected integrator.
# This script implements a modified Buckingham potential with
# Hogervorst combination rules and Gaussian distributed charges 
# for the nonbonded interactions. 
# A Morse or Cubic potential is used for the bonded interactions.
############################################################ 
#              PROCEED AT YOUR OWN RISK.                   #
############################################################
# Author: Marie-Madeleine Walz, David van der Spoel Group,
# Department of Cell and Molecular Biology, Uppsala University, Sweden. 
# marie-madeleine.walz@icm.uu.se
############################################################

from openmm import *
from openmm.app import *
from simtk.unit import *
from simtk import openmm, unit
import numpy as np
import argparse, math, sys, shutil
from enum import Enum

ONE_4PI_EPS0 = 138.93544561

# To distinguish 
class VdW(Enum):
    LJ8_6  = 1
    LJ12_6 = 2
    LJ14_7 = 3
    WBHAM  = 4
    GBHAM  = 5

# Map strings to VdW entries.
VdWdict = {
    'LJ8_6':  { "func": VdW.LJ8_6, "params": [ "sigma", "epsilon" ],
                "expression": "epsilon*(3*(sigma/r)^8 - 4*(sigma/r)^6)" },
    'LJ12_6': { "func": VdW.LJ12_6, "params": [ "sigma", "epsilon" ], 
                "expression": "4*epsilon*((sigma/r)^12 - (sigma/r)^6)" },
    'LJ14_7': { "func": VdW.LJ14_7, "params": [ "sigma", "epsilon", "gamma", "delta" ],
                "expression": ( 'select(epsilon,( epsilon*( ( (1+ delta)/((r/sigma)+ delta))^7 ) * ( ( (1+ gamma)/(((r/sigma)^7) +gamma )  ) -2       ) ),0)') },
    'WBHAM':  { "func": VdW.WBHAM, "params": [ "sigma", "epsilon", "gamma" ],
                "expression": ('select(epsilon,(((2*epsilon)/(1-(3/(gamma+3)))) * (1.0/(1.0+(r/sigma)^6)) * ((3/(gamma+3))*exp(gamma*(1-(r/sigma)))-1)),0)') },
    'GBHAM':  { "func": VdW.GBHAM, "params": [ "rmin",  "epsilon", "gamma", "delta" ],
                "expression": ('select(epsilon*rmin*gamma,(        epsilon*((delta + 2*gamma + 6)/(2*gamma)) * (1/(1+((r/rmin)^6))) * (  ((6+delta)/(delta + 2*gamma + 6)) * exp(gamma*(1-(r/rmin))) -1 ) - (epsilon/(1+(r/rmin)^delta))           ),0)') }
}

# Make reverse map as well.
dictVdW = {}
for key in VdWdict:
    dictVdW[VdWdict[key]["func"]] = key

class qDist(Enum):
    Point = 1
    Gaussian = 2
    Slater = 3

qdistDict = { 'Point': qDist.Point, 'Gaussian': qDist.Gaussian, 'Slater': qDist.Slater }

dictQdist = {}
for key in qdistDict:
    dictQdist[qdistDict[key]] = key

nbmethod = {
    'LJPME':          LJPME,
    'PME':            PME,
    'Ewald':          Ewald,
    'CutoffPeriodic': CutoffPeriodic,
    'NoCutoff':       NoCutoff
    }

constrmethod = {
    'AllBonds': AllBonds,
    'HBonds':   HBonds,
    'HAngles':  HAngles,
    'None':     None
    }

# indices (XML files have to follow this order)
parameter_indices = {
    VdW.WBHAM: {
        'sigma':   0,
        'epsilon': 1,
        'gamma':   2,
        'charge':  3,
        'zeta':    4
        },
    VdW.GBHAM: {
        'rmin':    0,
        'epsilon': 1,
        'gamma':   2,
        'delta':   3,
        'charge':  4,
        'zeta':    5
        },
    VdW.LJ14_7: {
        'sigma':   0,
        'epsilon': 1,
        'gamma':   2,
        'delta':   3,
        'charge':  4,
        'zeta':    5
        },
    VdW.LJ12_6: {
        'charge': 0,
        'sigma': 1,
        'epsilon': 2
    }        
    }

def select(x, y, z):
    return y if x else z

def count_atoms(topology)->int:
    # First count real atoms
    natom = 0
    for res in topology.residues():
        for atom in res.atoms():
            if atom.element:
                natom += 1
    return natom

def write_sdf(outf, topology, positions, ffcharge, bonds, my_shell):
    # Warning: This code is likely very fragile.
    outf.write("Generated by ACT OpenMM Interface.\n")
    outf.write("  Coordinates and charge information.\n")
    outf.write("WARNING: The content of this file should be carefully checked.\n")
    natom = count_atoms(topology)
    outf.write("%3d%3d  0  0  0  0  0  0  0  0999 V2000\n" % ( natom, len(bonds) ))
    myunit = unit.angstrom
    charges = []
    count   = 1
    remap   = {}
    for res in topology.residues():
        for atom in res.atoms():
            i = atom.index
            remap[i] = count
            if atom.element:
                outf.write("%10.4f%10.4f%10.4f" %
                           ( positions[i][0].value_in_unit(myunit),
                             positions[i][1].value_in_unit(myunit),
                             positions[i][2].value_in_unit(myunit) ))
                nnn = 0
                # Funky way to check for formal charge. 
                qqq = ffcharge[i]
                if my_shell and i in my_shell:
                    qqq += ffcharge[my_shell[i]]
                # Have to prevent rounding of numbers in the wrong direction
                qqq = int(round(qqq))
                if 0 != qqq:
                    bonded = False
                    for n in bonds:
                        if i == n[0] or i == n[1]:
                            bonded = True
                    if not bonded:
                        charges.append( { "count": count, "q": qqq } )
                        if qqq > 0:
                            nnn = 3
                        else:
                            nnn = 5
                outf.write("%3s%3d%3d  0  0  0  0  0  0  0  0  0  0\n" %
                           ( atom.element.symbol, 0, nnn ))
                count += 1
    for b in bonds:
        # Assume bond order 1
        order = 1
        outf.write("%3d%3d%3d  0  0  0  0\n" % ( remap[b[0]], remap[b[1]], order ))

    if len(charges) > 0:
        outf.write("M  CHG%3d" % len(charges))
        for q in charges:
            outf.write("%4d%4d" % ( q["count"], q["q"] ))
        outf.write("\n")
    outf.write("M  END\n")
    outf.write("$$$\n")

def write_xyz(outf, topology, positions):
    natom = count_atoms(topology)
    outf.write("%5d\n" % natom)
    outf.write("Coordinates\n")
    myunit = unit.angstrom
    for res in topology.residues():
        for atom in res.atoms():
            i = atom.index
            if atom.element:
                outf.write("%5s %15.10f  %15.10f  %15.10f\n" %
                           ( atom.element.symbol,
                             positions[i][0].value_in_unit(myunit), 
                             positions[i][1].value_in_unit(myunit), 
                             positions[i][2].value_in_unit(myunit) ))

class SimParams:

    def __init__(self, filename:str) -> None:
        self.filename = filename
        self.params   = {}
        with open(filename, 'r') as inFileStream:
            for line in inFileStream:
                line_no_comment = line.split('#')[0]
                try:
                    key, value       = [v.strip() for v in line_no_comment.split('=')]
                    self.params[key] = value
                except:
                    continue

    def setText(self, txt):
        self.txt = txt

    def getFloat(self, key:str, default=0) -> float:
        if key in self.params and len(self.params[key]) > 0:
            try:
                if self.params[key].find("*") > 0:
                    words = self.params[key].split("*")
                elif self.params[key].find("/") > 0:
                    words = self.params[key].split("/")
                else:
                    words = [ self.params[key] ]
                value = float(words[0])
            except ValueError:
                sys.exit("Incorrect float value '%s' for key '%s' in %s" % ( words[0], key, self.filename ))
            return value
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = %g\n" % ( key, self.filename, default ))
            return default

    def getInt(self, key:str, default:int=0) -> int:
        if key in self.params and len(self.params[key]) > 0:
            try:
                words = self.params[key].split("*")
                value = int(words[0])
            except ValueError:
                sys.exit("Incorrect integer value '%s' for key '%s' in %s" % ( words[0], key, self.filename ))
            return value
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = %d\n" % ( key, self.filename, default ))
            return default
        
    def getStr(self, key:str, default:str="") -> str:
        if key in self.params and len(self.params[key]) > 0:
            return self.params[key]
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = '%s'\n" % ( key, self.filename, default ))
            return default
        
    def getBool(self, key:str, default:bool=False) -> bool:
        if key in self.params and len(self.params[key]) > 0:
            return self.params[key] in [ "True", "true" ]
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = '%s'\n" % ( key, self.filename, str(default) ))
            return default
        
class CombinationRules:
    def __init__(self, qdist:qDist, comb:str, vdw:VdW):
        self.qdist = qdist
        self.vdw   = vdw
        vdwstr     = dictVdW[self.vdw]
        self.comb  = {}
        www = comb.split()
        if 2*len(VdWdict[vdwstr]["params"]) != len(www):
            sys.exit("Expected separate combination rules for %d parameters but found '%s'" % ( len(VdWdict[vdwstr]["params"]), comb ) )
        for i in range(int(len(www)/2)):
            param = www[2*i]
            self.comb[param] = www[2*i+1]
        for np in VdWdict[vdwstr]["params"]:
            if not np in self.comb:
                sys.exit("No combination rule provided for %s on '%s'" % ( np, comb) )

    def rule(self, param:str)->str:
        if not param in self.comb:
            print("WARNING: No such parameter '%s' in combination rules" % param)
            return "Cucumber"
        else:
            return self.comb[param]

    def geometricString(self, vara:str, varb:str)->str:
        return ("sqrt(%s*%s)" % ( vara, varb ))
        
    def geometric(self, vara:float, varb:float)->float:
        return eval(self.geometricString(str(vara), str(varb)))
        
    def arithmeticString(self, vara:str, varb:str)->str:
        return ("0.5*(%s+%s)" % ( vara, varb ))

    def arithmetic(self, vara:float, varb:float)->float:
        return eval(self.arithmeticString(str(vara), str(varb)))

    def combTwoString(self, rule:str, vara:str, varb:str)->str:
        myrule = rule.lower()
        if "geometric" == myrule:
            return self.geometricString(vara, varb)
        elif "arithmetic" == myrule:
            return self.arithmeticString(vara, varb)
        elif "yang" == myrule:
            return ("select(%s+%s, (%s*%s)*(%s+%s)/(%s*%s+%s*%s), 0)" % ( vara, varb, vara, varb, vara, varb, vara, vara, varb, varb ))
        elif "waldmansigma" == myrule:
            return ("(0.5*(%s^6 + %s^6))^(1.0/6.0)" % ( vara, varb ))
        elif "volumetric" == myrule:
            return ("(0.5*(%s^3 + %s^3))^(1.0/3.0)" % ( vara, varb ))
        elif "inversesquare" == myrule:
            return ("sqrt(2/(%s^(-2) + %s^(-2)))" % (vara, varb) )
        elif "qisigma" == myrule:
            return ("select(%s+%s,(%s^3+%s^3)/(%s^2+%s^2),0)" % ( vara, varb, vara, varb, vara, varb ))
        elif "halgrenepsilon" == myrule:
            return ("select(%s^2+%s^2,(4*%s*%s/(sqrt(%s)+sqrt(%s))^2),0)" % ( vara, varb, vara, varb, vara, varb ))
        elif "hogervorstepsilon" == myrule:
            return ("select(%s+%s,((2.0 * %s * %s)/( %s + %s )),0)" %  ( vara, varb, vara, varb, vara, varb ))
        else:
            sys.exit("Unknown combination rule '%s'" % rule)

    def combTwoFloats(self, param:str, vara:float, varb:float)->float:
        myrule = self.comb[param].lower()
        try:
            mystring = self.combTwoString(myrule, vara, varb).replace("^", "**").replace("sqrt", "math.sqrt")
            return eval(mystring)
        except Exception as e:
            if (vara + varb) == 0 and myrule in ["qisigma", "halgrenepsilon", "hogervorstepsilon", "yang"]:
                return 0
            else:
                raise e

    def combFloats(self, allParam:dict)->list:
        mydict = {}
        for param in self.comb.keys():
            hve = "hogervorstepsilon"
            hvs = "hogervorstsigma"
            wme = "waldmanepsilon"
            mng = "masongamma"
            epsilon1 = allParam["epsilon"][0]
            epsilon2 = allParam["epsilon"][1]
            if "sigma" in allParam:
                sigma1 = allParam["sigma"][0]
                sigma2 = allParam["sigma"][1]
            elif "rmin" in allParam:
                rmin1 = allParam["rmin"][0]
                rmin2 = allParam["rmin"][1]
            if "gamma" in allParam:
                gamma1 = allParam["gamma"][0]
                gamma2 = allParam["gamma"][1]
            if hvs == self.comb[param].lower():
                e12 = self.combineTwoFloat(hve, epsilon1, epsilon2)
                if self.vdw == VdW.WBHAM and "sigma" == param:
                    mydict["sigma"]  = math.sqrt(((epsilon1*gamma1*sigma1**6)/(gamma1-6)) * ((epsilon2*gamma2*sigma2**6)/(gamma2-6)))*((gamma1+gamma2)/2-6)/(e12*(gamma1+gamma2)/2)**(1.0/6.0)
                elif self.vdw == VdW.GBHAM and "rmin" == param:
                    mydict["rmin"]   = math.sqrt(((epsilon1*gamma1*rmin1**6)/(gamma1-6)) * ((epsilon2*gamma2*rmin2**6)/(gamma2-6)))*((gamma1+gamma2)/2-6)/(e12*(gamma1+gamma2)/2)**(1.0/6.0)
                else:
                    sys.exit("Combination rule %s not supported for param %s and VdW function %s" % ( hvs, param, dictVdW[self.vdw] ))
            elif wme == self.comb[param].lower():
                if "epsilon" == param:
                    if "sigma" in allParam:
                        denominator = (sigma1**6)+(sigma2**6)
                    elif "rmin" in allParam:
                        denominator = (rmin1**6)+(rmin2**6)
                    else:
                        sys.exit("Combination rule %s requires either sigma or rmin to calculate %s" % ( wme, param ))
                    # check for division by zero
                    if denominator != 0:
                        mydict["epsilon"] = math.sqrt(epsilon1*epsilon2)*(2*(rmin1**3)*(rmin2**3))/(denominator)
                    else:
                        mydict["epsilon"] = 0
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( wme, param ))
            elif mng == self.comb[param].lower():
                if "gamma" == param:
                    sigmaIJ = math.sqrt(allParam["sigma"][0]*allParam["sigma"][1])
                    mydict["gamma"] = sigmaIJ*(0.5*(allParam["gamma"][0]/allParam["sigma"][0]+allParam["gamma"][1]/allParam["sigma"][1]))
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( mng, param ))
            else:
                mydict[param] = self.combTwoFloats(param, allParam[param][0], allParam[param][1])
        return mydict
        
    def combStrings(self)->dict:
        mydict = {}
        for param in self.comb.keys():
            hvs = "hogervorstsigma"
            wme = "waldmanepsilon"
            mng = "masongamma"
            if hvs == self.comb[param].lower():
                e12 = self.combTwoString("hogervorstepsilon", "epsilon1", "epsilon2")
                if self.vdw == VdW.WBHAM and "sigma" == param:
                    mydict["sigma"]  = ("(((sqrt(((epsilon1*gamma1*(sigma1^6))/(gamma1-6)) * ((epsilon2*gamma2*(sigma2^6))/(gamma2-6)))*((gamma1+gamma2)/2-6))/(%s*(gamma1+gamma2)/2))^(1.0/6.0))" % e12)
                elif self.vdw == VdW.GBHAM and "rmin" == param:
                    mydict["rmin"] = ("(((sqrt(((epsilon1*gamma1*rmin1^6)/(gamma1-6)) * ((epsilon2*gamma2*rmin2^6)/(gamma2-6)))*((gamma1+gamma2)/2-6))/(%s*(gamma1+gamma2)/2))^(1.0/6.0))" % e12)
                else:
                    sys.exit("Combination rule %s not supported for param %s and VdW function %s" % ( hvs, param, dictVdW[self.vdw] ))
            elif wme == self.comb[param].lower():
                if "epsilon" == param:
                    if "sigma" in self.comb.keys():
                        mydict["epsilon"] = ("select(sigma1+sigma2, sqrt(epsilon1*epsilon2)*(2*(sigma1^3)*(sigma2^3))/((sigma1^6)+(sigma2^6)), 0)")
                    elif "rmin" in self.comb.keys():
                        mydict["epsilon"] = ("select(rmin1+rmin2, sqrt(epsilon1*epsilon2)*(2*(rmin1^3)*(rmin2^3))/((rmin1^6)+(rmin2^6)), 0)")
                    else:
                        sys.exit("Combination rule %s requires either sigma or rmin to calculate %s" % ( wme, param ))
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( wme, param ))
            elif mng == self.comb[param].lower():
                if "gamma" == param:
                    sigmaIJ = self.combTwoString("geometric", "sigma1", "sigma2")
                    mydict["gamma"] = ("%s*(0.5*(gamma1/sigma1+gamma2/sigma2))" % sigmaIJ)
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( mng, param ))
            else:
                mydict[param] = self.combTwoString(self.comb[param], param+"1", param+"2")
        return mydict
            
    def gaussianString(self)->str:
        if self.qdist == qDist.Gaussian:
            return "select(zeta1*zeta2, erf((zeta1*zeta2*r)/sqrt((zeta1^2)+(zeta2^2))), select(zeta1+zeta2, select(zeta1, erf(zeta1*r), erf(zeta2*r)), 1))"
        elif qDist.Point == self.qdist:
            return "1"
        else:
            sys.exit("No support for charge distribution type %s" % dictQdist[self.qdist])

class ActForce:
    def __init__(self, fcname:str, fgnumber:int):
        self.fcname = fcname
        self.fgnumber = fgnumber

class ActOpenMMSim:
    def __init__(self, pdbfile: str,                  datfile: str,                  actfile: str=None,         
                       xmlfile: str=None,             enefile: str='energy.csv',     txtfile: str='output.txt',
                       chkfile: str=None, 
                       pdbtraj: str='trajectory.pdb', dcdtraj: str='trajectory.dcd',
                       emonomer: float=None,          debug:   bool=False,           verbose: bool=False):
        self.chkfile     = chkfile
        self.enefile     = enefile
        self.txtfile     = txtfile
        self.dcdtraj     = dcdtraj
        self.pdbtraj     = pdbtraj
        self.emonomer    = emonomer
        self.txt         = None
        self.debug = debug
        if self.debug:
            self.verbose = True
        else:
            self.verbose = verbose
        # Check whether .pdb file is valid
        if not os.path.exists(pdbfile):
            sys.exit("Error: pdb file %s does not exist" % pdbfile)
        else:
            self.pdbfile = pdbfile
        # Check whether .dat file is valid
        if not os.path.exists(datfile):
            sys.exit("Error: parameter file %s does not exist" % datfile)
        else:
            self.datfile = datfile
        # ACT force field gets precedence over .xml
        if actfile != None: # only met when ACT is provided
            if not os.path.exists(actfile):
                sys.exit("Error: ACT force field file %s does not exist" % actfile)
            else:
                self.actfile = actfile
                self.xmlfile = None    # to prevent assignment of .xml if ACT exists
        elif xmlfile != None: # only met when .xml is provided and ACT
            if not os.path.exists(xmlfile):
                sys.exit("Error: OpenMM force field file %s does not exist" % xmlfile)
            else:
                self.actfile = actfile # is None
                self.xmlfile = xmlfile
        else:
            sys.exit("Please pass an ACT (actfile) or OpenMM force field file (xmlfile) using the optional arguments")
        self.pdb         = PDBFile(self.pdbfile)
        self.sim_params  = SimParams(self.datfile)
        # Open log file and pass it on.
        self.txt = open(self.txtfile, "w")
        self.sim_params.setText(self.txt)
        # Check options
        vdwopt           = 'vanderwaals'
        vdw              = self.sim_params.getStr(vdwopt)
        if not vdw in VdWdict:
            sys.exit("Unknown value for option %s in %s" % ( vdwopt, self.datfile ))
        self.vdw         = VdWdict[vdw]["func"]
        self.qdist       = self.sim_params.getStr("chargeDistribution")
        if not self.qdist in qdistDict:
            sys.exit("Don't know how to handle charge distribution '%s'" % self.qdist)
        self.qdist       = qdistDict[self.qdist]
        self.comb        = CombinationRules(self.qdist,
                                            self.sim_params.getStr("combinationRule"),
                                            self.vdw)
        # Check which code path to choose
        self.useOpenMMForce = False
        if self.sim_params.getBool("useOpenMMForce", False):
            if (qDist.Point == self.qdist and VdW.LJ12_6 == self.vdw and
                self.comb.rule("epsilon").lower() == "geometric" and
                self.comb.rule("sigma").lower() == "arithmetic"):
                self.useOpenMMForce = True
            else:
                sys.exit("OpenMMForce routines are supported only with LJ12_6 (%s), Point charges (%s) and geometric combination rule for epsilon (%s) and arithmetic for sigma (%s)" % ( vdw, self.qdist, self.comb.rule("epsilon"), self.comb.rule("sigma") ))
        self.force_group = None
        self.txt_header()
        self.gen_ff()
    
    def __del__(self):
        if self.verbose:
            if None != self.txt:
                print("Please check output in %s" % self.txtfile )
                self.txt.close()
            print("Energies are in %s" % self.enefile )
            if None != self.dcdtraj:
                print("DCD trajectory is in %s" % self.dcdtraj )
            if None != self.pdbtraj:
                print("PDB trajectory in %s" % self.pdbtraj )

    def txt_header(self):
        self.txt.write("Starting OpenMM calculation using the ActOpenMMSim interface.\n")
        self.txt.write("input pdbfile:         %s\n" % self.pdbfile)
        self.txt.write("simulation parameters: %s\n" % self.datfile)
        self.txt.write("vanderwaals:           %s\n" % dictVdW[self.vdw])
        self.txt.write("charge distribution:   %s\n" % self.comb.qdist)
        if self.useOpenMMForce:
            self.txt.write("Will use native OpenMM force routines.\n")
        self.txt.flush()

    def gen_ff(self):
        if None != self.xmlfile:
            self.forcefield  = ForceField(self.xmlfile)
            self.txt.write("force field            %s\n" % self.xmlfile)
        elif None != self.actfile:
            # Run alexandria gentop, but first check whether we have alexandria
            if None == shutil.which("alexandria"):
                sys.exit("You provided and ACT force field file, but the alexandria program is not in your PATH")
            self.xmloutfile = "act.xml"
            if os.path.exists(self.xmloutfile):
                if self.verbose:
                    self.txt.write("Removing existing OpenMM force field file %s\n" % self.xmloutfile)
                os.unlink(self.xmloutfile)
            mycmd = ("alexandria gentop -ff %s -f %s -openmm %s" % ( self.actfile,
                                                                     self.pdbfile,
                                                                     self.xmloutfile ))
            os.system(mycmd)
            if not os.path.exists(self.xmloutfile):
                sys.exit("Failed running '%s'" % mycmd)
            self.txt.write("Succesfully generated an OpenMM force field file %s from ACT force field %s\n" % (self.xmloutfile, self.actfile))
            self.forcefield = ForceField(self.xmloutfile)
        self.polarizable = any(isinstance(generator, openmm.app.forcefield.DrudeGenerator) for generator in self.forcefield.getGenerators())
        self.txt.write("polarizable:           %s\n" % self.polarizable)

    def xmlOutFile(self):
        return self.xmloutfile
        
    def init_force_groups(self)->int:
        self.force_group = {}
        self.fgnumber    = {}
        # First, copy existing force groups, but with only one force per group
        max_fg = -1
        self.count_forces("Init force group 1")
        for force in self.system.getForces():
            fcname   = force.getName()
            fgnumber = force.getForceGroup()
            # Find largest group while we are at it
            max_fg   = max(max_fg, fgnumber)
            if not fgnumber in self.force_group:
                self.force_group[fgnumber] = fcname
                self.fgnumber[fcname]      = fgnumber
        # Now give remaining forces new force group numbers
        self.count_forces("Init force group 2")
        for force in self.system.getForces():
            fcname   = force.getName()
            if not fcname in self.fgnumber:
                max_fg += 1
                force.setForceGroup(max_fg)
                self.force_group[max_fg] = fcname
                self.fgnumber[fcname]    = max_fg
        self.count_forces("Init force group 3")
        if self.verbose:
            for force in self.system.getForces():
                self.txt.write("System: %s group %d\n" % ( force.getName(), force.getForceGroup()))
            for group in self.force_group:
                self.txt.write("Self: %s group %d\n" % ( self.force_group[group], group ))
        return len(self.force_group.keys())

    def add_force_group(self, force, nonbond_direct:bool, newfg:bool):
        if None == self.force_group:
            new_fgnumber = self.init_force_groups()
        else:
            last_group = -1
            for nf in self.fgnumber.keys():
                last_group = max(self.fgnumber[nf], last_group)
            new_fgnumber = last_group
        fcname   = force.getName()
        fgnumber = force.getForceGroup()
        if force == self.nonbondedforce and self.nonbondedMethod != NoCutoff:
            # Remove direct space nonbondeds and add them to the local book-keeping
            if nonbond_direct:
                directname = fcname + ' (direct space)'
                self.force_group[fgnumber] = directname
                self.fgnumber[directname]  = fgnumber
                force.setName(directname)
                self.txt.write("Added force group %d %s\n" % ( fgnumber, force.getName()))
            # Now for the PME part
            ### three body dispersion has no reciprocal space
            if fcname != "CustomManyParticleForce":
                new_fgnumber += 1
                recipname = fcname + ' (reciprocal space)'
                self.force_group[new_fgnumber] = recipname
                self.fgnumber[recipname]       = new_fgnumber
                force.setReciprocalSpaceForceGroup(new_fgnumber)
                self.txt.write("Added force group %d %s\n" % ( new_fgnumber, recipname))
        elif newfg:
            new_fgnumber += 1
            self.force_group[new_fgnumber] = fcname
            self.fgnumber[fcname]          = new_fgnumber
            force.setForceGroup(new_fgnumber)
            self.txt.write("Added force group %d %s\n" % ( new_fgnumber, force.getName()))
        else:
            if fgnumber in self.force_group:
                # Update the name just in case
                self.force_group[fgnumber] = fcname
        

    def del_force(self, force, nonbond:bool=False):
        if None == force:
            return
        fcname   = force.getName()
        fgnumber = force.getForceGroup()
        if self.verbose:
            self.txt.write('Will try to delete force %s group %d\n' % (fcname, fgnumber))
        if not nonbond:
            # Find the index belonging to the force to be deleted
            # rather than using the force group number.
            iforce = -1
            index  = 0
            for force in self.system.getForces():
                if force.getName() == fcname:
                    iforce = index
                    break
                index += 1
            if -1 != iforce:
                self.system.removeForce(iforce)
                if fcname in self.fgnumber:
                    del self.fgnumber[fcname]
                if fgnumber in self.force_group:
                    del self.force_group[fgnumber]
        self.count_forces("Deleted force group %d %s" % ( fgnumber, fcname))
        return
        
    def count_forces(self, label:str):
        if self.verbose:
            self.txt.write("%s: there are %d forces\n"  % (label, len(self.system.getForces())))
        if self.debug:
            for force in self.system.getForces():
                self.txt.write("DBG: fcname %s fgnumber %d\n" % ( force.getName(), force.getForceGroup()))

    def nmol(self)->int:
        return self.topology.getNumResidues()
 
    def temperature(self)->float:
        return self.temperature_c
 
    def set_monomer_energy(self, emonomer:float):
        self.emonomer = emonomer

    def set_params(self):
        # SET SIMULATION PARAMETERS
        ################################################
        self.dt                 = self.sim_params.getFloat('dt')
        self.equilibrationSteps = self.sim_params.getInt('equilibrationSteps')
        self.steps              = self.sim_params.getInt('steps')
        self.nonbondedMethod           = nbmethod[self.sim_params.getStr('nonbondedMethod')]
        self.nonbondedCutoff           = self.sim_params.getFloat('nonbondedCutoff')
        self.col_freq                  = self.sim_params.getFloat('collisionFrequency', 0.1) 
        self.maxDrudeDist              = self.sim_params.getFloat('maxDrudeDistance', 0.02)
        self.useAndersenThermostat     = self.sim_params.getBool('useAndersenThermostat')
        self.temperature_c             = self.sim_params.getFloat('temperature_c')
        self.useMonteCarloBarostat     = self.sim_params.getBool('useMonteCarloBarostat')
        self.useMonteCarloAnisotropicBarostat = self.sim_params.getBool('useMonteCarloAnisotropicBarostat')
        if self.useMonteCarloAnisotropicBarostat:
            self.scaleX             = self.sim_params.getBool('scaleX')
            self.scaleY             = self.sim_params.getBool('scaleY')
            self.scaleZ             = self.sim_params.getBool('scaleZ')
            self.pressX             = self.sim_params.getFloat('pressX')
            self.pressY             = self.sim_params.getFloat('pressY')
            self.pressZ             = self.sim_params.getFloat('pressZ')
            self.pressvec           = [self.pressX,self.pressY,self.pressZ]
        self.constraints            = constrmethod[self.sim_params.getStr('constraints')]
        self.rigidWater             = self.sim_params.getBool('rigidWater')
        self.constraintTolerance    = self.sim_params.getFloat('constraintTolerance')
        
        # COMPUTING PLATFORM
        ################################################
        plform = self.sim_params.getStr('usePlatform')
        self.platform = Platform.getPlatformByName(plform)
        if 'CUDA' == plform or 'OpenCL' == plform:
            self.usePrecision = self.sim_params.getStr('usePrecision')
        elif not "Reference" == plform:
            if self.platform.supportsDoublePrecision():
                self.txt.write("Setting precision to double\n")
                self.usePrecision = "double"
            else:
                self.txt.write("Setting precision to single\n")
                self.usePrecision = "single"
        else:
            self.txt.write("Setting precision to single\n")
            self.usePrecision = "single"
        self.txt.write("Using OpenMM version %s on platform %s\n" %
                       ( self.platform.getOpenMMVersion(), self.platform.getName() ))
        self.txt.write("Integration time step %g ps\n" % self.dt)

    def start_output(self):
        # OUTPUT
        ################################################
        # Do not open files unnecessarily
        save = self.sim_params.getInt('saveDcd')
        self.dcdReporter = None
        if save > 0 and self.steps >= save:
            self.dcdReporter  = DCDReporter(self.dcdtraj, save)
        else:
            self.dcd_file = None
        self.dataReporter = StateDataReporter(self.enefile, self.sim_params.getInt('saveEnergy'),
                                              totalSteps=self.steps,
                                              step=self.sim_params.getBool('outStep'),
                                              time=self.sim_params.getBool('outTime'),
                                              speed=self.sim_params.getBool('outSpeed', False),
                                              progress=self.sim_params.getBool('outProgress', False),
                                              potentialEnergy=self.sim_params.getBool('outPotentialEnergy'),
                                              kineticEnergy=self.sim_params.getBool('outKineticEnergy'),
                                              temperature=self.sim_params.getBool('outTemperature'),
                                              volume=self.sim_params.getBool('outVolume', False),
                                              density=self.sim_params.getBool('outDensity'),
                                              separator=self.sim_params.getStr('outSeparator'))
        # Do not open files unnecessarily
        save = self.sim_params.getInt('checkPoint')
        self.chkReporter = None
        if save > 0 and self.steps >= save:
            if self.chkfile:
                self.chkReporter = CheckpointReporter(self.chkfile, save)
            else:
                self.txt.write("Not checkpointing since no checkpoint file name was provided.\n")
        # Do not open files unnecessarily
        save = self.sim_params.getInt('savePdb')
        self.pdbReporter = None
        if save > 0 and self.steps >= save:
            self.pdbReporter = PDBReporter(self.pdbtraj, save)
        else:
            self.pdbtraj = None

    def make_system(self):
        # TOPOLOGY
        ################################################
        topology  = self.pdb.topology
        positions = self.pdb.positions
        self.modeller  = Modeller(topology, positions)
        self.modeller.addExtraParticles(self.forcefield)
        self.topology  = self.modeller.topology
        self.positions = self.modeller.positions
        if self.verbose:
            self.txt.write("There are %d particles.\n" % len(self.positions))
        myDrudeMass    = self.sim_params.getFloat('drudeMass', 0.1)
        self.EwaldErrorTolerance = self.sim_params.getFloat('ewaldErrorTolerance')
        self.alphaPME  = math.sqrt(-math.log(self.EwaldErrorTolerance*2))/self.nonbondedCutoff
        #self.rigidWater = False
        rmcom           = True
        if self.nonbondedMethod == NoCutoff:
            rmcom = False
        if self.verbose:
            self.txt.write("Using flexible water (if present).\n")
        if self.polarizable:
            self.system = self.forcefield.createSystem(self.topology,
                                                       nonbondedMethod=self.nonbondedMethod,
                                                       nonbondedCutoff=self.nonbondedCutoff,
                                                       removeCMMotion=rmcom,
                                                       ewaldErrorTolerance=self.EwaldErrorTolerance,
                                                       constraints=self.constraints,
                                                       rigidWater=self.rigidWater,
                                                       drudeMass=myDrudeMass*unit.amu)
            if self.verbose:
                self.txt.write("The force field is polarizable and the drude mass is %g.\nMake sure it is consistent with your force field file.\n" % myDrudeMass)
        else:
            self.system = self.forcefield.createSystem(self.topology,
                                                       nonbondedMethod=self.nonbondedMethod,
                                                       nonbondedCutoff=self.nonbondedCutoff,
                                                       removeCMMotion=rmcom,
                                                       ewaldErrorTolerance=self.EwaldErrorTolerance,
                                                       constraints=self.constraints,
                                                       rigidWater=self.rigidWater)
            if self.verbose:
                self.txt.write("The force field is NOT polarizable.\n")

        self.count_forces("Initial")
    
    def find_shells_cores(self, drudeforce):
        self.cores = []
        self.shells = []
        self.core_shell = []
        self.my_core  = {}
        self.my_shell = {}
        for index in range(drudeforce.getNumParticles()):
            [particle, particle1, particle2, particle3, particle4, charge, pol, aniso12, aniso34] = drudeforce.getParticleParameters(index)
            self.shells.append(particle) # particle  = shell
            self.cores.append(particle1) # particle1 = core
            self.my_core[particle] = particle1
            self.my_shell[particle1] = particle
            self.core_shell.append((particle,particle1))
        if self.debug:
            # Checking correct atom/shell pairing
            self.txt.write(f"cores      {self.cores}\n")
            self.txt.write(f"shells     {self.shells}\n")
            self.txt.write(f"core_shell {self.core_shell}\n")
            self.txt.write("########################\n")
                
    # CODE FOR ALEXANDRIA NONBONDED FORCES
    ################################################
    def init_forces(self):
        """
        TODO: Update comment
        Create a CustomNonbondedForce to calculate the direct-space forces of the Alexandria
        Van der Waals potential as well (Gaussian distributed charge) Coulomb,
        placing it in specified force groups.
        The LJ and point charge is used for both the dispersion correction and for LJPME and PME
        and a correction is needed for the exclusioms.
        Create a CustomBondForce to calculate the direct space force of WBHAM and gaussian Coulomb for interactions
        that are excluded (besides core-shell interactions).
        """
        cnbname       = "CustomNonbondedForce"
        dforce        = "DrudeForce"
        DDDforce      = "CustomManyParticleForce"
        forces        = {}
        self.customnb = None
        drudeforce    = None
        for force in self.system.getForces():
            fname = force.getName()
            if self.debug:
                self.txt.write("Found force %s\n" % fname)
            forces[fname] = force
            if cnbname == fname:
                self.customnb = forces[cnbname]
            elif dforce == fname:
                drudeforce = forces[dforce]
            # three body dispersion
            if DDDforce == fname:
                self.CustomDDDforce = forces[DDDforce]
                self.add_force_group(self.CustomDDDforce, True, False)
        self.count_forces("Direct space 1")
        # There always is a regular NonbondedForce
        self.nonbondedforce  = forces['NonbondedForce']
        # Check whether the user wants us to use OpenMM forces or ACT forces
        # If we should use OpenMMForce routines
        nonbond_direct = True
        if not self.useOpenMMForce:
            self.nonbondedforce.setIncludeDirectSpace(False)
            nonbond_direct = False
        self.add_force_group(self.nonbondedforce, nonbond_direct, False)
        if drudeforce and not self.polarizable:
            sys.exit("There are drudes in the system but you forgot the -pol flag or something like that")
        if self.verbose:
            self.txt.write("***************************\n")
            self.txt.write(f"Number of particles (incl. vsites and drudes):  {self.system.getNumParticles()}\n")
        self.count_forces("Direct space 2")
        if self.polarizable:
            self.add_force_group(drudeforce, False, False)
            self.find_shells_cores(drudeforce)
        else:
            self.my_shell = None
        self.count_forces("Direct space 3")

    def makeVdWFunc(self):
        dictkey              = dictVdW[self.vdw]
        vdwParamNames        = VdWdict[dictkey]["params"]
        expression           = ( "%s" % VdWdict[dictkey]["expression"] )
        # Not a whole lot of documentation around, but this seems OK.
        # Have to verify that it is the same in OpenMM though.
        # https://manual.gromacs.org/documentation/2019/reference-manual/functions/long-range-vdw.html
        self.vdw_pme_corr_expression = None
        if self.nonbondedMethod == LJPME:
            self.vdw_pme_corr_expression = ( "((1 - exp(-(%s*r)^2)*(1 + (%s*r)^2 + 0.5*(%s*r)^4))*c6/r^6)" %
                                             ( self.alphaPME, self.alphaPME, self.alphaPME) )
            if self.debug:
                self.txt.write("DBG: vdw_pme_corr_expression '%s'\n" % self.vdw_pme_corr_expression)
            expression += " - "+self.vdw_pme_corr_expression
        expression += ";"
        self.vdw_expression  = expression
        if self.debug:
            self.txt.write("DBG: vdw_expression '%s'\n" % self.vdw_expression)
        if self.useOpenMMForce:
            return

        combdict             = self.comb.combStrings()
        # The statements have to be in this order! They are evaluated in the reverse order apparently.
        if VdW.WBHAM == self.vdw:
            expression += ( 'gamma3   = (gamma/(3+gamma));')
        for pp in vdwParamNames:
            expression += ( '%s    = %s;' % ( pp, combdict[pp] ))
        if self.nonbondedMethod == LJPME:
            expression += ( 'c6 = sqrt(c61*c62);' )
        self.custom_vdw = openmm.CustomNonbondedForce(expression)
        self.custom_vdw.setName("VanderWaals"+dictVdW[self.vdw])
        for pp in vdwParamNames:
            self.custom_vdw.addPerParticleParameter(pp)
        if self.nonbondedMethod == LJPME:
            self.custom_vdw.addPerParticleParameter("c6")

        if self.debug:
            for i in range(self.custom_vdw.getNumPerParticleParameters()):
                self.txt.write("Parameter %d %s\n" % ( i, self.custom_vdw.getPerParticleParameterName(i)))
        for index in range(self.nonbondedforce.getNumParticles()):
            [ charge, sigma, epsilon ] = self.nonbondedforce.getParticleParameters(index)
            if self.useOpenMMForce or not self.customnb:
                ppp = [ sigma._value, epsilon._value ]
            else:
                ppp = list(self.customnb.getParticleParameters(index))
            ppp = ppp[:len(vdwParamNames)]
            # Compute the c6 for LJPME correction
            if self.nonbondedMethod == LJPME:
                ppp.append(4*epsilon._value*sigma._value**6)

            self.custom_vdw.addParticle(ppp)
            if self.debug:
                self.txt.write("index %d" % index)
                myparm = self.custom_vdw.getParticleParameters(index)
                for mypp in range(self.custom_vdw.getNumPerParticleParameters()):
                    self.txt.write(" %s %g" % ( self.custom_vdw.getPerParticleParameterName(mypp),
                                                myparm[mypp] ) )
                self.txt.write("\n")

    def do_force_settings(self, force):
        if self.nonbondedMethod == NoCutoff:
            force.setNonbondedMethod(openmm.CustomNonbondedForce.NoCutoff)
        elif not self.useOpenMMForce:
            force.setNonbondedMethod(openmm.CustomNonbondedForce.CutoffPeriodic)
        if self.nonbondedforce != force:
            for index in range(self.nonbondedforce.getNumExceptions()):
                [iatom, jatom, qprod, sigma, epsilon] = self.nonbondedforce.getExceptionParameters(index)
                force.addExclusion(iatom, jatom)
                if self.debug:
                    self.txt.write("%s excl iatom %d jatom %d\n" %
                                   ( force.getName(), iatom, jatom ))
        force.setCutoffDistance(self.nonbondedforce.getCutoffDistance())
        if self.sim_params.getBool('useSwitchingFunction', False):
            force.setUseSwitchingFunction(True)
            force.setSwitchingDistance(self.sim_params.getFloat('SwitchDistance', 0))
        useDispCorr = self.sim_params.getBool('useDispersionCorrection', False)
        if hasattr(force, 'setUseDispersionCorrection'):
            force.setUseDispersionCorrection(useDispCorr)
        elif hasattr(force, 'setLongRangeCorrection'):
            force.setUseLongRangeCorrection(useDispCorr)
        if hasattr(force, 'setReactionFieldDielectric'):
            if 'dielectricConstant' in self.sim_params.params:
                force.setReactionFieldDielectric(self.sim_params.getFloat('dielectricConstant'))
        if self.verbose:
            if hasattr(force, "getNumExclusions"):
                nexcl = force.getNumExclusions()
            else:
                nexcl = force.getNumExceptions()
            self.txt.write("There are %d particles in %s and %d exclusions\n" %
                           ( force.getNumParticles(), force.getName(), nexcl ))
    
    def add_custom_forces(self):
        if self.useOpenMMForce:
            self.do_force_settings(self.nonbondedforce)
            return

        expression = None
        # OpenMM uses Reaction Field if a Cutoff is specified. Even with
        # a dielectric constant of 1, there is a constant off-set in the
        # energy we have to take into account. If the dielectric constant
        # is NOT 1, this will not work.
        # http://docs.openmm.org/7.1.0/userguide/theory.html#coulomb-interaction-with-cutoff
        if ('dielectricConstant' in self.sim_params.params and 
            1 != self.sim_params.getFloat('dielectricConstant')):
            sys.exit("No support for dielectric constant other than 1.0 with custom forces")

        elec_string  = ""
        if self.nonbondedMethod in [ PME, LJPME ]:
            elec_string = ("((1-erf(%s*r))/r)" % self.alphaPME)
        elif self.nonbondedMethod in [ CutoffNonPeriodic, CutoffPeriodic ]:
            elec_string = ("(1/r-%g)" % ( 1.0/self.nonbondedCutoff ))
        else:
            elec_string = ("(1/r)")
        if qDist.Gaussian == self.qdist:
            # Electrostatics is our screened Coulomb minus the point charge based potential
            expression          = ( "(%s*charge1*charge2*Gaussian*%s);" %
                                    ( ONE_4PI_EPS0, elec_string ) )
            expression         += ( "Gaussian = %s;" % self.comb.gaussianString())
        elif qDist.Point == self.qdist:
            # Or a simple point charge
            expression = ( '(%s*charge1*charge2*%s);' % ( ONE_4PI_EPS0, elec_string  ) )
        self.qq_expression  = expression

        self.custom_coulomb = openmm.CustomNonbondedForce(expression)
        self.custom_coulomb.setName("Coulomb"+dictQdist[self.qdist])
        if self.debug:
            self.txt.write("Created function %s '%s'\n" % ( self.custom_coulomb.getName(), expression))
        self.custom_coulomb.addPerParticleParameter("charge")
        if qDist.Point != self.qdist:
            self.custom_coulomb.addPerParticleParameter("zeta")

        self.charges = []
        for index in range(self.nonbondedforce.getNumParticles()):
            if self.useOpenMMForce or not self.customnb:
                myparams = self.nonbondedforce.getParticleParameters(index)
            else:
                myparams = self.customnb.getParticleParameters(index)
            if self.vdw == VdW.LJ12_6:
                charge = myparams[0]._value
            elif len(myparams) == len(VdWdict[dictVdW[self.vdw]]["params"])+2:
                charge = myparams[-2]
                zeta   = myparams[-1]
            else:
                sys.exit("Not implemented how to extract charge (and zeta)")
            self.charges.append(charge)
            if qDist.Point == self.qdist:
                self.custom_coulomb.addParticle([charge])
            else:
                self.custom_coulomb.addParticle([charge, zeta])
            self.txt.write("Adding %s charge %g to particle %d\n" % ( dictQdist[self.qdist], charge, index ))

        # Van der Waals, is our custom potential minus the default LJ.
        self.makeVdWFunc() 

        # General settings for non-bonded potentials
        for force in [ self.custom_vdw, self.custom_coulomb ]:
            self.do_force_settings(force)
            # Finally add it to the system forces. Well done!
            nb_direct = False
            self.add_force_group(force, nb_direct, True)
            self.system.addForce(force)

    #################################################


    def real_exclusion(self, nexcl:int, iatom:int, jatom:int)->bool:
        #return False
        #return iatom == jatom
        if self.system.isVirtualSite(iatom) or self.system.isVirtualSite(jatom):
            return True
        if nexcl == 0:
            return False
        else:
            # If we have an exclusion between two bonded atoms
            # we have to exclude the shells as well. Therefore
            # we first look up the cores for the atom numbers
            # that are passed to this routine.
            icore = iatom
            jcore = jatom
            if self.polarizable:
                if iatom in self.shells:
                    icore = self.my_core[iatom]
                if jatom in self.shells:
                    jcore = self.my_core[jatom]
            if self.debug:
                self.txt.write("DBG: Checking iatom %d icore %d jatom %d jcore %d\n" %
                               ( iatom, icore, jatom, jcore ))
            if (icore == jcore or (icore,jcore) in self.bonds or (jcore,icore) in self.bonds):
                return True
            elif nexcl == 2:
                excl = False
                for a in self.angles:
                    if (a[0] == icore and a[2] == jcore) or (a[2] == icore and a[0] == jcore):
                        excl = True
                return excl

        return False

    def add_excl_correction(self):
        # Add vdW and electrostactics that have been excluded.
        # This has to be done as the number of exclusions is 3 for 
        # nonbonded interactions in OpenMM and it likely less in ACT.
        # These interactions are added using two CustomBondForce entries.
        vdw_excl_corr = None
        dictkey       = dictVdW[self.vdw]
        if not self.useOpenMMForce:
            vdw_excl_corr = openmm.CustomBondForce(self.vdw_expression)
            vdw_excl_corr.setName("VanderWaalsExclusionCorrection")
            for pp in VdWdict[dictkey]["params"]:
                vdw_excl_corr.addPerBondParameter(pp)

        # Information on how to use PME with custom Coulomb
        # https://github.com/openmm/openmm/issues/3676
        # PME uses full charges, so subtract those.
        # TODO fetch this number from system.context
        # Now corrections for PME, dispersion only. TODO: This needs the erf function!
        vdw_pme_corr = None
        if self.nonbondedMethod == LJPME and not self.useOpenMMForce and self.vdw_pme_corr_expression:
            vdw_pme_corr = openmm.CustomBondForce("%s" % self.vdw_pme_corr_expression)
            vdw_pme_corr.setName("VanderWaalsPMEExclusionCorrection")
            vdw_pme_corr.addPerBondParameter("c6")

        if False:
            if self.nonbondedMethod == LJPME:
                param = self.nonbondedforce.getLJPMEParametersInContext(self.simulation.context)
                if self.debug:
                    self.txt.write("DBG: LJPME parameters {}\n".format(param))
                self.alphaPME = param[0]
            elif self.nonbondedMethod == PME:
                param = self.nonbondedforce.getPMEParametersInContext(self.simulation.context)
                if self.debug:
                    self.txt.write("DBG: PME parameters {}\n".format(param))
                self.alphaPME = param[0]
        self.txt.write("Found PME spreading alpha = %g\n" % self.alphaPME)

        qq_pme_corr = None
        qq_pme_self = None
        if self.nonbondedMethod in [ PME, LJPME ] and not self.useOpenMMForce:
            # Essmann1995, eqn. 2.5
            # The factor 1/2 is taken into acount by including the exclusions
            # in one direction only.
            qq_recip_corr = ( "-(%s*charge1*charge2*erf(%s*r)/r)" % ( ONE_4PI_EPS0, self.alphaPME ) )
            if self.verbose:
                self.txt.write("qq_recip_corr '%s'\n" % qq_recip_corr)
            qq_pme_corr  = openmm.CustomBondForce(qq_recip_corr)
            qq_pme_corr.setName("CoulombPMEExclusionCorrection")
            qq_pme_corr.addPerBondParameter("charge1")
            qq_pme_corr.addPerBondParameter("charge2")
            # OpenMM uses point charges for PME. No need to correct for this though.
            # Eqn. 2.5 in Essmann1995a
            if False:
                self_str = ("-%g*charge^2;" % ( 2*self.alphaPME*ONE_4PI_EPS0/math.sqrt(math.pi) ) )
                qq_pme_self = openmm.CustomCompoundBondForce(1, self_str)
                qq_pme_self.addPerBondParameter("charge")
                qq_pme_self.setName("CoulombPMESelfEnergy")

        qq_excl_corr = None
        if not self.useOpenMMForce:
            if self.qdist == qDist.Point:
                myexpression =  ( "(%s*charge1*charge2/r)" % ( ONE_4PI_EPS0 ) )
            else:
                myexpression =  ( "(%s*charge1*charge2*Gaussian/r)" % ( ONE_4PI_EPS0 ) )
            qq_excl_corr = openmm.CustomBondForce(myexpression)
            qq_excl_corr.setName("CoulombExclusionCorrection")
            qq_excl_corr.addPerBondParameter("charge1")
            qq_excl_corr.addPerBondParameter("charge2")
            if self.qdist != qDist.Point:
                qq_excl_corr.addPerBondParameter("zeta")
            self.txt.write("Made qq_excl_corr\n")
        
        nexclvdw = self.sim_params.getInt("nexclvdw")
        nexclqq  = self.sim_params.getInt("nexclqq")
        combdict = self.comb.combStrings()

        if self.debug:
            for param in combdict:
                self.txt.write("%s   = %s\n" % ( param, combdict[param] ))

        for index in range(self.nonbondedforce.getNumExceptions()):

            # Just get the excluded atoms from the regular NB force
            iatom, jatom, *_ = self.nonbondedforce.getExceptionParameters(index)
            if self.debug:
                self.txt.write("iatom %d jatom %d\n" % ( iatom, jatom ))

            if self.vdw == VdW.LJ12_6:
                # Get the parameters from the standard NB force
                *iparameters, = self.nonbondedforce.getParticleParameters(iatom)
                *jparameters, = self.nonbondedforce.getParticleParameters(jatom)
            else:
                # or get the parameters from the Custom NB force
                *iparameters, = self.customnb.getParticleParameters(iatom)
                *jparameters, = self.customnb.getParticleParameters(jatom)
                if self.debug:
                    self.txt.write(f" custom nonbonded force i {self.customnb.getParticleParameters(iatom)}\n")
                    self.txt.write(f" custom nonbonded force j {self.customnb.getParticleParameters(jatom)}\n")
            allParam = {}
            for parameter, idx in parameter_indices[self.vdw].items():
                allParam[parameter] = [ iparameters[idx], jparameters[idx] ]

            # Coulomb part
            # When using PME, add the PME exclusion, independent of our own exclusion settings
            if qq_pme_corr:
                qq_pme_corr.addBond(iatom, jatom, [allParam["charge"][0], allParam["charge"][1]])
                if self.debug:
                    self.txt.write("Adding Coul PME corr i %d j %d q1 %g q2 %g\n" %
                                   ( iatom, jatom, allParam["charge"][0], allParam["charge"][1] ))
            # Now check wheter our exclusions are fewer than OpenMM
            if qq_excl_corr and not self.real_exclusion(nexclqq, iatom, jatom):
                if not "zeta" in allParam or (0 == allParam["zeta"][0] * allParam["zeta"][1]):
                    zeta = 0
                else:
                    zeta = ((allParam["zeta"][0] * allParam["zeta"][1])/
                            (math.sqrt(allParam["zeta"][0]**2 + allParam["zeta"][1]**2)))
                if self.qdist == qDist.Point:
                    qq_excl_corr.addBond(iatom, jatom, [allParam["charge"][0], allParam["charge"][1]])
                else:
                    qq_excl_corr.addBond(iatom, jatom, [allParam["charge"][0], allParam["charge"][1], zeta])
                if self.debug:
                    self.txt.write("Adding Coul excl corr i %d j %d q1 %g q2 %g zeta %g\n" %
                                   ( iatom, jatom, allParam["charge"][0], allParam["charge"][1], zeta))

            # Van der Waals part
            # Always add the PME exclusion, independent of our own exclusion settings
            # And get the parameters from the Custom NB force
            if vdw_pme_corr:
                iLJ12_6 = self.nonbondedforce.getParticleParameters(iatom)
                jLJ12_6 = self.nonbondedforce.getParticleParameters(jatom)
                # Use geometric combination rule
                sigma   = math.sqrt(iLJ12_6[1]._value*jLJ12_6[1]._value)
                epsilon = math.sqrt(iLJ12_6[2]._value*jLJ12_6[2]._value)
                c6 = 4*epsilon*sigma**6
                vdw_pme_corr.addBond(iatom, jatom, [ c6 ])
                if self.debug:
                    self.txt.write("Adding vdw_pme_corr iatom %d jatom %d sigma %g epsilon %g c6 %g\n" % ( iatom, jatom, sigma, epsilon, c6 ))
            if vdw_excl_corr and self.vdw in [VdW.WBHAM, VdW.GBHAM, VdW.LJ14_7]:

                if (not self.real_exclusion(nexclvdw, iatom, jatom) and 
                    allParam["epsilon"][0] > 0 and 
                    allParam["epsilon"][1] > 0):

                    allXXX = self.comb.combFloats(allParam)
                    vdW_parameters      = []
                    for parameter in VdWdict[dictkey]["params"]:
                        myvdw = allXXX[parameter]
                        if self.debug:
                            self.txt.write("DBG: param %s myvdw %s\n" % ( parameter, myvdw ))
                        vdW_parameters.append(myvdw)
                    if self.nonbondedMethod == LJPME:
                        vdW_parameters.append(0)
                    vdw_excl_corr.addBond(iatom, jatom, vdW_parameters)
                    if self.debug:
                        msg = "Adding VDW excl i %d j %d" % (iatom, jatom)
                        k   = 0
                        for parameter in VdWdict[dictkey]["params"]:
                            msg += " %s %g" % (parameter, vdW_parameters[k])
                            k   += 1
                        self.txt.write("%s\n" % msg)

        # Finally single particle self interaction
        # This is not needed. Throw away?
        if qq_pme_self:
            for index in range(self.nonbondedforce.getNumParticles()):
                [ charge, _, _ ] = self.nonbondedforce.getParticleParameters(index)
                # Since the addBond routine cannot know how many atoms are
                # part of this, atoms have to be specified as a list.
                qq_pme_self.addBond([ index ], [ charge ])

        # Finish off. Did we add any exclusion or PME corrections?
        for myforce in [ qq_excl_corr, qq_pme_corr, qq_pme_self,
                         vdw_excl_corr, vdw_pme_corr ]:
            if myforce and 0 < myforce.getNumBonds():        
                self.add_force_group(myforce, False, True)
                self.system.addForce(myforce)
                mystring = ( "%s %d entries" % ( myforce.getName(), myforce.getNumBonds()))
                self.count_forces(mystring)

    def add_bonded_forces(self):
        self.bonds      = []
        self.bond_force = None
        cbfname = 'CustomBondForce'
        hbfname = 'HarmonicBondForce'
        # pairs without constraints
        for bond_force in self.system.getForces():
            if  bond_force.getName() in [ cbfname, hbfname ]:
                if self.verbose:
                    self.txt.write("Found %s\n" % bond_force.getName())
                if cbfname == bond_force.getName():
                    bond_force.setName("AlexandriaBonds")
                self.count_forces("Add Bondeds")
                self.add_force_group(bond_force, False, False)
                for bond_index in range(bond_force.getNumBonds()):
                    # Retrieve atoms (and parameters but we just want the bonds now).
                    bondinfo = bond_force.getBondParameters(bond_index)
                    if self.debug:
                        self.txt.write("DBG: bondinfo {}\n".format(bondinfo))
                    self.bonds.append((bondinfo[0], bondinfo[1]))
                self.bond_force = bond_force
        # pairs with constraints
        for index in range(self.system.getNumConstraints()):
            iatom, jatom, _ = self.system.getConstraintParameters(index)
            self.bonds.append((iatom, jatom))
        self.angles     = []
        for b1 in self.bonds:
            for b2 in self.bonds:
                if b1[0] == b2[0] and b1[1] < b2[1]:
                    self.angles.append(( b1[1], b1[0], b2[1] ))
                elif b1[0] == b2[1] and b1[1] < b2[0]:
                    self.angles.append(( b1[1], b1[0], b2[0] ))
                elif b1[1] == b2[0] and b1[0] < b2[1]:
                    self.angles.append(( b1[0], b1[1], b2[1] ))
                elif b1[1] == b2[1] and b1[0] < b2[0]:
                    self.angles.append(( b1[0], b1[1], b2[0] ))
        if self.debug:
            for b in self.bonds:
                self.txt.write("bond %d %d\n" % ( b[0], b[1] ))
            for a in self.angles:
                self.txt.write("angle %d %d %d\n" % ( a[0], a[1], a[2] ))

    def make_forces(self):
        # Create a new CustomNonbondedForce to mimic the direct space 
        self.add_custom_forces()
        self.add_bonded_forces()
        #printing of details for many particle force from force field 
        for g in self.forcefield.getGenerators():
            if isinstance(g, forcefield.CustomManyParticleGenerator):
                print(g.__dir__())
                self.txt.write("Many particle force detected in the force field. Following lines concern this force:\n")
                self.txt.write(f"This is the global C9 parameter {g.globalParams['C9']}\n")
                self.txt.write(f"This is the permutation mode index {g.permutationMode}\n")
                self.txt.write(f"This is the particle per set number {g.particlesPerSet}\n")
                self.txt.write(f"This is the bond cutoff {g.bondCutoff}\n")
                self.txt.write(f"Finally, this is the energy expression:  {g.energy}\n")
        for force in self.system.getForces():
            if (force.getName() in [ "CustomAngleForce", "HarmonicAngleForce" ] and
                0 == force.getNumAngles()):
                self.del_force(force)
            elif (force.getName() in [ "RBTorsionForce", "PeriodicTorsionForce" ] and
                  0 == force.getNumTorsions()):
                self.del_force(force)
            elif force.getName() == "CMMotionRemover":
                force.setFrequency(self.sim_params.getInt('commremoval_frequency', 10))
                if force.getFrequency() <= 0:
                    self.del_force(force)

    def print_force_settings(self):
        for force in self.system.getForces():
            self.txt.write("----------------------------\n")
            self.txt.write("%s Group: %d, PBC: %s\n" % ( force.getName(), 
                                                         force.getForceGroup(),
                                                         str(force.usesPeriodicBoundaryConditions())))
            if hasattr(force, 'getEnergyFunction'):
                self.txt.write('Expression {0}\n'.format(force.getEnergyFunction()))
            if hasattr(force, 'getNumPerParticleParameters'):
                self.txt.write("Parameter")
                for i in range(force.getNumPerParticleParameters()):
                    self.txt.write(" %d %s" % ( i, force.getPerParticleParameterName(i)))
                self.txt.write("\n")
            if hasattr(force, 'getNonbondedMethod'):
                self.txt.write('NonbondedMethod {0}\n'.format(force.getNonbondedMethod()))
            if hasattr(force, 'getCutoffDistance'):
                self.txt.write('Cutoff {0}\n'.format(force.getCutoffDistance()))
            if hasattr(force, 'getUseSwitchingFunction'):
                self.txt.write('SwitchingFunction {0}\n'.format(force.getUseSwitchingFunction()))
            if hasattr(force, 'getSwitchingDistance'):
                self.txt.write('SwitchingDistance {0}\n'.format(force.getSwitchingDistance ()))
            if hasattr(force, "getUseDispersionCorrection"):
                self.txt.write('Dispersion Correction {0}\n'.format(force.getUseDispersionCorrection()))
            if hasattr(force, "getReciprocalSpaceForceGroup"):
                self.txt.write('Reciprocal Force Group {0}\n'.format(force.getReciprocalSpaceForceGroup()))
            if hasattr(force, "getUseLongRangeCorrection"):
                self.txt.write('UseLongRangeCorrection {0}\n'.format(force.getUseLongRangeCorrection()))
            if hasattr(force, "getReactionFieldDielectric"):
                self.txt.write("Reaction Field Epsilon {0}\n".format(force.getReactionFieldDielectric()))
            if hasattr(force, "getNumBonds"):
                self.txt.write("Number of bonds/pairs %d\n" % ( force.getNumBonds() ) )
            if hasattr(force, "getNumParticles"):
                self.txt.write("Number of particles %d\n" % force.getNumParticles())
            if hasattr(force, "getNumAngles"):
                self.txt.write("Number of angles %d\n" % ( force.getNumAngles()))
        self.txt.write("----------------------------\n")

    def set_algorithms(self):
        #### ethermostat / Barostat ####
        if self.nonbondedMethod != NoCutoff:
            if self.sim_params.getBool('useMonteCarloBarostat'):
                if self.verbose:
                    self.txt.write("Monte Carlo Barostat will be used.\n")
                self.system.addForce(MonteCarloBarostat(self.sim_params.getFloat('pressure'),
                                                        self.temperature_c,
                                                        self.sim_params.getInt('barostatInterval')))
            elif self.sim_params.getBool('useMonteCarloAnisotropicBarostat'):
                self.system.addForce(MonteCarloAnisotropicBarostat(self.pressvec,self.temperature_c,self.scaleX,self.scaleY,self.scaleZ,self.sim_params.getInt('barostatInterval'))) 
                if self.verbose:
                    self.txt.write(f"Monte Carlo ANISOTROPIC Barostat will be used. The dimensions that can change are: X = {self.scaleX} Y = {self.scaleY} Z = {self.scaleZ}\n")
        if self.useAndersenThermostat:
            self.system.addForce(AndersenThermostat(self.temperature_c, self.col_freq))
            if self.verbose:
                self.txt.write(f"Andersen Thermostat will be used with temperature {self.temperature_c}\n")

        #### Integrator ####
        friction_c    = self.sim_params.getFloat('friction_c')
        temperature_s = self.sim_params.getFloat('temperature_s')
        integrator    = self.sim_params.getStr('integrator')
        if self.polarizable:
            dli = "DrudeLangevinIntegrator"
            if dli == integrator:
                self.integrator = DrudeLangevinIntegrator(self.temperature_c, friction_c, temperature_s, 
                                                          self.sim_params.getFloat('friction_s'), self.dt)
            elif "DrudeNoseHooverIntegrator" == integrator:
                self.integrator = DrudeNoseHooverIntegrator(self.temperature_c, friction_c, temperature_s, 
                                                            self.sim_params.getFloat('friction_s'), self.dt)
            elif "DrudeSCFIntegrator" == integrator:
                self.integrator = DrudeSCFIntegrator(self.dt)
                self.integrator.setDrudeTemperature(temperature_s)
            else:
                self.txt.write("Unsupported integrator %s for polarizable system, will use %s instead\n"
                               % ( integrator, dli ))
                self.integrator = DrudeLangevinIntegrator(self.temperature_c, friction_c, temperature_s,
                                                          self.sim_params.getFloat('friction_s'), self.dt)
            if self.useAndersenThermostat and not "DrudeSCFIntegrator" == integrator:
                self.txt.write("Andersen thermostat will be turned off since %s contains a built-in thermostat.\n"
                               % self.integrator)
                self.useAndersenThermostat = False
            self.integrator.setMaxDrudeDistance(self.maxDrudeDist)
        else:
            nhi = "NoseHooverIntegrator"
            if nhi != integrator:
                self.txt.write("Unsupported integrator %s for non-polarizable system, will use %s instead\n"
                               % ( integrator, nhi ))
            self.integrator = NoseHooverIntegrator(self.temperature_c, friction_c, self.dt)

        # Print some stuff yey.
        if self.verbose:
            self.txt.write("Core Temperature %g\n" % self.temperature_c)
            if self.polarizable:
                self.txt.write("Drude Temperature %g\n" % self.integrator.getDrudeTemperature()._value)
            self.txt.write("Step size %g\n" % self.integrator.getStepSize()._value)

    def compute_dipole(self)->list:
        positions = self.simulation.context.getState(getPositions=True).getPositions()
        dip = [ 0, 0, 0 ]
        enm2Debye = 48.0321
        for index in range(self.system.getNumParticles()):
            for m in range(3):
                dip[m] += positions[index][m]._value * self.charges[index] * enm2Debye
        self.txt.write("\nDipole [ %g %g %g ] total %g\n" % ( dip[0], dip[1], dip[2], 
                                                              math.sqrt(dip[0]**2+dip[1]**2+dip[2]**2)))
        return dip

    def init_simulation(self):
        #### Simulation setup ####
        self.simulation = Simulation(self.topology, self.system, self.integrator, self.platform)
        self.simulation.context.setPositions(self.positions)
        # Check whether the use platform can change the precision at all.
        prec = "Precision"
        havePrecision = False
        for p in self.platform.getPropertyNames():
            v = self.platform.getPropertyValue(self.simulation.context, p)
            if self.debug:
                self.txt.write("Property %s value %s\n" % ( p, str(v) ))
            if prec == p:
                havePrecesion = True
        if havePrecision:
            self.platform.setPropertyValue(self.simulation.context, prec, self.usePrecision)

    def update_positions(self):
        #### Set positions of shell system to almost zero) ####
        #### the shell displacement is necessary for the LJPME to work, otherwise an error is thrown:
        #### simtk.openmm.OpenMMException: Particle coordinate is nan
        positions = self.simulation.context.getState(getPositions=True).getPositions()
        new_pos = []
        for index in range(self.system.getNumParticles()):
            if (not self.polarizable or not index in self.shells):
                new_pos_x = positions[index][0]
                new_pos.append((new_pos_x,positions[index][1],positions[index][2]))
            if (self.polarizable and index in self.shells):
                new_pos_x = positions[index][0]+0.001*nanometer
                new_pos_y = positions[index][1]+0.001*nanometer
                new_pos_z = positions[index][2]+0.001*nanometer
                new_pos.append((new_pos_x,new_pos_y,new_pos_z))

        self.simulation.context.setPositions(new_pos)
        if self.debug:
            self.txt.write(f"number of particles (incl. drudes):  {self.system.getNumParticles()}\n")
            for np in new_pos:
                self.txt.write("%10.5f  %10.5f  %10.5f\n" % ( np[0]._value, np[1]._value, np[2]._value ))

    def remove_unused_forces(self):
        if not self.useOpenMMForce and not self.nonbondedMethod in [ PME, LJPME ]:
            # Remove the default Non-Bonded with OpenMM
            self.txt.write("Will remove standard (OpenMM) NonBondedForce\n")
            self.del_force(self.nonbondedforce, False)
        # TODO check whether this if statement should be flipped.
        if self.customnb:
            self.txt.write("Will remove standard CustomNonBondedForce\n")
            self.del_force(self.customnb)

    def update_forces(self):
        for myforce in self.system.getForces():
            if myforce.getName() in self.fgnumber and not myforce.getName() in [ "CMMotionRemover", "MonteCarloAnisotropicBarostat", "MonteCarloBarostat" ]:
                if self.verbose:
                    self.txt.write("Will update force %s\n" % myforce.getName())
                myforce.updateParametersInContext(self.simulation.context)
        
        
    def dhvap(self, epot:float)->float:
        if None == self.emonomer:
            return None
        nmol    = self.topology.getNumResidues()
        relener = epot/nmol - self.emonomer
        kB      = 1.380649e-23 * 6.02214e23 / 1000
        return kB*self.temperature_c - relener
    
    def dump_forces(self):
        self.txt.write("DBG: Checking spurious energies\n")
        for force in self.system.getForces():
            fcname   = force.getName()
            fgnumber = force.getForceGroup()
            self.txt.write("DBG: Force %s number %d\n" % ( fcname, fgnumber ))
        for group in range(16):
            eterm = self.simulation.context.getState(getEnergy=True, groups=(1 << group)).getPotentialEnergy()/unit.kilojoule_per_mole
            self.txt.write('DBG: group %2d energy %16.4f kJ/mol\n' % (group, eterm))

    def print_energy(self, title:str):
        self.txt.write("\n%s:\n" % title)
        etot = 0.0
        self.count_forces("Print energy")
        if self.verbose:
            for myforce in self.system.getForces():
                self.txt.write("%s\n" % myforce.getName())
        epme = 0
        for group in self.force_group:
            eterm = self.simulation.context.getState(getEnergy=True, groups=(1 << group)).getPotentialEnergy()/unit.kilojoule_per_mole
            etot += eterm
            self.txt.write('%-40s %2d %16.8f kJ/mol\n' % (self.force_group[group], group, eterm))
        self.potE = self.simulation.context.getState(getEnergy=True).getPotentialEnergy()/unit.kilojoule_per_mole
        ener_diff = self.potE-etot
        self.txt.write('Potential energy = %.5f kJ/mol.' % self.potE )
        if self.potE != 0 and abs(ener_diff)/abs(self.potE) >= 1e-3:
            self.txt.write(' WARNING: potE-etot %.5f\n' % (ener_diff))
            self.dump_forces()
        else:
            self.txt.write("\n")
        if None != self.emonomer:
            nmol = self.topology.getNumResidues()
            einter = self.potE - nmol*self.emonomer
            self.txt.write('Interaction energy for %d-mer %g\n' % ( nmol, einter ))
            self.txt.write('Delta H vap %g kJ/mol\n' % ( self.dhvap(self.potE) ) )
        if abs(self.potE-etot) > 1e-3:
            self.txt.write("sum of the above %.5f\n" % (etot))
        self.txt.flush()

    def potential_energy(self)->float:
        return self.potE

    def minimize_energy(self, maxIter:int)->float:
        #### Minimize and Equilibrate ####
        self.txt.write('\nPerforming energy minimization using maxIter = %d.\n' % maxIter)
        enertol = Quantity(value=1e-8, unit=kilojoule/(nanometer*mole))
        self.simulation.minimizeEnergy(tolerance=enertol, maxIterations=maxIter)
        return self.simulation.context.getState(getEnergy=True).getPotentialEnergy()/unit.kilojoule_per_mole

    def set_positions(self, positions:list):
        oldpos = self.get_positions()
        if len(oldpos) != len(positions):
            sys.exit("System has %d coordinates, but you are trying to set %d" % ( len(oldpos), len(positions )))
        self.simulation.context.setPositions(positions)

    def get_positions(self)->list:
        return self.simulation.context.getState(getPositions=True).getPositions()

    def get_residue_positions(self, resnr:int)->list:
        allpos = self.get_positions()
        respos = []
        for res in self.topology.residues():
            if res.index == resnr:
                for atom in res.atoms():
                    respos.append(allpos[atom.index])

        return respos

    def minimize_shells(self)->float:
        # Store atom masses
        oldmass = {}
        for res in self.topology.residues():
            for atom in res.atoms():
                if atom.element:
                    oldmass[atom.index] = self.system.getParticleMass(atom.index)
                    self.system.setParticleMass(atom.index, 0)
        # Compute energy after just minimizing shells
        ener = self.minimize_energy(0)
        # Restore atom masses
        for res in self.topology.residues():
            for atom in res.atoms():
                if atom.element:
                    self.system.setParticleMass(atom.index, oldmass[atom.index])
        return ener

    def equilibrate(self):
        self.txt.write('\nEquilibrating for %d steps at T = %g K.\n' % ( self.equilibrationSteps, self.temperature_c) )
        self.simulation.context.setVelocitiesToTemperature(self.temperature_c)
        self.simulation.step(self.equilibrationSteps)
    
    def production(self):
        simtime = self.sim_params.getFloat('dt')*self.sim_params.getInt('steps')
        self.txt.write('\nSimulating %g ps at %g K...\n' % (simtime, self.temperature_c ))
        if None != self.dcdReporter:
            self.simulation.reporters.append(self.dcdReporter)
        if None != self.dataReporter:
            self.simulation.reporters.append(self.dataReporter)
        if None != self.pdbReporter:
            self.simulation.reporters.append(self.pdbReporter)
        if None != self.chkReporter:
            self.simulation.reporters.append(self.chkReporter)
        self.simulation.currentStep = 0
        self.simulation.step(self.steps)

    def setup(self):
        self.set_params()
        self.start_output()
        self.make_system()
        self.set_algorithms()
        self.init_forces()
        self.make_forces()
        self.add_excl_correction()
        self.remove_unused_forces()
        self.print_force_settings()
        self.init_simulation()
        self.update_forces()
        self.update_positions()
        if self.verbose:
            self.print_force_settings()
        self.print_energy("Initial energies")

    def minimize(self, maxIter:int=0)->float:
        epot = self.minimize_energy(maxIter)
        self.print_energy("After minimization")
        return epot
    
    def write_coordinates(self, outfile:str):
        format = outfile[-3:]
        with open(outfile, "w") as outf:
            pbc = False
            if self.nonbondedMethod != NoCutoff:
                vecs = self.simulation.context.getState().getPeriodicBoxVectors()
                self.topology.setPeriodicBoxVectors(vecs)
                pbc = True
            positions = self.simulation.context.getState(getPositions=True, enforcePeriodicBox=pbc, getParameters=True).getPositions()
            if "pdb" == format:
                self.pdb.writeFile(self.topology, positions, outf)
            elif "xyz" == format:
                write_xyz(outf, self.topology, positions)
            else:
                write_sdf(outf, self.topology, positions, self.charges, self.bonds, self.my_shell)

    def run(self):
        self.setup()
        # load previous state; no equilibration
        if self.chkReporter and self.chkfile and os.path.isfile(self.chkfile):
            with open(self.chkfile, 'rb') as chk:
                self.simulation.context.loadCheckpoint(chk.read())
            self.print_energy("After loading checkpoint")
        # start fresh; start by equilibration
        else:
            self.minimize(maxIter=100)
            self.equilibrate()
            self.print_energy("After equilibration")
        # reset time (former outputs will be overwritten anyway)
        self.simulation.context.setTime(0.0)
        # finally, run production
        self.production()
        self.print_energy("After production")

    def act_charges(self)->str:
        # Return all charges in ACT order, that is
        # Core Shell Core Shell Vsite Core Shell etc.
        charges = ""
        if self.polarizable:
            for i in range(len(self.charges)):
                if i in self.cores:
                    charges += " " + str(self.charges[i])
                    # Check whether there is a shell
                    if i in self.my_shell:
                        charges += " " + str(self.charges[self.my_shell[i]])
                elif not i in self.shells:
                    # We found something that is neither core nor shell.
                    # Likely a vsite.
                    charges += " " + str(self.charges[i])
                
        else:
            for i in range(len(self.charges)):
                charges += " " + str(self.charges[i])
        return charges

    def log_to_xvg(self, xvg:str, ytargets:list):
        if None == self.enefile or not os.path.exists(self.enefile):
            print("Could not find any log file")
        else:
            xtarget  = "Time (ps)"
            ix = -1
            iy = []
            with open(xvg, "w") as outf:
                outf.write("@ xaxis label \"%s\"\n" % xtarget)
                with open(self.enefile, "r") as inf:
                    for line in inf:
                        words = line.strip().split(";")
                        if line.find("#") >= 0:
                            for i in range(len(words)):
                                if words[i].find(xtarget) >= 0:
                                    ix = i
                                else:
                                    for j in range(len(ytargets)):
                                        if words[i].find(ytargets[j]) >= 0:
                                            iy.append(i)
                        elif ix >= 0 and len(iy) > 0:
                            try:
                                outf.write("%10g" % float(words[ix]))
                                for ii in iy:
                                    outf.write("  %10g" % (float(words[ii])))
                                outf.write("\n")
                            except ValueError:
                                print("Incomprehensible line in ene_file %s" % self.enefile)
                                
    def log_to_average(self, ytargets:dict)->dict:
        if None == self.enefile or not os.path.exists(self.enefile):
            print("Could not find any log file")
            return []
        else:
            myaver  = {}
            for i in ytargets.keys():
                myaver[i] = 0
            naver   = 0
            xtarget = "Time (ps)"
            ix      = -1
            iy      = {}
            iy_rev  = {}
            with open(self.enefile, "r") as inf:
                for line in inf:
                    words = line.strip().split(";")
                    if line.find("#") >= 0:
                        for i in range(len(words)):
                            if words[i].find(xtarget) >= 0:
                                ix = i
                            else:
                                for j in ytargets.keys():
                                    if words[i].find(ytargets[j]) >= 0:
                                        iy[j]     = i
                                        iy_rev[i] = j
                    elif ix >= 0 and len(iy.keys()) > 0:
                        try:
                            for ii in iy.keys():
                                myaver[iy_rev[iy[ii]]] += float(words[iy[ii]])
                            naver += 1
                        except ValueError:
                            print("Incomprehensible line in ene_file %s" % self.enefile)
            if naver > 0:
                for i in myaver.keys():
                    myaver[i] /= naver
            return myaver

if __name__ == "__main__":
    pass
