#!/usr/bin/env python3

# OpenMM python example script for running Alexandria force fields
# in OpenMM using a user-selected integrator.
# This script implements a modified Buckingham potential with
# Hogervorst combination rules and Gaussian distributed charges
# for the nonbonded interactions.
# A Morse or Cubic potential is used for the bonded interactions.
############################################################
#              PROCEED AT YOUR OWN RISK.                   #
############################################################
# Author: Marie-Madeleine Walz, David van der Spoel Group,
# Department of Cell and Molecular Biology, Uppsala University, Sweden.
# marie-madeleine.walz@icm.uu.se
############################################################

from openmm import *
from openmm.app import *
from simtk.unit import *
from simtk import openmm, unit
import numpy as np
import argparse, copy, inspect, math, sys, shutil
from enum import Enum

# Should correspond to both ACT and OpenMM
ONE_4PI_EPS0 = 138.93545758

# To distinguish
class VdW(Enum):
    LJ8_6  = 1
    LJ12_6 = 2
    LJ14_7 = 3
    WBHAM  = 4
    GBHAM  = 5

# Map strings to VdW entries.
VdWDict = {
    'LJ8_6':  { "func": VdW.LJ8_6, "params": [ "sigma", "epsilon" ],
                "expression": "epsilon*(3*(sigma/r)^8 - 4*(sigma/r)^6)" },
    'LJ12_6': { "func": VdW.LJ12_6, "params": [ "sigma", "epsilon" ],
                "expression": "4*epsilon*((sigma/r)^12 - (sigma/r)^6)" },
    'LJ14_7': { "func": VdW.LJ14_7, "params": [ "sigma", "epsilon", "gamma", "delta" ],
                "expression": ( 'select(epsilon*sigma,( epsilon*( ( (1+ delta)/((r/sigma)+ delta))^7 ) * ( ( (1+ gamma)/(((r/sigma)^7) +gamma )  ) -2       ) ),0)') },
    'WANG_BUCKINGHAM':  { "func": VdW.WBHAM, "params": [ "sigma", "epsilon", "gamma" ],
                "expression": ('select(epsilon*sigma,(((2*epsilon)/(1-(3/(gamma+3)))) * (1.0/(1.0+(r/sigma)^6)) * ((3/(gamma+3))*exp(gamma*(1-(r/sigma)))-1)),0)') },
    'GENERALIZED_BUCKINGHAM':  { "func": VdW.GBHAM, "params": [ "rmin",  "epsilon", "gamma", "delta" ],
                "expression": ('select(epsilon*rmin*gamma,(        epsilon*((delta + 2*gamma + 6)/(2*gamma)) * (1/(1+((r/rmin)^6))) * (  ((6+delta)/(delta + 2*gamma + 6)) * exp(gamma*(1-(r/rmin))) -1 ) - (epsilon/(1+(r/rmin)^delta))           ),0)') }
}

# Make reverse map as well.
dictVdW = {}
for key in VdWDict:
    dictVdW[VdWDict[key]["func"]] = key

class qDist(Enum):
    Point = 1
    Gaussian = 2
    Slater = 3

qdistDict = { 'POINT': qDist.Point, 'GAUSSIAN': qDist.Gaussian, 'SLATER': qDist.Slater }

dictQdist = {}
for key in qdistDict:
    dictQdist[qdistDict[key]] = key

SpecialDict = { "EXPONENTIAL": 0, "DOUBLEEXPONENTIAL": 0 }

nbmethod = {
    'LJPME':          LJPME,
    'PME':            PME,
    'Ewald':          Ewald,
    'CutoffPeriodic': CutoffPeriodic,
    'NoCutoff':       NoCutoff
    }

constrmethod = {
    'AllBonds': AllBonds,
    'HBonds':   HBonds,
    'HAngles':  HAngles,
    'None':     None
    }

def select(x, y, z):
    return y if x else z

def count_atoms(topology, allpart:bool)->int:
    # First count real atoms
    natom = 0
    for res in topology.residues():
        for atom in res.atoms():
            if atom.element or allpart:
                natom += 1
    return natom

def write_sdf(outf, topology, positions, ffcharge, bonds, my_shell, allpart = False):
    # Warning: This code is likely very fragile.
    outf.write("Generated by ACT OpenMM Interface.\n")
    outf.write("  Coordinates and charge information.\n")
    outf.write("WARNING: The content of this file should be carefully checked.\n")

    natom = count_atoms(topology, allpart)
    outf.write("%3d%3d  0  0  0  0  0  0  0  0999 V2000\n" % ( natom, len(bonds) ))
    myunit = unit.angstrom
    charges = []
    count   = 1
    remap   = {}
    for res in topology.residues():
        for atom in res.atoms():
            i = atom.index
            remap[i] = count
            if atom.element or allpart:
                outf.write("%10.4f%10.4f%10.4f" %
                           ( positions[i][0].value_in_unit(myunit),
                             positions[i][1].value_in_unit(myunit),
                             positions[i][2].value_in_unit(myunit) ))
                nnn = 0
                # Funky way to check for formal charge.
                qqq = ffcharge[i]
                if my_shell and i in my_shell:
                    qqq += ffcharge[my_shell[i]]
                # Have to prevent rounding of numbers in the wrong direction
                qqq = int(round(qqq))
                if 0 != qqq:
                    bonded = False
                    for n in bonds:
                        if i == n[0] or i == n[1]:
                            bonded = True
                    if not bonded:
                        charges.append( { "count": count, "q": qqq } )
                        if qqq > 0:
                            nnn = 3
                        else:
                            nnn = 5
                symbol = "VS"
                if atom.element:
                    symbol = atom.element.symbol
                outf.write("%3s%3d%3d  0  0  0  0  0  0  0  0  0  0\n" %
                           ( symbol, 0, nnn ))
                count += 1
    for b in bonds:
        # Assume bond order 1
        order = 1
        outf.write("%3d%3d%3d  0  0  0  0\n" % ( remap[b[0]], remap[b[1]], order ))

    if len(charges) > 0:
        outf.write("M  CHG%3d" % len(charges))
        for q in charges:
            outf.write("%4d%4d" % ( q["count"], q["q"] ))
        outf.write("\n")
    outf.write("M  END\n")
    outf.write("$$$\n")

def write_xyz(outf, topology, positions):
    natom = count_atoms(topology, False)
    outf.write("%5d\n" % natom)
    outf.write("Coordinates\n")
    myunit = unit.angstrom
    for res in topology.residues():
        for atom in res.atoms():
            i = atom.index
            if atom.element:
                outf.write("%5s %15.10f  %15.10f  %15.10f\n" %
                           ( atom.element.symbol,
                             positions[i][0].value_in_unit(myunit),
                             positions[i][1].value_in_unit(myunit),
                             positions[i][2].value_in_unit(myunit) ))

class SimParams:

    def __init__(self, filename:str) -> None:
        self.filename = filename
        self.params   = {}
        with open(filename, 'r') as inFileStream:
            for line in inFileStream:
                line_no_comment = line.split('#')[0]
                try:
                    key, value       = [v.strip() for v in line_no_comment.split('=')]
                    self.params[key] = value
                except:
                    continue

    def setText(self, txt):
        self.txt = txt

    def getFloat(self, key:str, default=0) -> float:
        if key in self.params and len(self.params[key]) > 0:
            try:
                if self.params[key].find("*") > 0:
                    words = self.params[key].split("*")
                elif self.params[key].find("/") > 0:
                    words = self.params[key].split("/")
                else:
                    words = [ self.params[key] ]
                value = float(words[0])
            except ValueError:
                sys.exit("Incorrect float value '%s' for key '%s' in %s" % ( words[0], key, self.filename ))
            return value
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = %g\n" % ( key, self.filename, default ))
            return default

    def getInt(self, key:str, default:int=0) -> int:
        if key in self.params and len(self.params[key]) > 0:
            try:
                words = self.params[key].split("*")
                value = int(words[0])
            except ValueError:
                sys.exit("Incorrect integer value '%s' for key '%s' in %s" % ( words[0], key, self.filename ))
            return value
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = %d\n" % ( key, self.filename, default ))
            return default

    def getStr(self, key:str, default:str="") -> str:
        if key in self.params and len(self.params[key]) > 0:
            return self.params[key]
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = '%s'\n" % ( key, self.filename, default ))
            return default

    def getBool(self, key:str, default:bool=False) -> bool:
        if key in self.params and len(self.params[key]) > 0:
            return self.params[key] in [ "True", "true" ]
        else:
            self.txt.write("Unknown or empty key '%s' in %s, using default value = '%s'\n" % ( key, self.filename, str(default) ))
            return default

class CombinationRules:
    def __init__(self, qdist:str, vdw:str):
        self.qdist = qdist
        self.vdw   = vdw
        self.comb  = {}

        # Use default combination rules of OpenMM if nothing is specified, maybe changed later
        self.add_rule("epsilon", "geometric")
        self.add_rule("sigma", "arithmetic")

    def add_rule(self, param:str, rule:str):
        self.comb[param] = rule

    def rule(self, param:str)->str:
        if not param in self.comb:
            print("WARNING: No such parameter '%s' in combination rules" % param)
            return "Cucumber"
        else:
            return self.comb[param]

    def geometricString(self, vara:str, varb:str)->str:
        return ("sqrt(%s*%s)" % ( vara, varb ))

    def geometric(self, vara:float, varb:float)->float:
        return eval(self.geometricString(str(vara), str(varb)))

    def arithmeticString(self, vara:str, varb:str)->str:
        return ("0.5*(%s+%s)" % ( vara, varb ))

    def arithmetic(self, vara:float, varb:float)->float:
        return eval(self.arithmeticString(str(vara), str(varb)))

    def combTwoString(self, rule:str, vara:str, varb:str)->str:
        myrule = rule.lower()
        if "geometric" == myrule:
            return self.geometricString(vara, varb)
        elif "arithmetic" == myrule:
            return self.arithmeticString(vara, varb)
        elif "yang" == myrule:
            return ("select(%s+%s, (%s*%s)*(%s+%s)/(%s*%s+%s*%s), 0)" % ( vara, varb, vara, varb, vara, varb, vara, vara, varb, varb ))
        elif "waldmansigma" == myrule:
            return ("(0.5*(%s^6 + %s^6))^(1.0/6.0)" % ( vara, varb ))
        elif "volumetric" == myrule:
            return ("(0.5*(%s^3 + %s^3))^(1.0/3.0)" % ( vara, varb ))
        elif "inversesquare" == myrule:
            return ("sqrt(2/(%s^(-2) + %s^(-2)))" % (vara, varb) )
        elif "qisigma" == myrule:
            return ("select(%s+%s,(%s^3+%s^3)/(%s^2+%s^2),0)" % ( vara, varb, vara, varb, vara, varb ))
        elif "halgrenepsilon" == myrule:
            return ("select(%s^2+%s^2,(4*%s*%s/(sqrt(%s)+sqrt(%s))^2),0)" % ( vara, varb, vara, varb, vara, varb ))
        elif "hogervorstepsilon" == myrule:
            return ("select(%s+%s,((2.0 * %s * %s)/( %s + %s )),0)" %  ( vara, varb, vara, varb, vara, varb ))
        else:
            sys.exit("Unknown combination rule '%s'" % rule)

    def combTwoFloats(self, param:str, vara:float, varb:float)->float:
        myrule = self.comb[param].lower()
        try:
            mystring = self.combTwoString(myrule, vara, varb).replace("^", "**").replace("sqrt", "math.sqrt")
            return eval(mystring)
        except Exception as e:
            if (vara + varb) == 0 and myrule in ["qisigma", "halgrenepsilon", "hogervorstepsilon", "yang"]:
                return 0
            else:
                raise e

    def combFloats(self, allParam:dict)->list:
        mydict = {}
        for param in self.comb.keys():
            hve = "hogervorstepsilon"
            hvs = "hogervorstsigma"
            wme = "waldmanepsilon"
            mng = "masongamma"
            epsilon1 = allParam["epsilon"][0]
            epsilon2 = allParam["epsilon"][1]
            if "sigma" in allParam:
                sigma1 = allParam["sigma"][0]
                sigma2 = allParam["sigma"][1]
            elif "rmin" in allParam:
                rmin1 = allParam["rmin"][0]
                rmin2 = allParam["rmin"][1]
            if "gamma" in allParam:
                gamma1 = allParam["gamma"][0]
                gamma2 = allParam["gamma"][1]
            if hvs == self.comb[param].lower():
                e12 = self.combineTwoFloat(hve, epsilon1, epsilon2)
                if VdWDict[self.vdw]["func"] == VdW.WBHAM and param == "sigma":
                    mydict["sigma"]  = math.sqrt(((epsilon1*gamma1*sigma1**6)/(gamma1-6)) * ((epsilon2*gamma2*sigma2**6)/(gamma2-6)))*((gamma1+gamma2)/2-6)/(e12*(gamma1+gamma2)/2)**(1.0/6.0)
                elif VdWDict[self.vdw]["func"] == VdW.GBHAM and param == "rmin":
                    mydict["rmin"]   = math.sqrt(((epsilon1*gamma1*rmin1**6)/(gamma1-6)) * ((epsilon2*gamma2*rmin2**6)/(gamma2-6)))*((gamma1+gamma2)/2-6)/(e12*(gamma1+gamma2)/2)**(1.0/6.0)
                else:
                    sys.exit("Combination rule %s not supported for param %s and VdW function %s" % ( hvs, param, self.vdw ))
            elif wme == self.comb[param].lower():
                if "epsilon" == param:
                    if "sigma" in allParam:
                        denominator = (sigma1**6)+(sigma2**6)
                    elif "rmin" in allParam:
                        denominator = (rmin1**6)+(rmin2**6)
                    else:
                        sys.exit("Combination rule %s requires either sigma or rmin to calculate %s" % ( wme, param ))
                    # check for division by zero
                    if denominator != 0:
                        mydict["epsilon"] = math.sqrt(epsilon1*epsilon2)*(2*(rmin1**3)*(rmin2**3))/(denominator)
                    else:
                        mydict["epsilon"] = 0
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( wme, param ))
            elif mng == self.comb[param].lower():
                if "gamma" == param:
                    sigmaIJ = math.sqrt(allParam["sigma"][0]*allParam["sigma"][1])
                    mydict["gamma"] = sigmaIJ*(0.5*(allParam["gamma"][0]/allParam["sigma"][0]+allParam["gamma"][1]/allParam["sigma"][1]))
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( mng, param ))
            else:
                mydict[param] = self.combTwoFloats(param, allParam[param][0], allParam[param][1])
        return mydict

    def combStrings(self)->dict:
        mydict  = {}
        sigma   = "sigma"
        epsilon = "epsilon"
        hvs     = "hogervorstsigma"
        wme     = "waldmanepsilon"
        mng     = "masongamma"
        geom    = "geometric"
        for param in self.comb.keys():
            if hvs == self.comb[param].lower():
                e12 = self.combTwoString("hogervorstepsilon", "epsilon1", "epsilon2")
                if VdWDict[self.vdw]["func"] == VdW.WBHAM and param == sigma:
                    mydict[sigma]  = ("(((sqrt(((epsilon1*gamma1*(sigma1^6))/(gamma1-6)) * ((epsilon2*gamma2*(sigma2^6))/(gamma2-6)))*((gamma1+gamma2)/2-6))/(%s*(gamma1+gamma2)/2))^(1.0/6.0))" % e12)
                elif VdWDict[self.vdw]["func"] == VdW.GBHAM and param == 'rmin':
                    mydict["rmin"] = ("(((sqrt(((epsilon1*gamma1*rmin1^6)/(gamma1-6)) * ((epsilon2*gamma2*rmin2^6)/(gamma2-6)))*((gamma1+gamma2)/2-6))/(%s*(gamma1+gamma2)/2))^(1.0/6.0))" % e12)
                else:
                    sys.exit("Combination rule %s not supported for param %s and VdW function %s" % ( hvs, param, self.vdw ))
            elif wme == self.comb[param].lower():
                if epsilon == param:
                    if "rmin" in self.comb.keys():
                        mydict[epsilon] = ("select(rmin1+rmin2, sqrt(epsilon1*epsilon2)*(2*(rmin1^3)*(rmin2^3))/((rmin1^6)+(rmin2^6)), 0)")
                    elif sigma in self.comb.keys():
                        mydict[epsilon] = ("select(sigma1+sigma2, sqrt(epsilon1*epsilon2)*(2*(sigma1^3)*(sigma2^3))/((sigma1^6)+(sigma2^6)), 0)")
                    else:
                        sys.exit("Combination rule %s requires either sigma or rmin to calculate %s" % ( wme, param ))
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( wme, param ))
            elif mng == self.comb[param].lower():
                if "gamma" == param:
                    sigmaIJ = self.combTwoString(geom, "sigma1", "sigma2")
                    mydict["gamma"] = ("select(sigma1*sigma2,%s*(0.5*(gamma1/sigma1+gamma2/sigma2)),0)" % sigmaIJ)
                else:
                    sys.exit("Combination rule %s not supported for param %s" % ( mng, param ))
            else:
                mydict[param] = self.combTwoString(self.comb[param], param+"1", param+"2")
        return mydict

    def gaussianString(self)->str:
        if qdistDict[self.qdist] == qDist.Gaussian:
            return "select(zeta1*zeta2, erf((zeta1*zeta2*r)/sqrt((zeta1^2)+(zeta2^2))), select(zeta1+zeta2, select(zeta1, erf(zeta1*r), erf(zeta2*r)), 1))"
        elif qdistDict[self.qdist] == qDist.Point:
            return "1"
        else:
            sys.exit("No support for charge distribution type %s" % self.qdist)

class ActForce:
    def __init__(self, fcname:str, fgnumber:int):
        self.fcname = fcname
        self.fgnumber = fgnumber

class ActOpenMMSim:
    def __init__(self, pdbfile: str,         datfile: str,                  actfile: str=None,
                       xmlfile: str=None,    enefile: str='energy.csv',     txtfile: str='output.txt',
                       chkfile: str=None,    pdbtraj: str='trajectory.pdb', xtctraj: str='trajectory.xtc',
                       emonomer: float=None, debug:   bool=False,           verbose: bool=False):
        self.chkfile     = chkfile
        self.enefile     = enefile
        self.txtfile     = txtfile
        self.xtctraj     = xtctraj
        self.pdbtraj     = pdbtraj
        self.emonomer    = emonomer
        self.nexcl       = None
        self.txt         = None
        self.debug       = debug
        if self.debug:
            self.verbose = True
        else:
            self.verbose = verbose
        # Check whether .pdb file is valid
        if not os.path.exists(pdbfile):
            sys.exit("Error: pdb file %s does not exist" % pdbfile)
        else:
            self.pdbfile = pdbfile
        # Check whether .dat file is valid
        if not os.path.exists(datfile):
            sys.exit("Error: parameter file %s does not exist" % datfile)
        else:
            self.datfile = datfile
        # ACT force field gets precedence over .xml
        if actfile != None: # only met when ACT is provided
            if not os.path.exists(actfile):
                sys.exit("Error: ACT force field file %s does not exist" % actfile)
            else:
                self.actfile = actfile
                self.xmlfile = None    # to prevent assignment of .xml if ACT exists
        elif xmlfile != None: # only met when .xml is provided and ACT
            if not os.path.exists(xmlfile):
                sys.exit("Error: OpenMM force field file %s does not exist" % xmlfile)
            else:
                self.actfile = actfile # is None
                self.xmlfile = xmlfile
        else:
            sys.exit("Please pass an ACT (actfile) or OpenMM force field file (xmlfile) using the optional arguments")
        self.pdb         = PDBFile(self.pdbfile)
        self.sim_params  = SimParams(self.datfile)
        # Open log file and pass it on.
        self.txt = open(self.txtfile, "w")
        self.sim_params.setText(self.txt)
        # Default is 12-6 + Point charges, may be updated later.
        self.qdist = dictQdist[qDist.Point]
        self.vdw   = dictVdW[VdW.LJ12_6]
        self.comb  = CombinationRules(self.qdist, self.vdw)
        # Check which code path to choose
        self.useOpenMMForce = False
        if self.sim_params.getBool("useOpenMMForce", False):
            if (qdistDict[self.qdist] == qDist.Point and VdWDict[self.vdw]["func"] == VdW.LJ12_6 and
                self.comb.rule("epsilon").lower() == "geometric" and
                self.comb.rule("sigma").lower() == "arithmetic"):
                self.useOpenMMForce = True
            else:
                sys.exit("OpenMMForce routines are supported only with 'LJ12_6' (%s), 'Point' charges (%s) and 'geometric' combination rule for epsilon (%s) and 'arithmetic' for sigma (%s)" % ( self.vdw, self.qdist, self.comb.rule("epsilon").lower(), self.comb.rule("sigma").lower() ))
        self.force_group = None
        self.txt_header()
        self.gen_ff()

    def __del__(self):
        if self.verbose:
            if None != self.txt:
                print("Please check output in %s" % self.txtfile )
                self.txt.close()
            print("Energies are in %s" % self.enefile )
            if None != self.xtctraj:
                print("XTC trajectory is in %s" % self.xtctraj )
            if None != self.pdbtraj:
                print("PDB trajectory in %s" % self.pdbtraj )

    def txt_header(self):
        self.txt.write("Starting OpenMM calculation using the ActOpenMMSim interface.\n")
        self.txt.write("input pdbfile:         %s\n" % self.pdbfile)
        self.txt.write("simulation parameters: %s\n" % self.datfile)
        if self.useOpenMMForce:
            self.txt.write("Will use native OpenMM force routines.\n")
        self.txt.flush()

    def gen_ff(self):
        if None != self.xmlfile:
            self.forcefield  = ForceField(self.xmlfile)
            self.txt.write("force field            %s\n" % self.xmlfile)
        elif None != self.actfile:
            # Run alexandria gentop, but first check whether we have alexandria
            if None == shutil.which("alexandria"):
                sys.exit("You provided and ACT force field file, but the alexandria program is not in your PATH")
            self.xmloutfile = "act.xml"
            if os.path.exists(self.xmloutfile):
                if self.verbose:
                    self.txt.write("Removing existing OpenMM force field file %s\n" % self.xmloutfile)
                os.unlink(self.xmloutfile)
            mycmd = ("alexandria gentop -ff %s -f %s -openmm %s" % ( self.actfile,
                                                                     self.pdbfile,
                                                                     self.xmloutfile ))
            os.system(mycmd)
            if not os.path.exists(self.xmloutfile):
                sys.exit("Failed running '%s'" % mycmd)
            self.txt.write("Succesfully generated an OpenMM force field file %s from ACT force field %s\n" % (self.xmloutfile, self.actfile))
            self.forcefield = ForceField(self.xmloutfile)
        self.polarizable = any(isinstance(generator, openmm.app.forcefield.DrudeGenerator) for generator in self.forcefield.getGenerators())
        self.txt.write("polarizable:           %s\n" % self.polarizable)

    def xmlOutFile(self):
        return self.xmloutfile

    def init_force_groups(self)->int:
        self.force_group = {}
        self.fgnumber    = {}
        # First, copy existing force groups, but with only one force per group
        max_fg = -1
        self.count_forces("Init force group 1")
        for force in self.system.getForces():
            fcname   = force.getName()
            fgnumber = force.getForceGroup()
            # Find largest group while we are at it
            max_fg   = max(max_fg, fgnumber)
            if not fgnumber in self.force_group:
                self.force_group[fgnumber] = fcname
                self.fgnumber[fcname]      = fgnumber
        # Now give remaining forces new force group numbers
        self.count_forces("Init force group 2")
        for force in self.system.getForces():
            fcname   = force.getName()
            if not fcname in self.fgnumber:
                max_fg += 1
                force.setForceGroup(max_fg)
                self.force_group[max_fg] = fcname
                self.fgnumber[fcname]    = max_fg
        self.count_forces("Init force group 3")
        if self.verbose:
            for force in self.system.getForces():
                self.txt.write("System: %s group %d\n" % ( force.getName(), force.getForceGroup()))
            for group in self.force_group:
                self.txt.write("Self: %s group %d\n" % ( self.force_group[group], group ))
        return len(self.force_group.keys())

    def add_force_group(self, force, newfg:bool):
        if None == self.force_group:
            new_fgnumber = self.init_force_groups()
        else:
            last_group = -1
            for nf in self.fgnumber.keys():
                last_group = max(self.fgnumber[nf], last_group)
            new_fgnumber = last_group
        fcname   = force.getName()
        fgnumber = force.getForceGroup()
        if force == self.nonbondedforce and self.nonbondedMethod != NoCutoff:
            # Remove direct space nonbondeds and add them to the local book-keeping
            if force.getIncludeDirectSpace():
                directname = fcname + ' (direct space)'
                self.force_group[fgnumber] = directname
                self.fgnumber[directname]  = fgnumber
                force.setName(directname)
                self.txt.write("Added force group %d %s\n" % ( fgnumber, force.getName()))
            # Now for the PME part
            ### three body dispersion has no reciprocal space
            if fcname != "CustomManyParticleForce":
                new_fgnumber += 1
                recipname = fcname + ' (reciprocal space)'
                self.force_group[new_fgnumber] = recipname
                self.fgnumber[recipname]       = new_fgnumber
                force.setReciprocalSpaceForceGroup(new_fgnumber)
                self.txt.write("Added force group %d %s\n" % ( new_fgnumber, recipname))
        elif newfg:
            new_fgnumber += 1
            self.force_group[new_fgnumber] = fcname
            self.fgnumber[fcname]          = new_fgnumber
            force.setForceGroup(new_fgnumber)
            self.txt.write("Added force group %d %s\n" % ( new_fgnumber, force.getName()))
        else:
            if fgnumber in self.force_group:
                # Update the name just in case
                self.force_group[fgnumber] = fcname


    def del_force(self, force, nonbond:bool=False):
        if None == force:
            return
        fcname   = force.getName()
        fgnumber = force.getForceGroup()
        if self.verbose:
            self.txt.write('Will try to delete force %s group %d\n' % (fcname, fgnumber))
        if not nonbond:
            # Find the index belonging to the force to be deleted
            # rather than using the force group number.
            iforce = -1
            index  = 0
            for force in self.system.getForces():
                if force.getName() == fcname:
                    iforce = index
                    break
                index += 1
            if -1 != iforce:
                self.system.removeForce(iforce)
                if fcname in self.fgnumber:
                    del self.fgnumber[fcname]
                if fgnumber in self.force_group:
                    del self.force_group[fgnumber]
        self.count_forces("Deleted force group %d %s" % ( fgnumber, fcname))
        return

    def count_forces(self, label:str):
        if self.verbose:
            self.txt.write("%s: there are %d forces\n"  % (label, len(self.system.getForces())))
        if self.debug:
            for force in self.system.getForces():
                num = 0
                for interaction in ['Particle', 'Bond', 'Angle', 'Torsion']: # more could be added if necessary
                    get_num = getattr(force, f'getNum{interaction}s', None)
                    if get_num:
                        num = get_num()
                self.txt.write("DBG: fcname %s fgnumber %d N = %d\n" % ( force.getName(), force.getForceGroup(), num))

    def nmol(self)->int:
        return self.topology.getNumResidues()

    def temperature(self)->float:
        return self.temperature_c

    def set_monomer_energy(self, emonomer:float):
        self.emonomer = emonomer

    def set_params(self):
        # SET SIMULATION PARAMETERS
        ################################################
        self.dt                 = self.sim_params.getFloat('dt')
        self.equilibrationSteps = self.sim_params.getInt('equilibrationSteps')
        self.minimizationSteps  = self.sim_params.getInt('minimizationSteps', 1000)
        self.steps              = self.sim_params.getInt('steps')
        self.nonbondedMethod           = nbmethod[self.sim_params.getStr('nonbondedMethod')]
        self.nonbondedCutoff           = self.sim_params.getFloat('nonbondedCutoff')
        self.col_freq                  = self.sim_params.getFloat('collisionFrequency', 0.1)
        self.maxDrudeDist              = self.sim_params.getFloat('maxDrudeDistance', 0.02)
        self.useAndersenThermostat     = self.sim_params.getBool('useAndersenThermostat')
        self.temperature_c             = self.sim_params.getFloat('temperature_c')
        self.useMonteCarloBarostat     = self.sim_params.getBool('useMonteCarloBarostat')
        self.useMonteCarloAnisotropicBarostat = self.sim_params.getBool('useMonteCarloAnisotropicBarostat')
        if self.useMonteCarloAnisotropicBarostat:
            self.scaleX             = self.sim_params.getBool('scaleX')
            self.scaleY             = self.sim_params.getBool('scaleY')
            self.scaleZ             = self.sim_params.getBool('scaleZ')
            self.pressX             = self.sim_params.getFloat('pressX')
            self.pressY             = self.sim_params.getFloat('pressY')
            self.pressZ             = self.sim_params.getFloat('pressZ')
            self.pressvec           = [self.pressX,self.pressY,self.pressZ]
        self.constraints            = constrmethod[self.sim_params.getStr('constraints', 'None')]
        self.rigidWater             = self.sim_params.getBool('rigidWater')
        self.constraintTolerance    = self.sim_params.getFloat('constraintTolerance')

    def start_output(self):
        # Do not initialize energy file, unless necessary
        save = self.sim_params.getInt('saveEnergy')
        self.dataReporter = None
        if save > 0 and self.steps >= save:
            self.txt.write(f"Simulation data will be stored in CSV every {save} steps in {self.enefile}.\n")
            self.dataReporter = StateDataReporter(self.enefile, save,
                                                  totalSteps      = self.steps,
                                                  step            = self.sim_params.getBool('outStep'),
                                                  time            = self.sim_params.getBool('outTime'),
                                                  speed           = self.sim_params.getBool('outSpeed', False),
                                                  progress        = self.sim_params.getBool('outProgress', False),
                                                  potentialEnergy = self.sim_params.getBool('outPotentialEnergy'),
                                                  kineticEnergy   = self.sim_params.getBool('outKineticEnergy'),
                                                  temperature     = self.sim_params.getBool('outTemperature'),
                                                  volume          = self.sim_params.getBool('outVolume', False),
                                                  density         = self.sim_params.getBool('outDensity'),
                                                  separator       = self.sim_params.getStr('outSeparator'))
        else:
            self.txt.write("Simulation data will not be stored in CSV (save set to 0 or exceeding number of steps).\n")
            self.enefile = None

        # Do not initialize PDB file, unless necessary
        save = self.sim_params.getInt('savePdb')
        self.pdbReporter = None
        if save > 0 and self.steps >= save:
            self.txt.write(f"Coordinates will be stored in PDB every {save} steps in {self.pdbtraj}.\n")
            self.pdbReporter = PDBReporter(self.pdbtraj, save)
        else:
            self.txt.write(f"Coordinates will not be stored in PDB (save set to 0 or exceeding number of steps).\n")
            self.pdbtraj = None

        # Do not initialize XTC file, unless necessary
        save = self.sim_params.getInt('saveXtc')
        self.xtcReporter = None
        if save > 0 and self.steps >= save:
            self.txt.write(f"Coordinates will be stored in XTC every {save} steps in {self.xtctraj}.\n")
            self.xtcReporter = XTCReporter(self.xtctraj, save)
        else:
            self.txt.write(f"Coordinates will not be stored in XTC (save set to 0 or exceeding number of steps).\n")
            self.xtctraj = None

        # Do not initialize CHK file, unless necessary
        save = self.sim_params.getInt('saveChk')
        self.chkReporter = None
        if save > 0 and self.steps >= save:
            if self.chkfile is not None:
                self.txt.write(f"Checkpoints will be stored in CHK every {save} steps in {self.chkfile}.\n")
                self.chkReporter = CheckpointReporter(self.chkfile, save)
            else:
                self.txt.write("Checkpoints will not be stored in CHK (no file provided).\n")
                #self.chkfile = None # <- already None
        else:
            self.txt.write("Checkpoints will not be stored in CHK (save set to 0 or exceeding number of steps).\n")
            self.chkfile = None

    def get_parameter_indices(self):
        # read parameter order from OpenMM XML file
        self.parameter_indices = {}
        for force in self.system.getForces():
            fname = force.getName()
            for interaction in ['Particle', 'Bond', 'Angle', 'Torsion']: # more could be added if necessary
                get_param_name = getattr(force, f'getPer{interaction}ParameterName', None)
                get_num_params = getattr(force, f'getNumPer{interaction}Parameters', None)
                if get_param_name and get_num_params:
                    self.parameter_indices[fname] = {get_param_name(index): index for index in range(get_num_params())}
                elif hasattr(force, f'set{interaction}Parameters'):
                    param_names = [p.name for p in inspect.signature(getattr(force, f'set{interaction}Parameters')).parameters.values() if p.name != 'index']
                    self.parameter_indices[fname] = {pname: p for p, pname in enumerate(param_names)}
            if fname in self.parameter_indices and self.verbose:
                self.txt.write("parameter_indices[%s] = %s\n" % ( fname, str(self.parameter_indices[fname])))

    def make_system(self):
        # TOPOLOGY
        ################################################
        topology  = self.pdb.topology
        positions = self.pdb.positions
        self.modeller  = Modeller(topology, positions)
        self.modeller.addExtraParticles(self.forcefield)
        self.topology  = self.modeller.topology
        self.positions = self.modeller.positions
        if self.verbose:
            self.txt.write("There are %d particles.\n" % len(self.positions))
        myDrudeMass    = self.sim_params.getFloat('drudeMass', 0.1)
        # Document where this constant comes from
        self.EwaldErrorTolerance = self.sim_params.getFloat('ewaldErrorTolerance', 1e-4)
        self.alphaPME = math.sqrt(-math.log(self.EwaldErrorTolerance*2))/self.nonbondedCutoff
        rmcom           = True
        if self.nonbondedMethod == NoCutoff:
            rmcom = False
        if self.verbose:
            self.txt.write("Using flexible water (if present).\n")
        if self.polarizable:
            self.system = self.forcefield.createSystem(self.topology,
                                                       nonbondedMethod=self.nonbondedMethod,
                                                       nonbondedCutoff=self.nonbondedCutoff,
                                                       removeCMMotion=rmcom,
                                                       ewaldErrorTolerance=self.EwaldErrorTolerance,
                                                       constraints=self.constraints,
                                                       rigidWater=self.rigidWater,
                                                       drudeMass=myDrudeMass*unit.amu)
            if self.verbose:
                self.txt.write("The force field is polarizable and the drude mass is %g.\nMake sure it is consistent with your force field file.\n" % myDrudeMass)
        else:
            self.system = self.forcefield.createSystem(self.topology,
                                                       nonbondedMethod=self.nonbondedMethod,
                                                       nonbondedCutoff=self.nonbondedCutoff,
                                                       removeCMMotion=rmcom,
                                                       ewaldErrorTolerance=self.EwaldErrorTolerance,
                                                       constraints=self.constraints,
                                                       rigidWater=self.rigidWater)
            if self.verbose:
                self.txt.write("The force field is NOT polarizable.\n")
        self.count_forces("Initial")

    def find_shells_cores(self, drudeforce):
        self.cores = []
        self.shells = []
        self.core_shell = []
        self.my_core  = {}
        self.my_shell = {}
        for index in range(drudeforce.getNumParticles()):
            [particle, particle1, _, _, _, _, _, _, _] = drudeforce.getParticleParameters(index)
            self.shells.append(particle) # particle  = shell
            self.cores.append(particle1) # particle1 = core
            self.my_core[particle] = particle1
            self.my_shell[particle1] = particle
            self.core_shell.append((particle,particle1))
        if self.debug:
            # Checking correct atom/shell pairing
            self.txt.write(f"cores      {self.cores}\n")
            self.txt.write(f"shells     {self.shells}\n")
            self.txt.write(f"core_shell {self.core_shell}\n")
            self.txt.write("########################\n")

    # CODE FOR ALEXANDRIA NONBONDED FORCES
    ################################################
    def add_customnb(self, force):
        potname = None
        isVdw   = False
        for i in range(force.getNumGlobalParameters()):
            param = force.getGlobalParameterName(i)
            value = force.getGlobalParameterDefaultValue(i)
            # Analyze the parameter
            if param.startswith("pot-"):
                correct = True
                if param[4:] in VdWDict:
                    potname = param[4:]
                    force.setName(param[4:])
                    self.vdw = potname
                    isVdw    = True
                    self.comb.vdw = self.vdw
                elif param[4:].startswith("COULOMB_"):
                    qqname = param[12:]
                    if qqname in qdistDict:
                        self.qdist = qqname
                        self.comb.qdist = qqname
                    else:
                        correct = False
                elif param[4:] in SpecialDict:
                    # TODO think of what to do here
                    # correct = False
                    force.setName(param[4:])
                    potname = param[4:]
                if not correct:
                    sys.exit("Invalid potential name '%s'" % potname)
            elif param.startswith("cr-"):
                try:
                    cparm, crule = param[3:].split("_")
                    self.comb.add_rule(cparm, crule)
                except:
                    sys.exit("Invalid combination rule '%s'" % ( param[3:] ) )
            elif param.startswith("nexcl"):
                if not self.nexcl:
                    self.nexcl = value
                elif self.nexcl != value:
                    sys.exit("Different exclusions provided for different forces, this is not supported")
            else:
                sys.exit("Unknown global parameter '%s'" % param)

        if potname:
            force.setName(potname)
            self.customnbs.append( { "pot": potname, "force": force, "vdw": isVdw } )

    def init_forces(self):
        """
        TODO: Update comment
        Create a CustomNonbondedForce to calculate the direct-space forces of the Alexandria
        Van der Waals potential as well (Gaussian distributed charge) Coulomb,
        placing it in specified force groups.
        The LJ and point charge is used for both the dispersion correction and for LJPME and PME
        and a correction is needed for the exclusioms.
        """

        # There always is a regular NonbondedForce
        self.nonbondedforce = None
        for force in self.system.getForces():
            if force.getName().startswith('NonbondedForce'):
                self.nonbondedforce = force
        if not self.nonbondedforce:
            sys.exit("No nonbonded force found")

        # Now for the other forces
        cnbname        = "CustomNonbondedForce"
        dforce         = "DrudeForce"
        DDDforce       = "CustomManyParticleForce"
        self.customnbs = []
        self.my_shell = None
        # Loop over all forces
        for force in self.system.getForces():
            fname = force.getName()
            if self.debug:
                self.txt.write("Found force %s\n" % fname)
            if fname == cnbname:
                # CustomNonbond
                self.add_customnb(force)
                self.add_force_group(force, True)
            elif fname == DDDforce:
                # Three body dispersion
                self.add_customnb(force)
                self.add_force_group(force, False)
            elif dforce == fname:
                self.add_force_group(force, False)
                self.find_shells_cores(force)
        if len(self.customnbs) == 0:
            self.useOpenMMForce = True
        # Check whether the user wants us to use OpenMM forces or ACT forces
        # If we should use OpenMMForce routines
        if not self.useOpenMMForce:
            self.nonbondedforce.setIncludeDirectSpace(False)
        self.add_force_group(self.nonbondedforce, False)

        if self.verbose:
            self.txt.write("***************************\n")
            self.txt.write(f"Number of particles (incl. vsites and drudes):  {self.system.getNumParticles()}\n")
        self.count_forces("Direct space 3")

    def makeVdWFunc(self):
        vdwParamNames       = VdWDict[self.vdw]["params"]
        self.vdw_expression = ( "%s" % VdWDict[self.vdw]["expression"] )
        # Not a whole lot of documentation around, but this seems OK.
        # Have to verify that it is the same in OpenMM though.
        # https://manual.gromacs.org/documentation/2019/reference-manual/functions/long-range-vdw.html
        self.vdw_pme_excl_corr_expression = None
        if self.nonbondedMethod == LJPME:
            # NB! the minus sign
            # TODO: IS THIS CORRECT? SHOULD THE SIGN BE REVERSED IN THE NORMAL VDW?
            self.vdw_pme_excl_corr_expression = ( "-((1-exp(-(%s*r)^2)*(1+(%s*r)^2+0.5*(%s*r)^4))*c6/r^6)" %
                                                 ( self.alphaPME, self.alphaPME, self.alphaPME) )
            if self.debug:
                self.txt.write("DBG: vdw_pme_excl_corr_expression '%s'\n" % self.vdw_pme_excl_corr_expression)
            self.vdw_expression += self.vdw_pme_excl_corr_expression
            self.vdw_pme_excl_corr_expression += ";"
        if self.useOpenMMForce:
            return

        # close energy expressions
        self.vdw_expression           += ";"

        # The statements have to be in this order! They are evaluated in the reverse order apparently.
        combdict = self.comb.combStrings()
        for pp in vdwParamNames:
            self.vdw_expression += ('%s = %s;' % ( pp, combdict[pp] ))
        if self.nonbondedMethod == LJPME:
            self.vdw_expression += ('c6 = sqrt(c61*c62);')

        # custom van der Waals
        self.custom_vdw = openmm.CustomNonbondedForce(self.vdw_expression)
        self.custom_vdw.setName("VanderWaals"+ self.vdw)
        for pp in vdwParamNames:
            self.custom_vdw.addPerParticleParameter(pp)
        if self.nonbondedMethod == LJPME:
            self.custom_vdw.addPerParticleParameter("c6")

        if self.debug:
            for i in range(self.custom_vdw.getNumPerParticleParameters()):
                self.txt.write("self.custom_vdw parameter %d %s\n" % ( i, self.custom_vdw.getPerParticleParameterName(i)))
        for index in range(self.nonbondedforce.getNumParticles()):
            [ charge, sigma, epsilon ] = self.nonbondedforce.getParticleParameters(index)
            ppp = None
            if self.useOpenMMForce or len(self.customnbs) == 0:
                ppp = [ sigma._value, epsilon._value ]
            else:
                for cnb in self.customnbs:
                    if cnb["vdw"]:
                        ppp = list(cnb["force"].getParticleParameters(index))
            if not ppp:
                sys.exit("No vanderwaals function")
            ppp = ppp[:len(vdwParamNames)]
            # Compute the c6 for LJPME correction
            if self.nonbondedMethod == LJPME:
                ppp.append(4*epsilon._value*sigma._value**6)

            self.custom_vdw.addParticle(ppp)
            if self.debug:
                self.txt.write("index %d" % index)
                myparm = self.custom_vdw.getParticleParameters(index)
                for mypp in range(self.custom_vdw.getNumPerParticleParameters()):
                    self.txt.write(" %s %g" % ( self.custom_vdw.getPerParticleParameterName(mypp),
                                                myparm[mypp] ) )
                self.txt.write("\n")

    def do_force_settings(self, force):
        if self.nonbondedMethod == NoCutoff:
            force.setNonbondedMethod(openmm.CustomNonbondedForce.NoCutoff)
        elif not self.useOpenMMForce:
            force.setNonbondedMethod(openmm.CustomNonbondedForce.CutoffPeriodic)
        if self.nonbondedforce != force:
            for index in range(self.nonbondedforce.getNumExceptions()):
                # If we use a CustomNonbondedForce rather than the native one we need
                # to copy the exclusions, however the 1-4 interactions may be problematic.
                # Maybe move this to the special exclusion routines?
                [iatom, jatom, qprod, sigma, epsilon] = self.nonbondedforce.getExceptionParameters(index)
                #force.addExclusion(iatom, jatom)
                #if self.debug:
                #    self.txt.write("%s excl iatom %d jatom %d\n" %
                #                   ( force.getName(), iatom, jatom ))
        force.setCutoffDistance(self.nonbondedforce.getCutoffDistance())
        if self.sim_params.getBool('useSwitchingFunction', False):
            force.setUseSwitchingFunction(True)
            force.setSwitchingDistance(self.sim_params.getFloat('SwitchDistance', 0))
        useDispCorr = self.sim_params.getBool('useDispersionCorrection', False)
        if hasattr(force, 'setUseDispersionCorrection'):
            force.setUseDispersionCorrection(useDispCorr)
        elif hasattr(force, 'setLongRangeCorrection'):
            force.setUseLongRangeCorrection(useDispCorr)
        if hasattr(force, 'setReactionFieldDielectric'):
            if 'dielectricConstant' in self.sim_params.params:
                force.setReactionFieldDielectric(self.sim_params.getFloat('dielectricConstant'))
        if self.verbose:
            if hasattr(force, "getNumExclusions"):
                mynexcl = force.getNumExclusions()
            else:
                mynexcl = force.getNumExceptions()
            self.txt.write("There are %d particles in %s and %d exclusions\n" %
                           ( force.getNumParticles(), force.getName(), mynexcl ))

    def add_custom_forces(self):
        if self.useOpenMMForce:
            self.do_force_settings(self.nonbondedforce)

        else:
            expression = None
            # OpenMM uses Reaction Field if a Cutoff is specified. Even with
            # a dielectric constant of 1, there is a constant off-set in the
            # energy we have to take into account. If the dielectric constant
            # is NOT 1, this will not work.
            # http://docs.openmm.org/7.1.0/userguide/theory.html#coulomb-interaction-with-cutoff
            if ('dielectricConstant' in self.sim_params.params and
                1 != self.sim_params.getFloat('dielectricConstant')):
                sys.exit("No support for dielectric constant other than 1.0 with custom forces")
                
            elec_string  = ""
            if self.nonbondedMethod in [ PME, LJPME ]:
                elec_string = ("((1-erf(%s*r))/r)" % self.alphaPME)
            elif self.nonbondedMethod in [ CutoffNonPeriodic, CutoffPeriodic ]:
                elec_string = ("(1/r-%g)" % ( 1.0/self.nonbondedCutoff ))
            else:
                elec_string = ("(1/r)")
            if qdistDict[self.qdist] == qDist.Gaussian:
                # Electrostatics is our screened Coulomb minus the point charge based potential
                self.qq_expression  = ( "(%s*charge1*charge2*Gaussian*%s);" %
                                        ( ONE_4PI_EPS0, elec_string ) )
                self.qq_expression += ( "Gaussian = %s;" % self.comb.gaussianString())
            elif qdistDict[self.qdist] == qDist.Point:
                # Or a simple point charge
                self.qq_expression = ( '(%s*charge1*charge2*%s);' % ( ONE_4PI_EPS0, elec_string  ) )

            self.custom_coulomb = openmm.CustomNonbondedForce(self.qq_expression)
            self.custom_coulomb.setName("Coulomb"+self.qdist)
            if self.verbose:
                self.txt.write("Created electrostatics function %s '%s'\n" % ( self.custom_coulomb.getName(), self.qq_expression))
            self.custom_coulomb.addPerParticleParameter("charge")
            if qdistDict[self.qdist] != qDist.Point:
                self.custom_coulomb.addPerParticleParameter("zeta")

        self.charges = []
        for index in range(self.nonbondedforce.getNumParticles()):
            if self.useOpenMMForce or qdistDict[self.qdist] == qDist.Point or len(self.customnbs) == 0:
                *myparams, = self.nonbondedforce.getParticleParameters(index)
                allParam   = {parameter: myparams[idx] for parameter, idx in self.parameter_indices[self.nonbondedforce.getName()].items()}
                if hasattr(allParam["charge"], "_value"):
                    charge     = allParam["charge"]._value
                else:
                    charge     = allParam["charge"]
                if hasattr(self, "custom_coulomb"):
                    self.custom_coulomb.addParticle([charge])
                    if self.debug:
                        self.txt.write(f"Adding {self.qdist} charge {charge} to particle {index}\n")
            else:
                for cnb in self.customnbs:
                    if cnb["vdw"]:
                        *myparams, = cnb["force"].getParticleParameters(index)
                        allParam   = {parameter: myparams[idx] for parameter, idx in self.parameter_indices[cnb["force"].getName()].items()}
                        if not "charge" in allParam:
                            sys.exit("No charge in %s" % str(allParam))
                        charge     = allParam["charge"]
                        zeta       = allParam["zeta"]
                        if hasattr(self, "custom_coulomb"):
                            self.custom_coulomb.addParticle([charge, zeta]) # should these be turned into quantities as well?
                            self.txt.write(f"Adding {self.qdist} charge {charge} and zeta {zeta} to particle {index}\n")
            self.charges.append(charge)

        # Van der Waals, is our custom potential
        self.makeVdWFunc()

        # General settings for custom non-bonded potentials, if they are present!
        for forcenm in [ "custom_vdw", "custom_coulomb" ]:
            if hasattr(self, forcenm):
                # This is now extremely ugly code
                force = getattr(self, forcenm)
                self.do_force_settings(force)
                # Finally add it to the system forces. Well done!
                self.add_force_group(force, True)
                self.system.addForce(force)

    #################################################

    def check_dist(self, iatom:int, jatom:int):
        dist2 = 0
        if hasattr(self, 'core_shell') and (( iatom, jatom ) in self.core_shell or ( jatom, iatom ) in self.core_shell):
            return dist2
        for m in range(3):
            dist2 += (self.positions[iatom][m]._value - self.positions[jatom][m]._value)**2
        dist = math.sqrt(dist2)
        if abs(dist) < 0.001: # nm
            self.txt.write("Particles %d and %d have distance %g. Please check your force field, e.g. the virtual site definitions.\n" % ( iatom, jatom, dist ) )
        return dist

    def get_nb_excl(self):
        # Extract exclusions/exceptions from NonbondedForce for use in correcting PME
        # exclusions.
        self.nb_excl = {}
        self.txt.write("NonbondedForce has %d exclusions.\n" % self.nonbondedforce.getNumExceptions())
        for index in range(self.nonbondedforce.getNumExceptions()):
            # Just get the excluded atoms from the regular NB force
            iatom, jatom, *_ = self.nonbondedforce.getExceptionParameters(index)
            cexcl = ( iatom, jatom )

            allParam = None
            if VdWDict[self.vdw]["func"] == VdW.LJ12_6 and qdistDict[self.qdist] == qDist.Point:
                # Get the parameters from the standard NB force
                *iparameters, = self.nonbondedforce.getParticleParameters(iatom)
                *jparameters, = self.nonbondedforce.getParticleParameters(jatom)
                allParam      = {parameter: [iparameters[idx]._value, jparameters[idx]._value] for parameter, idx in self.parameter_indices["NonbondedForce"].items()} # NonbondedForce also stores unit
                if self.debug:
                    self.txt.write(f" default nonbonded force i {', '.join([f'{parameter}={iparameters[idx]._value}' for parameter, idx in self.parameter_indices['NonbondedForce'].items()])}\n")
                    self.txt.write(f" default nonbonded force j {', '.join([f'{parameter}={jparameters[idx]._value}' for parameter, idx in self.parameter_indices['NonbondedForce'].items()])}\n")
            elif (VdWDict[self.vdw]["func"] == VdW.LJ12_6 and qdistDict[self.qdist] == qDist.Gaussian) or VdWDict[self.vdw]["func"] in [VdW.WBHAM, VdW.GBHAM, VdW.LJ14_7]:
                # or get the parameters from the Custom NB force
                for cnb in self.customnbs:
                    if cnb["vdw"]:
                        vdwforce = cnb["force"]
                        *iparameters, = vdwforce.getParticleParameters(iatom)
                        *jparameters, = vdwforce.getParticleParameters(jatom)
                        fname = vdwforce.getName()
                        allParam      = {parameter: [iparameters[idx], jparameters[idx]] for parameter, idx in self.parameter_indices[fname].items()}
                        if self.debug:
                            self.txt.write(f" custom nonbonded force i {', '.join([f'{parameter}={iparameters[idx]}' for parameter, idx in self.parameter_indices[fname].items()])}\n")
                            self.txt.write(f" custom nonbonded force j {', '.join([f'{parameter}={jparameters[idx]}' for parameter, idx in self.parameter_indices[fname].items()])}\n")
            else:
                sys.exit("Unsupported combination of VdW (%s) and ChargeDistribution (%s)" %
                         ( dictVdW[self.vdw], dictQdist[self.qdist] ) )

            self.nb_excl[cexcl] = allParam

    def add_customnb_excls(self, myforce):
        if not self.nexcl:
            sys.exit("Please make sure nexcl is set in your force field file")
        self.txt.write("Will generate %d exclusions for %s\n" % ( self.nexcl, myforce.getName() ) )
        # First generate exclusions based on real bonds
        myforce.createExclusionsFromBonds(self.bonds, self.nexcl)
        # Make LookUp table for exclusion
        exdict = {}
        for index in range(myforce.getNumExclusions()):
            i, j = myforce.getExclusionParticles(index)
            if not i in exdict:
                exdict[i] = set()
            if not j in exdict:
                exdict[j] = set()
            exdict[i].add(j)
            exdict[j].add(i)
        self.txt.write("Created exclusion dictionary with %d keys\n" % ( len(exdict) ) )
        origdict = copy.deepcopy(exdict)
        self.txt.write("origdict %s\n" % ( str(origdict) ) )
        # Now add exclusion from vsites to constructing atoms, but avoid adding doubles
        # or OpenMM will puke.
        for index in range(myforce.getNumParticles()):
            if self.system.isVirtualSite(index):
                vsite = self.system.getVirtualSite(index)
                self.txt.write("Found vsite %d based on %d cores\n" % ( index, vsite.getNumParticles() ) )
                for j in range(vsite.getNumParticles()):
                    core = vsite.getParticle(j)
                    if not core in exdict:
                        exdict[core] = set()
                    exdict[core].add(index)
                    for k in exdict[core]:
                        if not k in exdict:
                            exdict[k] = set()
                        exdict[k].add(index)
        if hasattr(self, "core_shell"):
            self.txt.write("There are %d core-shell pairs\n" % len(self.core_shell) )
            # First add the core-shell pairs
            for shell,core in self.core_shell:
                if not core in exdict:
                    exdict[core] = set()
                exdict[core].add(shell)
                exdict[shell] = set()
                exdict[shell].add(core)
            self.txt.write("exdict %s\n" % str(exdict))
            # Then loop over the exclusions of the core
            for loop in range(1):
                for shell,core in self.core_shell:
                    for k in exdict[core]:
                        if not shell == k:
                            exdict[k].add(shell)
                            exdict[shell].add(k)
        self.txt.write("Final exclusion dict: %s\n" % str(exdict))
        for i in exdict.keys():
            for j in exdict[i]:
                if i == j:
                    continue
                if i < j and ((not i in origdict or not (i in origdict and j in origdict[i])) and
                              (not j in origdict or not (j in origdict and i in origdict[j]))):
                    myforce.addExclusion( i, j )

        self.txt.write("Found CustomNonbonded function %s with %d exclusions\n" %
                       (myforce.getName(), myforce.getNumExclusions() ) )
        if self.debug:
            for index in range(myforce.getNumExclusions()):
                # Just get the excluded atoms from the custom NB force
                iatom, jatom = myforce.getExclusionParticles(index)
                self.txt.write("Exclusion %d %d\n" % ( iatom, jatom ))

    def add_pme_excl_correction(self):
        if self.useOpenMMForce:
            return
        if not self.nonbondedMethod in [ PME, LJPME ]:
            return
        # First fetch the exclusions
        if not hasattr(self, "nb_excl"):
            self.get_nb_excl()

        # Information on how to use PME with custom Coulomb
        # https://github.com/openmm/openmm/issues/3676
        # PME uses full charges, so subtract those and add
        # TODO fetch this number from system.context
        # Now corrections for PME, dispersion only. TODO: This needs the erf function!
        vdw_pme_excl_corr = None
        if self.nonbondedMethod == LJPME and self.vdw_pme_excl_corr_expression:
            vdw_pme_excl_corr = openmm.CustomBondForce("%s" % self.vdw_pme_excl_corr_expression)
            vdw_pme_excl_corr.setName("VanderWaalsPMEExclusionCorrection")
            vdw_pme_excl_corr.addPerBondParameter("c6")

        qq_pme_excl_corr      = None
        qq_pme_excl_corr_self = None
        if self.nonbondedMethod in [ PME, LJPME ]:
            # Essmann1995, eqn. 2.5
            # The factor 1/2 is taken into acount by including the exclusions
            # in one direction only.
            qq_pme_excl_corr_expression = ( "-(%s*qiqj*erf(%s*r)/r)" % ( ONE_4PI_EPS0, self.alphaPME ) )
            if self.verbose:
                self.txt.write("qq_recip_corr '%s'\n" % qq_pme_excl_corr_expression)
            qq_pme_excl_corr  = openmm.CustomBondForce(qq_pme_excl_corr_expression)
            qq_pme_excl_corr.setName("CoulombPMEExclusionCorrection")
            qq_pme_excl_corr.addPerBondParameter("qiqj")
            # OpenMM uses point charges for PME. No need to correct for this though since 
            # this is taken care of in the reciprocal part.
            # TODO: check whether there is a difference between PC and Gaussian charges.
            # Eqn. 2.5 in Essmann1995a
            if False:
                qq_pme_excl_corr_self_expression = ("-%g*charge^2;" % ( 2*self.alphaPME*ONE_4PI_EPS0/math.sqrt(math.pi) ) )
                qq_pme_excl_corr_self = openmm.CustomCompoundBondForce(1, qq_pme_excl_corr_self_expression)
                qq_pme_excl_corr_self.addPerBondParameter("charge")
                qq_pme_excl_corr_self.setName("CoulombPMESelfEnergy")

        combdict = self.comb.combStrings()
        if self.debug:
            for param in combdict:
                self.txt.write("%s = %s\n" % ( param, combdict[param] ))

        # Now loop over missing exclusions
        for ( iatom, jatom ) in self.nb_excl:
            allParam = self.nb_excl[(iatom, jatom)]
            # Van der Waals part
            # Always add the PME exclusion, independent of our own exclusion settings.
            # This is necessary since we turned off direct-space evaluation in OpenMM
            # and therefore the PME-exclusions are not computed either.
            # Also get the parameters from the Custom NB force.
            if vdw_pme_excl_corr:
                # Use geometric combination rule
                if "sigma" in allParam:
                    sigma   = math.sqrt(allParam['sigma'][0]*allParam['sigma'][1])
                elif "rmin" in allParam:
                    sigma   = math.sqrt(allParam['rmin'][0]*allParam['rmin'][1])*2.0^(1.0/6.0)
                else:
                    sys.exit("Neither sigma nor rmin present")
                epsilon = math.sqrt(allParam['epsilon'][0]*allParam['epsilon'][1])
                c6      = 4*epsilon*sigma**6
                dist    = self.check_dist(iatom, jatom)
                vdw_pme_excl_corr.addBond(iatom, jatom, [ c6 ])
                if self.debug:
                    self.txt.write("Adding vdw_pme_excl_corr iatom %d jatom %d sigma %g epsilon %g c6 %g\n" % ( iatom, jatom, sigma, epsilon, c6 ))
            # Coulomb part
            # When using PME, add the PME exclusion, independent of our own exclusion settings
            if qq_pme_excl_corr:
                qiqj = allParam['charge'][0]*allParam['charge'][1]
                dist = self.check_dist(iatom, jatom)
                qq_pme_excl_corr.addBond(iatom, jatom, [qiqj])
                if self.debug:
                    self.txt.write(f"Adding Coul PME corr i {iatom} j {jatom} qi*qj {qiqj} dist %g\n" % dist)

        # Finally single particle self interaction
        # TODO: This is not needed. Throw away?
        # Does this differ between PC and Gaussian charges?
        if qq_pme_excl_corr_self:
            for index in range(self.nonbondedforce.getNumParticles()):
                [ charge, _, _ ] = self.nonbondedforce.getParticleParameters(index)
                # Since the addBond routine cannot know how many atoms are
                # part of this, atoms have to be specified as a list.
                qq_pme_excl_corr_self.addBond([ index ], [ charge ])

        # Finish off. Did we add any exclusion or PME corrections?
        for myforce in [ vdw_pme_excl_corr, qq_pme_excl_corr, qq_pme_excl_corr_self ]:
            if myforce and 0 < myforce.getNumBonds():
                self.add_force_group(myforce, True)
                self.system.addForce(myforce)
                mystring = ( "%s %d entries" % ( myforce.getName(), myforce.getNumBonds()))
                self.count_forces(mystring)

    def add_bonded_forces(self):
        self.bonds      = []
        self.bond_force = None
        cbfname = 'CustomBondForce'
        hbfname = 'HarmonicBondForce'
        # pairs without constraints
        for bond_force in self.system.getForces():
            if bond_force.getName() in [ cbfname, hbfname ]:
                if self.verbose:
                    self.txt.write("Found %s\n" % bond_force.getName())
                if cbfname == bond_force.getName():
                    bond_force.setName("AlexandriaBonds")
                self.count_forces("Add Bondeds")
                self.add_force_group(bond_force, False)
                for bond_index in range(bond_force.getNumBonds()):
                    # Retrieve atoms (and parameters but we just want the bonds now).
                    bondinfo = bond_force.getBondParameters(bond_index)
                    if self.debug:
                        self.txt.write("DBG: bondinfo {}\n".format(bondinfo))
                    self.bonds.append((bondinfo[0], bondinfo[1]))
                self.bond_force = bond_force
        # pairs with constraints
        for index in range(self.system.getNumConstraints()):
            iatom, jatom, _ = self.system.getConstraintParameters(index)
            self.bonds.append((iatom, jatom))
        self.angles     = []
        for b1 in self.bonds:
            for b2 in self.bonds:
                if b1[0] == b2[0] and b1[1] < b2[1]:
                    self.angles.append(( b1[1], b1[0], b2[1] ))
                elif b1[0] == b2[1] and b1[1] < b2[0]:
                    self.angles.append(( b1[1], b1[0], b2[0] ))
                elif b1[1] == b2[0] and b1[0] < b2[1]:
                    self.angles.append(( b1[0], b1[1], b2[1] ))
                elif b1[1] == b2[1] and b1[0] < b2[0]:
                    self.angles.append(( b1[0], b1[1], b2[0] ))
        if self.verbose:
            self.txt.write("There are %d angles\n" % len(self.angles))
        if self.debug:
            for b in self.bonds:
                self.txt.write("bond %d %d\n" % ( b[0], b[1] ))
            for a in self.angles:
                self.txt.write("angle %d %d %d\n" % ( a[0], a[1], a[2] ))

    def make_forces(self):
        # Create a new CustomNonbondedForce to mimic the direct space
        self.add_custom_forces()
        self.add_bonded_forces()
        # Printing details for many particle force from force field
        for g in self.forcefield.getGenerators():
            if isinstance(g, forcefield.CustomManyParticleGenerator):
                print(g.__dir__())
                self.txt.write("Many particle force detected in the force field. Following lines concern this force:\n")
                self.txt.write(f"This is the global C9 parameter {g.globalParams['C9']}\n")
                self.txt.write(f"This is the permutation mode index {g.permutationMode}\n")
                self.txt.write(f"This is the particle per set number {g.particlesPerSet}\n")
                self.txt.write(f"This is the bond cutoff {g.bondCutoff}\n")
                self.txt.write(f"Finally, this is the energy expression:  {g.energy}\n")
        for force in self.system.getForces():
            if (force.getName() in [ "CustomAngleForce", "HarmonicAngleForce" ] and
                0 == force.getNumAngles()):
                self.del_force(force)
            elif (force.getName() in [ "RBTorsionForce", "PeriodicTorsionForce" ] and
                  0 == force.getNumTorsions()):
                self.del_force(force)
            elif force.getName() == "CMMotionRemover":
                force.setFrequency(self.sim_params.getInt('commremoval_frequency', 10))
                if force.getFrequency() <= 0:
                    self.del_force(force)

    def print_force_settings(self):
        for force in self.system.getForces():
            self.txt.write("----------------------------\n")
            self.txt.write("%s Group: %d, PBC: %s\n" % ( force.getName(),
                                                         force.getForceGroup(),
                                                         str(force.usesPeriodicBoundaryConditions())))
            if hasattr(force, 'getEnergyFunction'):
                self.txt.write('Expression {0}\n'.format(force.getEnergyFunction()))
            if hasattr(force, 'getNumPerBondParameters') and hasattr(force, 'getPerBondParameterName'):
                self.txt.write('Parameters {0}\n'.format(', '.join([force.getPerBondParameterName(i) for i in range(force.getNumPerBondParameters())])))
            if hasattr(force, 'getNumPerParticleParameters'):
                self.txt.write("Parameter")
                for i in range(force.getNumPerParticleParameters()):
                    self.txt.write(" %d %s" % ( i, force.getPerParticleParameterName(i)))
                self.txt.write("\n")
            if hasattr(force, 'getNonbondedMethod'):
                self.txt.write('NonbondedMethod {0}\n'.format(force.getNonbondedMethod()))
            if hasattr(force, 'getCutoffDistance'):
                self.txt.write('Cutoff {0}\n'.format(force.getCutoffDistance()))
            if hasattr(force, 'getUseSwitchingFunction'):
                self.txt.write('SwitchingFunction {0}\n'.format(force.getUseSwitchingFunction()))
            if hasattr(force, 'getSwitchingDistance'):
                self.txt.write('SwitchingDistance {0}\n'.format(force.getSwitchingDistance ()))
            if hasattr(force, "getUseDispersionCorrection"):
                self.txt.write('Dispersion Correction {0}\n'.format(force.getUseDispersionCorrection()))
            if hasattr(force, "getReciprocalSpaceForceGroup"):
                self.txt.write('Reciprocal Force Group {0}\n'.format(force.getReciprocalSpaceForceGroup()))
            if hasattr(force, "getUseLongRangeCorrection"):
                self.txt.write('UseLongRangeCorrection {0}\n'.format(force.getUseLongRangeCorrection()))
            if hasattr(force, "getReactionFieldDielectric"):
                self.txt.write("Reaction Field Epsilon {0}\n".format(force.getReactionFieldDielectric()))
            if hasattr(force, "getNumBonds"):
                self.txt.write("Number of bonds/pairs %d\n" % ( force.getNumBonds() ) )
            if hasattr(force, "getNumParticles"):
                self.txt.write("Number of particles %d\n" % force.getNumParticles())
                if self.debug:
                    for i in range(force.getNumParticles()):
                        self.txt.write("Atom %d params: %s\n" % ( i, str(force.getParticleParameters(i)) ) )
            if hasattr(force, "getNumAngles"):
                self.txt.write("Number of angles %d\n" % ( force.getNumAngles()))
        self.txt.write("----------------------------\n")

    def set_platform(self):
        # GPU/CPU platform
        platform            = self.sim_params.getStr("usePlatform")
        available_platforms = [Platform.getPlatform(i).getName() for i in range(Platform.getNumPlatforms())]
        if platform in available_platforms:
            self.txt.write(f"Requested platform {platform} found.\n")
        else:
            self.txt.write(f"Requested platform {platform} not found. Looking through available alternatives...\n")
            for alternative_platform in ["CUDA", "OpenCL", "CPU", "Reference"]:
                alternative_found = False
                if alternative_platform in available_platforms:
                    platform = alternative_platform
                    self.txt.write(f"Alternative platform {platform} found.\n")
                    alternative_found = True
                    break
            if not alternative_found:
                sys.exit("Found no suitable platform to carry out computations. Exiting...\n")
        self.platform = Platform.getPlatformByName(platform)
        self.txt.write(f"Using OpenMM version {self.platform.getOpenMMVersion()} on platform {self.platform.getName()}.\n")
        # platform precison
        available_properties = self.platform.getPropertyNames()
        for property, alternative_values in [('Precision', ['double', 'single', 'mixed'])]:
            if f"use{property}" in self.sim_params.params:
                if property in available_properties:
                    value = self.sim_params.getStr(f"use{property}")
                    self.platform.setPropertyDefaultValue(property, value)
                    self.txt.write(f"Requested platform property {property} set to default value {value}.\n")
                else:
                    self.txt.write(f"Property {property} does not exist for platform {self.platform.getName()}.\n")
        # summary of properties
        if self.debug:
            for property in available_properties:
                value = self.platform.getPropertyDefaultValue(property)
                self.txt.write("Property %s value %s\n" % ( property, str(value) ))

    def set_algorithms(self):
        #### Thermostat / Barostat ####
        if self.nonbondedMethod != NoCutoff:
            if self.sim_params.getBool('useMonteCarloBarostat'):
                if self.verbose:
                    self.txt.write("Monte Carlo Barostat will be used.\n")
                self.system.addForce(MonteCarloBarostat(self.sim_params.getFloat('pressure'),
                                                        self.temperature_c,
                                                        self.sim_params.getInt('barostatInterval')))
            elif self.sim_params.getBool('useMonteCarloAnisotropicBarostat'):
                self.system.addForce(MonteCarloAnisotropicBarostat(self.pressvec,self.temperature_c,self.scaleX,self.scaleY,self.scaleZ,self.sim_params.getInt('barostatInterval')))
                if self.verbose:
                    self.txt.write(f"Monte Carlo ANISOTROPIC Barostat will be used. The dimensions that can change are: X = {self.scaleX} Y = {self.scaleY} Z = {self.scaleZ}\n")
        if self.useAndersenThermostat:
            self.system.addForce(AndersenThermostat(self.temperature_c, self.col_freq))
            if self.verbose:
                self.txt.write(f"Andersen Thermostat will be used with temperature {self.temperature_c}\n")

        #### Integrator ####
        friction_c    = self.sim_params.getFloat('friction_c')
        temperature_s = self.sim_params.getFloat('temperature_s')
        integrator    = self.sim_params.getStr('integrator')
        if self.polarizable:
            dli = "DrudeLangevinIntegrator"
            if dli == integrator:
                self.integrator = DrudeLangevinIntegrator(self.temperature_c, friction_c, temperature_s,
                                                          self.sim_params.getFloat('friction_s'), self.dt)
            elif "DrudeNoseHooverIntegrator" == integrator:
                self.integrator = DrudeNoseHooverIntegrator(self.temperature_c, friction_c, temperature_s,
                                                            self.sim_params.getFloat('friction_s'), self.dt)
            elif "DrudeSCFIntegrator" == integrator:
                self.integrator = DrudeSCFIntegrator(self.dt)
                self.integrator.setDrudeTemperature(temperature_s)
            else:
                self.txt.write("Unsupported integrator %s for polarizable system, will use %s instead\n"
                               % ( integrator, dli ))
                self.integrator = DrudeLangevinIntegrator(self.temperature_c, friction_c, temperature_s,
                                                          self.sim_params.getFloat('friction_s'), self.dt)
            if self.useAndersenThermostat and not "DrudeSCFIntegrator" == integrator:
                self.txt.write("Andersen thermostat will be turned off since %s contains a built-in thermostat.\n"
                               % self.integrator)
                self.useAndersenThermostat = False
            self.integrator.setMaxDrudeDistance(self.maxDrudeDist)
        else:
            nhi = "NoseHooverIntegrator"
            if nhi != integrator:
                self.txt.write("Unsupported integrator %s for non-polarizable system, will use %s instead\n"
                               % ( integrator, nhi ))
            self.integrator = NoseHooverIntegrator(self.temperature_c, friction_c, self.dt)

        # Print some stuff yey.
        if self.verbose:
            self.txt.write("Core Temperature %g\n" % self.temperature_c)
            if self.polarizable:
                self.txt.write("Drude Temperature %g\n" % self.integrator.getDrudeTemperature()._value)
            self.txt.write("Integration time step %g\n" % self.integrator.getStepSize()._value)

    def compute_dipole(self)->list:
        positions = self.simulation.context.getState(getPositions=True).getPositions()
        dip = [ 0, 0, 0 ]
        enm2Debye = 48.0321
        for index in range(self.system.getNumParticles()):
            for m in range(3):
                dip[m] += positions[index][m]._value * self.charges[index] * enm2Debye
        self.txt.write("\nDipole [ %g %g %g ] total %g\n" % ( dip[0], dip[1], dip[2],
                                                              math.sqrt(dip[0]**2+dip[1]**2+dip[2]**2)))
        return dip

    def init_simulation(self):
        #### Simulation setup ####
        self.simulation = Simulation(self.topology, self.system, self.integrator, self.platform)
        self.simulation.context.setPositions(self.positions)

    def update_positions(self):
        #### Set positions of shell system to almost zero) ####
        #### the shell displacement is necessary for the LJPME to work, otherwise an error is thrown:
        #### simtk.openmm.OpenMMException: Particle coordinate is nan
        positions = self.simulation.context.getState(getPositions=True).getPositions()
        new_pos = []
        for index in range(self.system.getNumParticles()):
            if (not self.polarizable or not index in self.shells):
                new_pos_x = positions[index][0]
                new_pos.append((new_pos_x,positions[index][1],positions[index][2]))
            if (self.polarizable and index in self.shells):
                new_pos_x = positions[index][0]+0.001*nanometer
                new_pos_y = positions[index][1]+0.001*nanometer
                new_pos_z = positions[index][2]+0.001*nanometer
                new_pos.append((new_pos_x,new_pos_y,new_pos_z))

        self.simulation.context.setPositions(new_pos)
        if self.debug:
            self.txt.write(f"number of particles (incl. drudes):  {self.system.getNumParticles()}\n")
            for np in new_pos:
                self.txt.write("%10.5f  %10.5f  %10.5f\n" % ( np[0]._value, np[1]._value, np[2]._value ))

    def remove_unused_forces(self):
        if not self.useOpenMMForce and not self.nonbondedMethod in [ PME, LJPME ]:
            # Remove the default Non-Bonded with OpenMM
            self.txt.write("Will remove standard (OpenMM) NonBondedForce\n")
            self.del_force(self.nonbondedforce, False)
        # TODO check whether this statement is correct.
        # We remove the input vdw function that is now split over separate coulomb and vdw
        for cnb in self.customnbs:
            if cnb["vdw"]:
                self.txt.write("Will remove CustomNonBondedForce %s\n" % cnb["pot"])
                self.del_force(cnb["force"])

    def update_forces(self):
        for myforce in self.system.getForces():
            if myforce.getName() in self.fgnumber and not myforce.getName() in [ "CMMotionRemover", "MonteCarloAnisotropicBarostat", "MonteCarloBarostat" ]:
                if self.verbose:
                    self.txt.write("Will update force settings %s\n" % myforce.getName())
                myforce.updateParametersInContext(self.simulation.context)


    def dhvap(self, epot:float)->float:
        if None == self.emonomer:
            return None
        nmol    = self.topology.getNumResidues()
        relener = epot/nmol - self.emonomer
        kB      = 1.380649e-23 * 6.02214e23 / 1000
        return kB*self.temperature_c - relener

    def dump_forces(self):
        self.txt.write("DBG: Checking spurious energies\n")
        for force in self.system.getForces():
            fcname   = force.getName()
            fgnumber = force.getForceGroup()
            self.txt.write("DBG: Force %s number %d\n" % ( fcname, fgnumber ))
        for group in range(16):
            eterm = self.simulation.context.getState(getEnergy=True, groups=(1 << group)).getPotentialEnergy()/unit.kilojoule_per_mole
            self.txt.write('DBG: group %2d energy %16.4f kJ/mol\n' % (group, eterm))

    def print_energy(self, title:str):
        self.txt.write("\n%s:\n" % title)
        etot = 0.0
        self.count_forces("Print energy")
        if self.verbose:
            for myforce in self.system.getForces():
                self.txt.write("%s\n" % myforce.getName())
        epme = 0
        for group in self.force_group:
            eterm = self.simulation.context.getState(getEnergy=True, groups=(1 << group)).getPotentialEnergy()/unit.kilojoule_per_mole
            etot += eterm
            self.txt.write('%-40s %2d %16.8f kJ/mol\n' % (self.force_group[group], group, eterm))
        self.potE = self.simulation.context.getState(getEnergy=True).getPotentialEnergy()/unit.kilojoule_per_mole
        ener_diff = self.potE-etot
        self.txt.write('Potential energy = %.5f kJ/mol.' % self.potE )
        if self.potE != 0 and abs(ener_diff)/abs(self.potE) >= 1e-3:
            self.txt.write(' WARNING: potE-etot %.5f\n' % (ener_diff))
            self.dump_forces()
        else:
            self.txt.write("\n")
        if None != self.emonomer:
            nmol = self.topology.getNumResidues()
            einter = self.potE - nmol*self.emonomer
            self.txt.write('Interaction energy for %d-mer %g\n' % ( nmol, einter ))
            self.txt.write('Delta H vap %g kJ/mol\n' % ( self.dhvap(self.potE) ) )
        if abs(self.potE-etot) > 1e-3:
            self.txt.write("sum of the above %.5f\n" % (etot))
        self.txt.flush()

    def potential_energy(self)->float:
        return self.potE

    def minimize_energy(self, maxIter:int)->float:
        #### Minimize energy ####
        enertol = Quantity(value=1e-8, unit=kilojoule/(nanometer*mole))
        self.txt.write("\nPerforming energy minimization with force tolerance %s " % ( str(enertol)))
        if maxIter == 0:
            self.txt.write("until convergence.\n")
        else:
            self.txt.write("and maxIter = %d.\n" % maxIter)
        self.simulation.minimizeEnergy(tolerance=enertol, maxIterations=maxIter)
        return self.simulation.context.getState(getEnergy=True).getPotentialEnergy()/unit.kilojoule_per_mole

    def set_positions(self, positions:list):
        oldpos = self.get_positions()
        if len(oldpos) != len(positions):
            sys.exit("System has %d coordinates, but you are trying to set %d" % ( len(oldpos), len(positions )))
        self.simulation.context.setPositions(positions)

    def get_positions(self)->list:
        return self.simulation.context.getState(getPositions=True).getPositions()

    def get_residue_positions(self, resnr:int)->list:
        allpos = self.get_positions()
        respos = []
        for res in self.topology.residues():
            if res.index == resnr:
                for atom in res.atoms():
                    respos.append(allpos[atom.index])

        return respos

    def minimize_shells(self)->float:
        # Store atom masses
        oldmass = {}
        for res in self.topology.residues():
            for atom in res.atoms():
                if atom.element:
                    oldmass[atom.index] = self.system.getParticleMass(atom.index)
                    self.system.setParticleMass(atom.index, 0)
        # Compute energy after just minimizing shells
        ener = self.minimize_energy(0)
        # Restore atom masses
        for res in self.topology.residues():
            for atom in res.atoms():
                if atom.element:
                    self.system.setParticleMass(atom.index, oldmass[atom.index])
        return ener

    def equilibrate(self, constantVolume:bool=False):
        ensemble  = "NpT"
        frequency = self.sim_params.getInt('barostatInterval')
        for force in self.system.getForces():
            if force.getName() in [ "MonteCarloAnisotropicBarostat", "MonteCarloBarostat" ]:
                if constantVolume:
                    # Set frequency to more than the number of steps
                    force.setFrequency(self.equilibrationSteps + 1)
                    ensemble = "NVT"
                else:
                    force.setFrequency(frequency)

        self.txt.write('\n%s equilibration for %d steps at T = %g K.\n' %
                       ( ensemble, self.equilibrationSteps, self.temperature_c) )
        self.simulation.context.setVelocitiesToTemperature(self.temperature_c)
        self.simulation.step(self.equilibrationSteps)

    def production(self):
        simtime = self.sim_params.getFloat('dt')*self.sim_params.getInt('steps')
        self.txt.write('\nSimulating %g ps at %g K...\n' % (simtime, self.temperature_c ))
        if None != self.dataReporter:
            self.simulation.reporters.append(self.dataReporter)
        if None != self.pdbReporter:
            self.simulation.reporters.append(self.pdbReporter)
        if None != self.xtcReporter:
            self.simulation.reporters.append(self.xtcReporter)
        if None != self.chkReporter:
            self.simulation.reporters.append(self.chkReporter)
        self.simulation.currentStep = 0
        self.simulation.step(self.steps)

    def setup(self):
        self.set_params()
        self.start_output()
        self.make_system()
        self.set_algorithms()
        self.set_platform()
        self.init_forces()
        self.get_parameter_indices()
        self.make_forces()
        if not self.useOpenMMForce:
            for cnbname in [ "custom_vdw", "custom_coulomb" ]:
                if hasattr(self, cnbname):
                    self.add_customnb_excls(getattr(self, cnbname))
            for cnb in self.customnbs:
                self.add_customnb_excls(cnb["force"])
        self.add_pme_excl_correction()
        self.remove_unused_forces()
        self.print_force_settings()
        self.init_simulation()
        self.update_forces()
        self.update_positions()
        if self.verbose:
            self.print_force_settings()
        self.print_energy("Initial energies")

    def minimize(self, maxIter:int=0)->float:
        epot = self.minimize_energy(maxIter)
        self.print_energy("After minimization")
        return epot

    def write_coordinates(self, outfile:str):
        format = outfile[-3:]
        with open(outfile, "w") as outf:
            pbc = False
            if self.nonbondedMethod != NoCutoff:
                vecs = self.simulation.context.getState().getPeriodicBoxVectors()
                self.topology.setPeriodicBoxVectors(vecs)
                pbc = True
            positions = self.simulation.context.getState(getPositions=True, enforcePeriodicBox=pbc, getParameters=True).getPositions()
            if "pdb" == format:
                self.pdb.writeFile(self.topology, positions, outf)
            elif "xyz" == format:
                write_xyz(outf, self.topology, positions)
            else:
                write_sdf(outf, self.topology, positions, self.charges, self.bonds, self.my_shell, self.debug)

    def run(self):
        self.setup()
        # load previous state; no equilibration
        if self.chkReporter and self.chkfile and os.path.isfile(self.chkfile):
            with open(self.chkfile, 'rb') as chk:
                self.simulation.context.loadCheckpoint(chk.read())
            self.print_energy("After loading checkpoint")
        # start fresh; start by equilibration
        else:
            self.minimize(maxIter=self.minimizationSteps)
            self.equilibrate(constantVolume=True)
            self.equilibrate(constantVolume=False)
            self.print_energy("After equilibration")
        # reset time (former outputs will be overwritten anyway)
        self.simulation.context.setTime(0.0)
        # finally, run production
        self.production()
        self.print_energy("After production")

    #############################################################
    #                  U T I L I T I E S                        #
    #############################################################
    def act_charges(self)->str:
        # Return all charges in ACT order, that is
        # Core Shell Core Shell Vsite Core Shell etc.
        charges = ""
        if self.polarizable:
            for i in range(len(self.charges)):
                if i in self.cores:
                    charges += " " + str(self.charges[i])
                    # Check whether there is a shell
                    if i in self.my_shell:
                        charges += " " + str(self.charges[self.my_shell[i]])
                elif not i in self.shells:
                    # We found something that is neither core nor shell.
                    # Likely a vsite.
                    charges += " " + str(self.charges[i])

        else:
            for i in range(len(self.charges)):
                charges += " " + str(self.charges[i])
        return charges

    def log_to_xvg(self, xvg:str, ytargets:list):
        if None == self.enefile or not os.path.exists(self.enefile):
            print("Could not find any log file")
        else:
            xtarget  = "Time (ps)"
            ix = -1
            iy = []
            with open(xvg, "w") as outf:
                outf.write("@ xaxis label \"%s\"\n" % xtarget)
                with open(self.enefile, "r") as inf:
                    for line in inf:
                        words = line.strip().split(";")
                        if line.find("#") >= 0:
                            for i in range(len(words)):
                                if words[i].find(xtarget) >= 0:
                                    ix = i
                                else:
                                    for j in range(len(ytargets)):
                                        if words[i].find(ytargets[j]) >= 0:
                                            iy.append(i)
                        elif ix >= 0 and len(iy) > 0:
                            try:
                                outf.write("%10g" % float(words[ix]))
                                for ii in iy:
                                    outf.write("  %10g" % (float(words[ii])))
                                outf.write("\n")
                            except ValueError:
                                print("Incomprehensible line in ene_file %s" % self.enefile)

    def log_to_average(self, ytargets:dict)->dict:
        if None == self.enefile or not os.path.exists(self.enefile):
            print("Could not find any log file")
            return []
        else:
            myaver  = {}
            for i in ytargets.keys():
                myaver[i] = 0
            naver   = 0
            xtarget = "Time (ps)"
            ix      = -1
            iy      = {}
            iy_rev  = {}
            with open(self.enefile, "r") as inf:
                for line in inf:
                    words = line.strip().split(";")
                    if line.find("#") >= 0:
                        for i in range(len(words)):
                            if words[i].find(xtarget) >= 0:
                                ix = i
                            else:
                                for j in ytargets.keys():
                                    if words[i].find(ytargets[j]) >= 0:
                                        iy[j]     = i
                                        iy_rev[i] = j
                    elif ix >= 0 and len(iy.keys()) > 0:
                        try:
                            for ii in iy.keys():
                                myaver[iy_rev[iy[ii]]] += float(words[iy[ii]])
                            naver += 1
                        except ValueError:
                            print("Incomprehensible line in ene_file %s" % self.enefile)
            if naver > 0:
                for i in myaver.keys():
                    myaver[i] /= naver
            return myaver

if __name__ == "__main__":
    pass
