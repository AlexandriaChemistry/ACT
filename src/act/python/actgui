#!/usr/bin/env python3

# This script is part of the Alexandria Chemistry Toolkit
# https://github.com/AlexandriaChemistry/ACT
# License is GPL v. 2

import copy, os, sys, tempfile, webbrowser, time
import tkinter as tk
import tkinter.font as tkFont
from tkinter import filedialog
from tkinter import messagebox
from tkinter import ttk
from PIL import ImageTk, Image

# Some global variables
Atom     = "Atom"
VSite    = "VSite"
Shell    = "Shell"
Point    = "Point"
Gaussian = "Gaussian"
Slater   = "Slater"
PG       = "P+G"

def labelFont():
    return ('Helvetica', 20, 'bold')

def library_file(filenm:str)->str:
    if os.path.exists(filenm):
        return filenm
    actdata = "ACTDATA"
    if actdata in os.environ:
        filenm2 = ( "%s/%s" % ( os.environ[actdata], filenm ))
    if os.path.exists(filenm2):
        return filenm2
    print("Cannot find file '%s'" % filenm)
    return None
    
def saveasfile(mytitle:str, defext:str)->str:
    # Get file name
    # Loop to make sure we get a file name with the correct extension
    ext    = ""
    file_path = True
    while file_path and not ext == defext:
        file_path = filedialog.asksaveasfilename(title=mytitle, defaultextension=defext)
        if file_path:
            _,ext = os.path.splitext(file_path)
        else:
            return None
    return file_path

def openasfile(mytitle:str, defext:str)->str:
    # Get file name
    # Loop to make sure we get a file name with the correct extension
    ext    = ""
    file_path = True
    while file_path and not ext == defext:
        file_path = filedialog.askopenfilename(title=mytitle, defaultextension=defext)
        if file_path:
            _,ext = os.path.splitext(file_path)
        else:
            return None
    return file_path

def show_info(msg:str):
    messagebox.showinfo("ACT GUI", msg)


# Code for ToolTips taken from
# https://stackoverflow.com/questions/3221956/how-do-i-display-tooltips-in-tkinter
class CreateToolTip(object):
    """
    create a tooltip for a given widget
    """
    def __init__(self, widget, text='widget info'):
        self.waittime = 500     #miliseconds
        self.wraplength = 180   #pixels
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)
        self.id = None
        self.tw = None

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.widget.after_cancel(id)

    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.tw = tk.Toplevel(self.widget)
        # Leaves only the label and removes the app window
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry("+%d+%d" % (x, y))
        label = tk.Label(self.tw, text=self.text, justify='left',
                         background="#ffffff", relief='solid', borderwidth=1,
                         wraplength = self.wraplength)
        label.pack(ipadx=1)

    def hidetip(self):
        tw = self.tw
        self.tw= None
        if tw:
            tw.destroy()

class VdwSel:
    def __init__(self, frame, myrow:int, mycol:int):
        self.vdws = { 
            "TT2b": 
            { "sig_min": 0, "sig_max": 1, "eps_min": 0, "eps_max": 5,
              "gam_min":0, "gam_max": 0, "del_min": 0, "del_max": 0,
              "comment": "Tang-Toennies with separate b\nSheng et al. Phys. Rev. Lett. 125 (2020) 2534 " },
            "WANG_BUCKINGHAM":
            { "sig_min": 0, "sig_max": 1, "eps_min": 0, "eps_max": 5,
              "gam_min":1, "gam_max": 25, "del_min": 0, "del_max": 0,
              "comment": "Bucking variant without singularity\nWang et al. J. Chem. Theory Comput. 9 (2013) 452" },
            "LJ14_7":
            { "sig_min": 0, "sig_max": 1, "eps_min": 0, "eps_max": 5, 
              "gam_min":0, "gam_max": 0.8, "del_min": 0, "del_max": 2,
              "comment": "Buffered 14-7 potential\nHalgren, J. Amer. Chem. Soc. 114 (1992) 7827" }, 
            "LJ12_6":
            { "sig_min": 0, "sig_max": 1, "eps_min": 0, "eps_max": 5,
              "gam_min":0, "gam_max": 0, "del_min": 0, "del_max": 0,
              "comment": "Lennard-Jones potential\nJones, Proc. Royal Soc. A 106 (1924) 463" },
            "GENERALIZED_BUCKINGHAM":
            { "sig_min": 0, "sig_max": 1, "eps_min": 0, "eps_max": 5,
              "gam_min":1, "gam_max": 25, "del_min": 3, "del_max": 12,
              "comment": "Generalized Buckingham\nWerhahn et al. Chem. Phys. Lett. 619 (2015) 133" },
        }
        self.vdwPot = tk.StringVar(frame, "WANG_BUCKINGHAM")
        labPot = tk.Label(frame, text=f"Van der Waals potential",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        myrow += 1
        for vdw in self.vdws.keys():
            item = tk.Radiobutton(frame, text=vdw, variable=self.vdwPot,
                                  value=vdw, command=None)
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            tpp = CreateToolTip(item, self.vdws[vdw]["comment"])
            myrow += 1

        labParticle = tk.Label(frame, text=f"Use VdW on", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        self.vdwPart = {}
        ptypes = { Atom: 1, VSite: 0, Shell: 0 }
        for ptype in ptypes.keys():
            self.vdwPart[ptype] = tk.IntVar()
            self.vdwPart[ptype].set(ptypes[ptype])
            item = tk.Checkbutton(frame, text=ptype, command=None,
                                  variable=self.vdwPart[ptype])
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

        labParticle = tk.Label(frame, text=f"Options", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        self.exchcorr = tk.IntVar()
        item = tk.Checkbutton(frame, text="Exchange correction on vsites", command=None,
                              variable=self.exchcorr)
        item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        ttp = CreateToolTip(item, "For sigma-holes\nKriz & Van der Spoel, J. Phys. Chem. Lett. 15 (2024) 9974")
        myrow += 1

        labPot = tk.Label(frame, text=f"Number of exclusions",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        myrow += 1
        
        self.nexcl = tk.IntVar()
        self.nexcl.set(2)
        excl = [ 1, 2 ]
        for ie in excl:
            item = tk.Radiobutton(frame, text=str(ie), variable=self.nexcl,
                                  value=ie, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

        self.myrow = myrow

    def potential(self)->str:
        return self.vdwPot.get()

    def exchCorr(self)->int:
        return self.exchcorr.get()

    def nExcl(self)->int:
        return self.nexcl.get()

    def vdwParticles(self)->dict:
        vdwP = {}
        for vdw in self.vdwPart.keys():
            vdwP[vdw] = self.vdwPart[vdw].get()
        return vdwP

    def nrows(self)->int:
        return self.myrow
        
    def bounds(self)->dict:
        return self.vdws[self.potential()]

class QSel:
    def __init__(self, root, myrow:int, mycol:int):
        gharemanpour2018b = "Distributed charges\nGhahremanpour et al. J. Chem. Theory Comput. 14 (2018) 5553"
        self.qs = { Point: "Point charges", 
                    Gaussian: gharemanpour2018b, 
                    Slater: gharemanpour2018b, 
                    PG: "Point+Gaussian\nVan der Spoel & Hosseini, Phys. Chem. Chem. Phys. 27 (2025) 13817" }
        self.qmodel = tk.StringVar(root, Gaussian)
        labPot = tk.Label(root, text=f"Charge model",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        for q in self.qs.keys():
            item = tk.Radiobutton(root, text=q, variable=self.qmodel, value=q, command=None)
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            ttp = CreateToolTip(item, self.qs[q])
            myrow += 1

        # Epsilon R
        labPot = tk.Label(root, text=f"Relative dielectric constant",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        self.epsr = tk.StringVar()
        self.epsr.set("1")
        item = tk.Entry(root, textvariable=self.epsr).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        labParticle = tk.Label(root, text=f"Options", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        # Charge symmetrization for CH3 groups etc. 
        self.qsymm = tk.IntVar()
        self.qsymm.set(1)
        item = tk.Checkbutton(root, text="Enforce charge symmetry", command=None,
                              variable=self.qsymm).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        
        # Polarization
        self.pol = tk.IntVar()
        self.pol.set(0)
        item = tk.Checkbutton(root, text="Polarizability", command=None,
                              variable=self.pol).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        self.myrow = myrow

    def symm(self):
        return self.qsymm.get()

    def qModel(self):
        return self.qmodel.get()

    def polarizable(self):
        return self.pol.get()

    def nrows(self)->int:
        return self.myrow

    def epsilonR(self)->float:
        try:
            eee = float(self.epsr.get())
            return eee
        except ValueError:
            print("Value entered for dielectric constant incomprehensible, using 1")
            return 1

class BondSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.bonds = ["BONDS", "CUBIC", "HUA", "MORSE" ]
        self.bondPot = tk.StringVar(root, f"{self.bonds[2]}")
        labPot = tk.Label(root, text=f"Bond potential", anchor="w", font=labelFont())
        labPot.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        tpp = CreateToolTip(labPot, "Van Maaren & Van der Spoel\nDigit. Discov. 4 (2025) 824")
        myrow += 1

        for bond in self.bonds:
            item = tk.Radiobutton(root, text=bond, variable=self.bondPot,
                                  value=bond, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

    def potential(self):
        return self.bondPot.get()

    def nrows(self)->int:
        return len(self.bonds)+1

class AngleSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.angles = ["ANGLES", "UREY_BRADLEY" ]
        self.anglePot = tk.StringVar(root, f"{self.angles[0]}")
        labPot = tk.Label(root, text=f"Angle potential", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        for angle in self.angles:
            item = tk.Radiobutton(root, text=angle, variable=self.anglePot,
                                  value=angle, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

    def potential(self):
        return self.anglePot.get()

    def nrows(self)->int:
        return len(self.angles)+1

class DihSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.dihs = ["PDIHS", "FOURDIHS" ]
        self.dihPot = tk.StringVar(root, f"{self.dihs[1]}")
        labPot = tk.Label(root, text=f"Dihedral potential", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        for dih in self.dihs:
            item = tk.Radiobutton(root, text=dih, variable=self.dihPot,
                                  value=dih, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

    def potential(self):
        return self.dihPot.get()

    def nrows(self)->int:
        return len(self.dihs)+1

class ICSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.ics = { "NONE": "No corrections", 
                     "MACDANIEL_SCHMIDT": "Negative exponential correction\nMcDaniel & Schmidt, J. Phys. Chem. 117 (2013) 2053",
                     "MORSE_BONDS": "Correction with repulsive and attractive part\nHosseini & Van der Spoel, in preparation" }
        self.icPot = tk.StringVar(root, "NONE")
        labPot = tk.Label(root, text=f"Induction correction potential", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        for ic in self.ics.keys():
            item = tk.Radiobutton(root, text=ic, variable=self.icPot,
                                  value=ic, command=None)
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            ttp = CreateToolTip(item, self.ics[ic])
            myrow += 1

    def potential(self):
        return self.icPot.get()

    def nrows(self)->int:
        return len(self.ics)+1

class AtomTypes:
    def __init__(self, frame, myrow, mycol):
        atype_gui = library_file("atomtypes_gui.csv")
        if not atype_gui:
            sys.exit("No atom type definitions")
        self.atype_props = {}
        with open(atype_gui, "r") as inf:
            lineno = 0
            for line in inf:
                lineno += 1
                if line.startswith("#"):
                    continue
                words = line.strip().split("|")
                if len(words) == 8:
                    try:
                        self.atype_props[words[0]] = { "Element": words[1],
                                                       "Default": int(words[2]),
                                                       "Bonds": int(words[3]),
                                                       "Radius": float(words[4]),
                                                       "Row": int(words[5]),
                                                       "Charge": int(words[6]),
                                                       "Comment": words[7] }
                    except ValueError:
                        sys.exit(f"Error in file {atype_gui} on line {lineno}")

        maxrow = 6
        ncol = int(len(self.atype_props.keys())/maxrow)+1
        labParticle = tk.Label(frame, text=f"Select atomtypes", anchor="w", font=labelFont())
        labParticle.grid(row=myrow, columnspan=ncol, sticky=tk.N+tk.S+tk.W+tk.E)
        ttp = CreateToolTip(labParticle, "Atomtype definitions based on GAFF\nWang et al. J. Comp. Chem. 25 (2004) 1157")
        myrow += 1
        btnOn  = tk.Button(frame, text="Select all", anchor="w", font=labelFont(), command=self.allOn)
        btnOn.grid(row=myrow+2, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        btnOff = tk.Button(frame, text="Deselect all", anchor="w", font=labelFont(), command=self.allOff)
        btnOff.grid(row=myrow+4, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        mycol += 1
        self.atypes = {}
        for at in self.atype_props.keys():
            self.atypes[at] = tk.IntVar()
            self.atypes[at].set(self.atype_props[at]["Default"])
            item = tk.Checkbutton(frame, text=at, command=None,
                                  variable=self.atypes[at])
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
            ttp = CreateToolTip(item, text=self.atype_props[at]["Comment"])
            myrow += 1
            if myrow == maxrow+1:
                myrow = 1
                mycol += 1

    def allOn(self):
        for at in self.atypes:
            self.atypes[at].set(1)
            self.atype_props[at]["Default"] = 1
            
    def allOff(self):
        for at in self.atypes:
            self.atypes[at].set(0)
            self.atype_props[at]["Default"] = 0
            
    def getAtypes(self)->dict:
        atprops = {}
        for at in self.atypes:
            if self.atypes[at].get():
                atprops[at] = copy.deepcopy(self.atype_props[at])
                atprops[at]["Default"] = 1
        return atprops

class ACTLogo:
    def __init__(self, size:int, root):
        actlogo = library_file("ACTlogo2.png")
        if actlogo:
            self.icon = ImageTk.PhotoImage(Image.open(actlogo))
            self.logo = ttk.Label(root, image=self.icon, justify="center",
                                  width=size)
        else:
            # TODO: build in alternative if the logo image is not present
            sys.exit("Cannot find %s" % actlogo)

    def set_icon(self, root):
        root.tk.call('wm', 'iconphoto', root._w, self.icon)

    def set_grid(self, myrow=0, mycol=0):
        # The sticky stuff is incomprehensible...
        self.logo.grid(row=myrow, column=mycol, sticky="ns")

class GeometryFF:
    def __init__(self, root):
        self.root = root

    def run(self)->int:
        molprop = openasfile("Molecule Property File (molprop)", ".xml")
        if not molprop:
            return 1
        ffin = openasfile("Input/output force field file", ".xml")
        if not ffin:
            return 1
        #ffout = openasfile("Output force field file", ".xml")
        #if not ffout:
        #    return 1
        status = os.system(f"alexandria geometry_ff -ff {ffin} -mp {molprop} -o {ffin}")
        if status == 0:
            show_info(f"Updated bond information in {ffin}")
        return status

def callback(url:str):
    webbrowser.open_new(url)

class GeometryFF:
    def __init__(self, root):
        self.root = root

    def run(self)->int:
        molprop = openasfile("Molecule Property File (molprop)", ".xml")
        if not molprop:
            return 1
        ffin = openasfile("Input/output force field file", ".xml")
        if not ffin:
            return 1
        #ffout = openasfile("Output force field file", ".xml")
        #if not ffout:
        #    return 1
        status = os.system(f"alexandria geometry_ff -ff {ffin} -mp {molprop} -o {ffin}")
        if status == 0:
            show_info(f"Updated bond information in {ffin}")
        return status

class Manager:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("ACT - GUI")
        self.root.configure()
        
        default_font = tkFont.nametofont("TkDefaultFont")
        default_font.configure(size=16)
        
        # TODO: get this number from the image size
        logo_size = 150
        self.pad = 5
        self.height = logo_size+2*self.pad
        self.width = 2*self.height
        self.root.minsize(self.width, self.height)
        self.root.maxsize(2*self.width, 2*self.height)
        self.content = ttk.Frame(self.root, padding=(self.pad,self.pad,self.pad,self.pad))
        self.content.grid(row=0, column=0, rowspan=1, columnspan=2, sticky="ewns")
        self.logoStuff(self.content, logo_size)
        self.addButtons(self.content, 1)
    
    def logoStuff(self, root, logo_size:int):
        self.logo_frame = ttk.Frame(root, width=self.height, height=self.height)
        self.logo_frame.grid(row=0, column=0, rowspan=3, sticky="ew")
        self.logo = ACTLogo(logo_size, self.logo_frame)
        self.logo.set_grid()
        self.logo.set_icon(self.root)
        label = tk.Label(self.logo_frame, text="Alexandria Chemistry\nToolkit",
                         justify='center', relief='solid', borderwidth=0,
                         font=labelFont(), fg="blue", cursor="hand2")
        label.grid(row=1, column=0, sticky="ew")
        label.bind("<Button-1>", lambda e: callback("http://github.com/AlexandriaChemistry"))
        lab2 = tk.Label(self.logo_frame, text="(c) 2025 David van der Spoel",
                         justify='center', relief='solid', borderwidth=0)
        lab2.grid(row=2, column=0, sticky="ew")
    
    def run(self):
        # layout all of the main containers
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0, weight=1)
        for c in range(2):
            self.content.grid_columnconfigure(c, weight=1)
        
        for r in range(2):
            self.logo_frame.grid_rowconfigure(r, weight=1)
        for r in range(len(self.mybuttons)):
            self.bframe.grid_rowconfigure(r, weight=1)
        self.root.mainloop()

    def genff(self):
        ffgen = FFGenerator(self.root)
        ffgen.run()

    def geometry(self):
        geomff = GeometryFF(self.root)
        geomff.run()

    def help(self):
        helpstr = ("This is a simple frontend to some the commands available in the Alexandria Chemistry Toolkit.\n\nYou can generate a force field template, pressing the button will pop-up another window where you can make selections of atom types, potentials and some algorithmic options.\n\nThen you can add parameters for bonded functions if you provide a molecule property (molprop) file that will be analysed for bond-lengths, angles, etc. after which the information will be added to your force field file.")
        show_info(helpstr)

    def stop(self):
        self.root.quit()

    def addButtons(self, parent, mycol:int):
        bwidth = int(self.width/2) - self.pad
        self.bframe = ttk.Frame(parent, width=bwidth,
                                height=bwidth, border=0, relief=tk.SOLID)
        self.bframe.grid(row=0, column=mycol, rowspan=3, sticky="wens")
        myrow = 0
        bdict = { "Generate force field": self.genff,
                  "Add bonded parameters": self.geometry,
                  "Help": self.help,
                  "Quit": self.stop }
        deft      = "normal"
        self.mybuttons = []
        for bd in bdict:
            mybut = ttk.Button(self.bframe, text=bd, default=deft, command=bdict[bd])
            mybut.grid(row=myrow, column=mycol, sticky="ew", padx=self.pad, pady=self.pad)
            self.mybuttons.append(mybut)
            deft   = "normal"
            myrow += 1

class CombRule:
    def __init__(self, root):
        self.parent = root
        self.width = 300
        self.height= 200
        self.root = tk.Toplevel(root)
        self.root.geometry(f"{self.width}x{self.height}")
        self.root.title("Combination Rule Selector")
        self.all_rules = [ "Geometric", "Arithmetic", "Volumetric",
                           "InverseSquare", "Kronecker",
                           "HogervorstEpsilon", "HogervorstSigma", 
                           "WaldmanSigma", "WaldmanEpsilon",
                           "HalgrenEpsilon", "QiSigma", "QiEpsilon",
                           "Yang", "MasonGamma" ]
        self.crules = None
        self.ready = False

    def run(self, potential:str):
        all_params = { "WANG_BUCKINGHAM": { "sigma", "epsilon", "gamma" },
                       "LJ14_7": { "sigma", "epsilon", "gamma", "delta" },
                       "LJ12_6": { "sigma", "epsilon" },
                       "LJ8_6": { "sigma", "epsilon" },
                       "GENERALIZED_BUCKINGHAM": { "rmin", "epsilon", "gamma", "delta" },
                       "MORSE_BONDS": { "bondlength", "De", "beta" }
                      }
        if potential not in all_params:
            show_info(f"Potential {potential} is not supported yet for manual selection of combination rules. Defaults will be used.")
            #self.done()
            return
        myparam = all_params[potential]
        self.content = ttk.Frame(self.root)
        self.content.grid(row=0, column=0, columnspan=2, rowspan=len(myparam)+2)
        self.content.grid_rowconfigure(1, weight=1)
        self.content.grid_columnconfigure(1, weight=1)
        lab = ttk.Label(self.content, text=f"Parameters for {potential}")
        lab.grid(row=0, column=0, columnspan=2)
        self.crules = {}
        myrow = 1
        for p in myparam:
            self.crules[p] = tk.StringVar(self.content, self.all_rules[0])
            lab = ttk.Label(self.content, text=p)
            lab.grid(row=myrow, column=0, sticky="wns")
            menu = ttk.OptionMenu(self.content, self.crules[p], *self.all_rules)
            menu.grid(row=myrow, column=1, sticky="news")
            myrow += 1
        hh = ttk.Button(self.content, text="Help", command=self.help)
        hh.grid(column=0, row=myrow, sticky="nwes")
        bb = ttk.Button(self.content, text="OK", command=self.done)
        bb.grid(column=1, row=myrow, sticky="nwes")
        myrow += 1
        while not self.ready:
            self.parent.update()
            time.sleep(0.1)

    def help(self):
        helpstr = "Choose the combination rule for each parameter in the potential of your choice. Please be aware that combination rules represent an approximation of the potential between atoms. The choice of rules has a large impact on the accuracy of your model. For more detailed information, please refer to Kriz et al. J. Chem. Theory Comput. 20 (2024) 2362."
        show_info(helpstr)

    def done(self):
        self.root.destroy()
        self.ready = True

    def rules(self)->dict:
        myrules = {}
        for c in self.crules:
            myrules[c] = self.crules[c].get()
        return myrules

class FFGenerator:
    def __init__(self, root):
        self.width = 900
        self.height= 800
        self.root = tk.Toplevel(root)
        self.root.geometry(f"{self.width}x{self.height}")
        self.root.title("ACT - Force Field Generator")
#        self.root.configure()

    def rootW(self):
        return self.root

    def doGenFF(self):
        if self.verbose.get():
            self.print()
        # Get file name
        file_path = saveasfile("Force Field filename to save", ".xml")
        if file_path:
            comb_rules = CombRule(self.root)
            comb_rules.run(self.vdwSel.potential())
            print(f"Here are the combination rules you selected {comb_rules.rules()}")
            status = self.runACT(file_path, comb_rules.rules())
            if status == 0:
                msg = ("Succesfully generated a force field in %s" % file_path)
                show_info(msg)
            else:
                show_info("Force field generation failed")
            self.root.destroy()

    def top(self):
        logo_size = 150
        self.logo_frame = tk.Frame(self.root, width=logo_size,
                                   height=logo_size, pady=3)
        actlogo = library_file("ACTlogo2.png")
        if actlogo:
            self.logo     = ImageTk.PhotoImage(Image.open(actlogo))
            self.root.tk.call('wm', 'iconphoto', self.root._w, self.logo)
            mylogo        = tk.Label(self.logo_frame, image=self.logo, width = logo_size, height = logo_size).grid(row=0, column=0, sticky=tk.N+tk.S+tk.W+tk.E)
        else:
            # TODO: build in alternative if the logo image is not present
            sys.exit("Cannot find %s" % actlogo)
        self.atom_frame = tk.Frame(self.root, width=self.width-logo_size,
                                   height=logo_size, pady=3, padx=3, bd=1, relief=tk.SOLID)
        self.atoms    = AtomTypes(self.atom_frame, myrow=0, mycol=0)

    def makePots(self):
        self.mid_frame = tk.Frame(self.root, width=self.width,
                                  height=500, pady=3, bd=1, relief=tk.SOLID)
        self.vdwSel   = VdwSel(self.mid_frame, myrow=0, mycol=0)
        self.qSel     = QSel(self.mid_frame, myrow=0, mycol=1)
        self.bondSel  = BondSel(self.mid_frame, myrow=0, mycol=2)
        self.angleSel = AngleSel(self.mid_frame, myrow=self.bondSel.nrows(), mycol=2)
        self.dihSel   = DihSel(self.mid_frame, myrow=self.bondSel.nrows()+self.angleSel.nrows(), mycol=2)
        self.icSel    = ICSel(self.mid_frame, myrow=self.qSel.nrows(), mycol=1)

    def makeButtons(self):
        self.bot_frame = tk.Frame(self.root, width=self.width, height=60, pady=3, bd=1, relief=tk.SOLID)
        bwidth = int(self.width/4)
        self.saveIntermediates = tk.IntVar()
        self.saveIntermediates.set(1)
        item = tk.Checkbutton(self.bot_frame, width=bwidth, text="Save intermediate files", command=None,
                              variable=self.saveIntermediates).grid(row=0, column=0, sticky=tk.N+tk.S+tk.W)
        self.verbose = tk.IntVar()
        self.verbose.set(0)
        item = tk.Checkbutton(self.bot_frame, width=bwidth,  text="Verbose mode", command=None,
                              variable=self.verbose).grid(row=0, column=1, sticky=tk.N+tk.S+tk.W)
        tk.Button(self.bot_frame,  width=bwidth, text="Run", default="active", command=self.doGenFF).grid(row=0, column=2, sticky=tk.W)
        tk.Button(self.bot_frame,  width=bwidth, text="Cancel", default="normal", command=self.close).grid(row=0, column=3, sticky=tk.E)

    def close(self):
        self.root.destroy()

    def run(self):
        # Build the elements of the window
        self.top()
        self.makePots()
        self.makeButtons()
        # layout all of the main containers
        self.root.grid_rowconfigure(1, weight=1)
        self.root.grid_columnconfigure(1, weight=1)
        # create top widgets
        self.logo_frame.grid(row=0, column=0, sticky="ewn")
        self.atom_frame.grid(row=0, column=1, sticky="ewn")
        # create the center widgets
        self.mid_frame.grid_rowconfigure(0, weight=1)
        for c in range(3):
            self.mid_frame.grid_columnconfigure(c, weight=1)
        self.mid_frame.grid(row=1, columnspan=3, sticky="ew")
        # create the bottom widgets
        self.bot_frame.grid_rowconfigure(1, weight=1)
        for c in range(4):
            self.bot_frame.grid_columnconfigure(c, weight=1)
        self.bot_frame.grid(row=2, columnspan=4, sticky="ews")

    def print(self):
        print(f"VDW potential selected: {self.vdwSel.potential()}")
        vdwPart = self.vdwSel.vdwParticles()
        for ptype in vdwPart.keys():
            print(f"VDW on {ptype}: {vdwPart[ptype]}")
        print(f"Use exchange correction: {self.vdwSel.exchCorr()}")
        print(f"Charge model selected: {self.qSel.qModel()}")
        print(f"Polarizable: {self.qSel.polarizable()}")
        print(f"Bond potential selected: {self.bondSel.potential()}")
        print(f"Angle potential selected: {self.angleSel.potential()}")
        print(f"Dihedral potential selected: {self.dihSel.potential()}")
        print(f"Induction correction potential selected: {self.icSel.potential()}")
        print(f"Selection of atomtypes {self.atoms.getAtypes()}")

    def generateCSV(self)->bool:
        self.csv_file = None
        if self.saveIntermediates.get():
            # Let user decide what file to save atomtypes in
            self.csv_file = saveasfile("File to save atomtypes", ".csv")
            if self.csv_file:
                self.tf = open(self.csv_file, "w")
        else:
            # Open a temporary file
            self.tf = tempfile.NamedTemporaryFile(suffix=".csv", mode='w')
            self.csv_file = self.tf.name
        if not self.csv_file or len(self.csv_file) == 0:
            print("No correct csv file name received or temp file opening failed.")
            return False

        # Do we need to generate vsite1 definitions
        self.vs1_file = None
        qdist         = self.qSel.qModel()
        if qdist == PG:
            # Yes!
            if self.saveIntermediates.get():
                # Let user decide what file to save atomtypes in
                self.vs1_file = saveasfile("File to save vsite definitions", ".csv")
                if self.vs1_file:
                    self.vs1f = open(self.vs1_file, "w")
                else:
                    return False
            else:
                # Open a temporary file
                self.vs1f = tempfile.NamedTemporaryFile(suffix=".csv", mode='w')
                self.vs1_file = self.vs1f.name
                if not self.vs1_file:
                    return False

        self.tf.write("#atomtype|element|q_min|q_max|charge_mutability|bondtype|poltype|zetatype|acmtype|epsilon_min|epsilon_max|epsilon_mutability|gamma_min|gamma_max|gamma_mutability|sigma_min|sigma_max|sigma_mutability|delta_min|delta_max|delta_mutability|radius|row|alpha_min|alpha_max|alpha_mutability|zeta_min|zeta_max|zeta_mutability|eta_min|eta_max|eta_mutability|chi_min|chi_max|chi_mutability|aexp_min|aexp_max|aexp_mutability|bexp_min|bexp_max|bexp_mutability|a1dexp_min|a1dexp_max|a1dexp_mutability|a2dexp_min|a2dexp_max|a2dexp_mutability|bdexp_min|bdexp_max|bdexp_mutability|comment|reference\n")
        # Fetch the atom types selected by the user
        atype_props = self.atoms.getAtypes()
        if len(atype_props) == 0:
            show_info("No atom types selected!")
            return False
        # Set some shortcuts
        Bounded     = "Bounded"
        Fixed       = "Fixed"
        vdwPart     = self.vdwSel.vdwParticles()
        polarizable = self.qSel.polarizable()
        # Defaults for potentials
        for atp in atype_props:
            if atype_props[atp]["Default"] > 0:
                for vdwtp in vdwPart:
                    if vdwtp == Shell and not polarizable:
                        continue
                    if vdwtp == VSite and not qdist == PG:
                        continue
                    btype = ""
                    if atype_props[atp]["Bonds"] > 0 and vdwtp == Atom:
                        btype = atp + "_b"
                    atype_name = atp
                    if vdwtp == Shell:
                        atype_name = atp + "_s"
                    elif vdwtp == VSite:
                        atype_name = "v1" + atp
                        self.vs1f.write(f"{atype_name}|VSITE1|{atp}_b|0|1||||\n")
                    stype = ""
                    alpha = { "min": 0, "max": 0, "mut": Fixed }
                    if polarizable:
                        if vdwtp == Atom:
                            stype = atp + "_s"
                        elif vdwtp == Shell:
                            alpha["max"] = 12
                            alpha["mut"] = Bounded
                    ztype   = atype_name + "_z"
                    acmtype = ""
                    if vdwtp == Atom:
                        acmtype = ztype
                    # Determine whether to use VDW
                    bounds = { "sig_min": 0, "sig_max": 0,
                               "eps_min": 0, "eps_max": 0,
                               "gam_min":0, "gam_max": 0,
                               "del_min": 0, "del_max": 0 }
                    vdw_mut = Fixed
                    if vdwPart[vdwtp]:
                        bounds = self.vdwSel.bounds()
                        vdw_mut = Bounded
                    zeta = { 'min': 0, "max": 0, "mut": Fixed }
                    if qdist != Point:
                        if (qdist == PG and vdwtp != Atom) or qdist in [ Gaussian, Slater ]:
                            zeta = { "min": 4, "max": 20, "mut": Bounded }
                    aexp = { "min": 0, "max": 0 }
                    vdwcorr_mut = Fixed
                    bexp = { "min": 10, "max": 50 }
                    if self.vdwSel.exchCorr() and vdwtp == Atom:
                        aexp["max"] = 50000
                        vdwcorr_mut = Bounded
                    radius     = ""
                    row        = 0
                    element    = "X"
                    eta = { "min": "", "max": "", "mut": "" }
                    chi = { "min": "", "max": "", "mut": "" }
                    if vdwtp == Atom:
                        radius  = str(atype_props[atp]['Radius'])
                        row     = atype_props[atp]['Row']
                        element = atype_props[atp]['Element']
                        eta     = { "min": "4", "max": "20", "mut": Bounded }
                        chi     = { "min": "4", "max": "12", "mut": Bounded }
                    a1dexp = { "min": 0, "max": 0 }
                    MS_mut = Fixed
                    a2dexp = { "min": 0, "max": 0 }
                    bdexp  = { "min": 10, "max": 50 }
                    comment    = ""
                    if vdwtp == Atom:
                        comment = atype_props[atp]['Comment']
                    reference  = ""
                    self.tf.write(f"{atype_name}|{element}|0|0|Bounded|{btype}|" +
                                  f"{stype}|{ztype}|{acmtype}|" +
                                  f"{bounds['eps_min']}|{bounds['eps_max']}|{vdw_mut}|" +
                                  f"{bounds['gam_min']}|{bounds['gam_max']}|{vdw_mut}|" +
                                  f"{bounds['sig_min']}|{bounds['sig_max']}|{vdw_mut}|" +
                                  f"{bounds['del_min']}|{bounds['del_max']}|{vdw_mut}|" +
                                  f"{radius}|" +
                                  f"{row}|" +
                                  f"{alpha['min']}|{alpha['max']}|{alpha['mut']}|" +
                                  f"{zeta['min']}|{zeta['max']}|{zeta['mut']}|"
                                  f"{eta['min']}|{eta['max']}|{eta['mut']}|" +
                                  f"{chi['min']}|{chi['max']}|{chi['mut']}|" +
                                  f"{aexp['min']}|{aexp['max']}|{vdwcorr_mut}|" +
                                  f"{bexp['min']}|{bexp['max']}|{vdwcorr_mut}|" +
                                  f"{a1dexp['min']}|{a1dexp['max']}|{MS_mut}|" +
                                  f"{a2dexp['min']}|{a2dexp['max']}|{MS_mut}|" +
                                  f"{bdexp['min']}|{bdexp['max']}|{MS_mut}|" +
                                  f"{comment}|{reference}|\n")

        if self.verbose.get():
            print("Generated file %s" % self.csv_file)
        return True

    def closeCSV(self):
        # Close atomtypes file
        self.tf.close()
        # Close vsite1 only when needed
        if self.vs1_file:
            self.vs1f.close()

    def runACT(self, file_path:str, comb_rules:dict)->int:
        epsr  = self.qSel.epsilonR()
        nexcl = self.vdwSel.nExcl()
        qsymm = " -noqsymm "
        # status = 0 corresponds to everything was fine under Linux / MacOS.
        status = 1
        if self.qSel.symm():
            qsymm = " -qsymm "
        if self.generateCSV():
            # Workaround since alexandria gen_ff does not yet know about the P+G charge distribution
            qdist = self.qSel.qModel()
            if qdist == PG:
                qdist = Gaussian
            cmd = f"alexandria gen_ff -f {self.csv_file} -nexclqq {nexcl} -nexclvdw {nexcl} -epsilonr {epsr} -vdwfn {self.vdwSel.potential()} -qdist {qdist} {qsymm} -anglefn {self.angleSel.potential()} -dihfn {self.dihSel.potential()} -o {file_path}"
            if self.vs1_file:
                cmd += f" -vs {self.vs1_file} "
            icpot = self.icSel.potential()
            if icpot != "NONE":
                cmd += f" -icfn {icpot} "
            if self.vdwSel.exchCorr():
                cmd += " -vdwcorr "
            if len(comb_rules.keys()) > 0:
                for cr in comb_rules:
                    cmd += f" -cr_{cr[:3]} {comb_rules[cr]} "
            if self.verbose:
                print(f"Command line: {cmd}")
            status = os.system(cmd)
            self.closeCSV()
        return status
    
if __name__ == "__main__":
    manager = Manager()
    manager.run()
