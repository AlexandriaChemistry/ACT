#!/usr/bin/env python3

# This script is part of the Alexandria Chemistry Toolkit
# https://github.com/AlexandriaChemistry/ACT
# Author: David van der Spoel
# Copyright 2025
# License is GPL v. 2

import copy, os, sys, tempfile, webbrowser, time
import tkinter as tk
import tkinter.font as tkFont
from tkinter import filedialog
from tkinter import messagebox
from tkinter import ttk
from PIL import ImageTk, Image

# Some global variables
Atom     = "Atom"
VSite    = "VSite"
Shell    = "Shell"
Point    = "POINT"
Gaussian = "GAUSSIAN"
Slater   = "SLATER"
PG       = "P+G"
Bounded  = "Bounded"
Fixed    = "Fixed"
coul     = "COULOMB"
defnm    = "DefaultName"
comment  = "Comment"
geom     = "Geometric"
arith    = "Arithmetic"
pad1     = 5
mypad    = ( pad1, pad1, pad1, pad1 )

def labelFont(size:int=20):
    return ('Helvetica', size, 'bold')

def library_file(filenm:str)->str:
    if os.path.exists(filenm):
        return filenm
    actdata = "ACTDATA"
    if actdata in os.environ:
        filenm2 = ( "%s/%s" % ( os.environ[actdata], filenm ))
    if os.path.exists(filenm2):
        return filenm2
    print("Cannot find file '%s'" % filenm)
    return None
    
def saveasfile(mytitle:str, defext:str)->str:
    # Get file name
    # Loop to make sure we get a file name with the correct extension
    ext    = ""
    file_path = True
    while file_path and not ext == defext:
        file_path = filedialog.asksaveasfilename(title=mytitle, defaultextension=defext)
        if file_path:
            _,ext = os.path.splitext(file_path)
        else:
            return None
    return file_path

def openasfile(mytitle:str, defext:str)->str:
    # Get file name
    # Loop to make sure we get a file name with the correct extension
    ext    = ""
    file_path = True
    while file_path and not ext == defext:
        file_path = filedialog.askopenfilename(title=mytitle, defaultextension=defext)
        if file_path:
            _,ext = os.path.splitext(file_path)
        else:
            return None
    return file_path

def show_info(msg:str):
    messagebox.showinfo("ACT GUI", msg)


# Code for ToolTips taken from
# https://stackoverflow.com/questions/3221956/how-do-i-display-tooltips-in-tkinter
class CreateToolTip(object):
    """
    create a tooltip for a given widget
    """
    def __init__(self, widget, text='widget info'):
        self.waittime = 500     #miliseconds
        self.wraplength = 180   #pixels
        self.widget = widget
        self.text = text
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<ButtonPress>", self.leave)
        self.id = None
        self.tw = None

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.widget.after(self.waittime, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.widget.after_cancel(id)

    def showtip(self, event=None):
        x = y = 0
        x, y, cx, cy = self.widget.bbox("insert")
        x += self.widget.winfo_rootx() + 25
        y += self.widget.winfo_rooty() + 20
        # creates a toplevel window
        self.tw = tk.Toplevel(self.widget)
        # Leaves only the label and removes the app window
        self.tw.wm_overrideredirect(True)
        self.tw.wm_geometry("+%d+%d" % (x, y))
        label = tk.Label(self.tw, text=self.text, justify='left',
                         background="#ffffff", relief='solid', borderwidth=1,
                         wraplength = self.wraplength)
        label.pack(ipadx=1)

    def hidetip(self):
        tw = self.tw
        self.tw= None
        if tw:
            tw.destroy()

class VdwSel:
    def __init__(self, frame, myrow:int, mycol:int):
        self.vdws = {
            "SLATER_ISA_TT": 
            { "A": ( 0, 100000, "kJ/mol" ),
              "bDisp": ( 5, 50, "1/nm" ),
              "bExch": ( 5, 50, "1/nm" ),
              "c6": ( 0, 0.005, "kJ/mol nm6" ), 
              "c8": ( 0, 0.002, "kJ/mol nm8" ),
              "c10": ( 0, 0.001, "kJ/mol nm10" ),
              comment: "Slater-ISA repulsion with Tang-Toennies dispersion\nVan Vleet et al. J. Chem. Theory. Comput. 12 (2016) 3851-3870 and Sheng et al. Phys. Rev. Lett. 125 (2020) 2534 " },
            "TT2b": 
            { "Att2b": ( 0, 100000, "kJ/mol" ),
              "bDisptt2b": ( 5, 50, "1/nm" ),
              "bExchtt2b": ( 5, 50, "1/nm" ),
              "c6tt2b": ( 0, 0.005, "kJ/mol nm6" ), 
              "c8tt2b": ( 0, 0.002, "kJ/mol nm8" ),
              "c10tt2b": ( 0, 0.001, "kJ/mol nm10" ),
              comment: "Tang-Toennies with separate b\nSheng et al. Phys. Rev. Lett. 125 (2020) 2534 " },
            "WANG_BUCKINGHAM":
            { "sigma": ( 0, 1, "nm"),
              "epsilon": ( 0, 5, "kJ/mol" ),
              "gamma": ( 1, 25, "" ),
              comment: "Buckingham variant without singularity at r=0\nWang et al. J. Chem. Theory Comput. 9 (2013) 452" },
            "LJ14_7":
            { "sigma": ( 0, 1, "nm"),
              "epsilon": ( 0, 5, "kJ/mol" ),
              "gamma": ( 0, 0.8, "" ),
              "delta": ( 0, 2, "" ),
              comment: "Buffered 14-7 potential\nHalgren, J. Amer. Chem. Soc. 114 (1992) 7827" }, 
            "LJ12_6":
            { "sigma": ( 0, 1, "nm"),
              "epsilon": ( 0, 5, "kJ/mol" ),
              comment: "Lennard-Jones potential\nJones, Proc. Royal Soc. A 106 (1924) 463" },
            "GENERALIZED_BUCKINGHAM":
            { "rmin": ( 0, 1, "nm"),
              "epsilon": ( 0, 5, "kJ/mol" ),
              "gamma": ( 1, 25, ""),
              "delta": ( 3, 12, "" ),
              comment: "Generalized Buckingham\nWerhahn et al. Chem. Phys. Lett. 619 (2015) 133" },
        }
        self.vdwPot = tk.StringVar(frame, "WANG_BUCKINGHAM")
        labPot = tk.Label(frame, text=f"Van der Waals potential",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        myrow += 1
        for vdw in self.vdws.keys():
            item = tk.Radiobutton(frame, text=vdw, variable=self.vdwPot,
                                  value=vdw, command=None)
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            tpp = CreateToolTip(item, self.vdws[vdw][comment])
            myrow += 1

        labParticle = tk.Label(frame, text=f"Use VdW on", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        self.vdwPart = {}
        ptypes = { Atom: 1, VSite: 0, Shell: 0 }
        for ptype in ptypes.keys():
            self.vdwPart[ptype] = tk.IntVar()
            self.vdwPart[ptype].set(ptypes[ptype])
            item = tk.Checkbutton(frame, text=ptype, command=None,
                                  variable=self.vdwPart[ptype])
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

        labPot = tk.Label(frame, text=f"Number of exclusions",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        myrow += 1
        
        self.nexcl = tk.IntVar()
        self.nexcl.set(2)
        excl = [ 1, 2 ]
        for ie in excl:
            item = tk.Radiobutton(frame, text=str(ie), variable=self.nexcl,
                                  value=ie, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

        self.myrow = myrow

    def potential(self)->str:
        return self.vdwPot.get()

    def nExcl(self)->int:
        return self.nexcl.get()

    def vdwParticles(self)->dict:
        vdwP = {}
        for vdw in self.vdwPart.keys():
            vdwP[vdw] = self.vdwPart[vdw].get()
        return vdwP

    def nrows(self)->int:
        return self.myrow
        
    def bounds(self)->dict:
        return self.vdws[self.potential()]

class QSel:
    def __init__(self, root, myrow:int, mycol:int):
        gharemanpour2018b = "Distributed charges\nGhahremanpour et al., J. Chem. Theory Comput. 14 (2018) 5553"
        self.qs = { Point: "Point charges", 
                    Gaussian: gharemanpour2018b, 
                    Slater: gharemanpour2018b,
                    PG: "Point+Gaussian charges\nVan der Spoel & Hosseini, Phys. Chem. Chem. Phys. 27 (2025) 13817" }
        self.qmodel = tk.StringVar(root, Gaussian)
        labPot = tk.Label(root, text=f"Charge model",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        for q in self.qs.keys():
            item = tk.Radiobutton(root, text=q, variable=self.qmodel, value=q, command=None)
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            ttp = CreateToolTip(item, self.qs[q])
            myrow += 1

        # Epsilon R
        labPot = tk.Label(root, text=f"Relative dielectric constant",
                          anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        self.epsr = tk.StringVar()
        self.epsr.set("1")
        item = tk.Entry(root, textvariable=self.epsr).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        labParticle = tk.Label(root, text=f"Options", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        # Charge symmetrization for CH3 groups etc. 
        self.qsymm = tk.IntVar()
        self.qsymm.set(1)
        item = tk.Checkbutton(root, text="Enforce charge symmetry", command=None,
                              variable=self.qsymm).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1
        
        self.myrow = myrow

    def symm(self):
        return self.qsymm.get()

    def qModel(self):
        return self.qmodel.get()

    def nrows(self)->int:
        return self.myrow

    def epsilonR(self)->float:
        try:
            eee = float(self.epsr.get())
            return eee
        except ValueError:
            print("Value entered for dielectric constant incomprehensible, using 1")
            return 1

class BondSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.bonds = ["BONDS", "CUBIC", "HUA", "MORSE" ]
        self.bondPot = tk.StringVar(root, f"{self.bonds[2]}")
        labPot = tk.Label(root, text=f"Bond potential", anchor="w", font=labelFont())
        labPot.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        tpp = CreateToolTip(labPot, "Van Maaren & Van der Spoel\nDigit. Discov. 4 (2025) 824")
        myrow += 1

        for bond in self.bonds:
            item = tk.Radiobutton(root, text=bond, variable=self.bondPot,
                                  value=bond, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

    def potential(self):
        return self.bondPot.get()

    def nrows(self)->int:
        return len(self.bonds)+1

class AngleSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.angles = ["ANGLES", "UREY_BRADLEY" ]
        self.anglePot = tk.StringVar(root, f"{self.angles[0]}")
        labPot = tk.Label(root, text=f"Angle potential", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        for angle in self.angles:
            item = tk.Radiobutton(root, text=angle, variable=self.anglePot,
                                  value=angle, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

    def potential(self):
        return self.anglePot.get()

    def nrows(self)->int:
        return len(self.angles)+1

class DihSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.dihs = ["PDIHS", "FOURDIHS" ]
        self.dihPot = tk.StringVar(root, f"{self.dihs[1]}")
        labPot = tk.Label(root, text=f"Dihedral potential", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
        myrow += 1

        for dih in self.dihs:
            item = tk.Radiobutton(root, text=dih, variable=self.dihPot,
                                  value=dih, command=None).grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W)
            myrow += 1

    def potential(self):
        return self.dihPot.get()

    def nrows(self)->int:
        return len(self.dihs)+1

class ICSel:
    def __init__(self, root, myrow:int, mycol:int):
        self.ics = { 
            "NONE": {
                comment: "No corrections" },
            "MACDANIEL_SCHMIDT": {
                "a1dexp": ( 0, 100000, "kJ/mol"),
                "a2dexp": ( 0, 100000, "kJ/mol"),
                "bdexp": ( 5, 50, "1/nm" ),
                comment: "Negative exponential correction\nMcDaniel & Schmidt, J. Phys. Chem. 117 (2013) 2053" },
            "MORSE_BONDS": {
                "D0": ( 0, 0, "kJ/mol"),
                "De": ( 0, 800, "kJ/mol" ),
                "bondlength": ( 0, 0.5, "nm" ),
                "beta": ( 5, 50, "1/nm" ),
                comment: "Correction with repulsive and attractive part\nHosseini & Van der Spoel, in preparation" }
        }
        self.icPot = tk.StringVar(root, "NONE")
        labPot = tk.Label(root, text=f"Induction correction potential", anchor="w", font=labelFont()).grid(row=myrow, column=mycol, sticky="nsw")
        myrow += 1

        for ic in self.ics.keys():
            if ic == "NONE":
                mycmd = self.disable
            else:
                mycmd = self.enable
            item = tk.Radiobutton(root, text=ic, variable=self.icPot,
                                  value=ic, command=mycmd)
            item.grid(row=myrow, column=mycol, sticky="nsw")
            ttp = CreateToolTip(item, self.ics[ic][comment])
            myrow += 1
        labParticle = tk.Label(root, text=f"Use induction correction on", anchor="w", font=labelFont())
        labParticle.grid(row=myrow, column=mycol, sticky="nsw")
        myrow += 1
        self.icPart = {}
        ptypes = { Atom: 1, Shell: 0 }
        self.cb = {}
        for ptype in ptypes.keys():
            self.icPart[ptype] = tk.IntVar()
            self.icPart[ptype].set(ptypes[ptype])
            self.cb[ptype] = tk.Checkbutton(root, text=ptype, command=None, state=tk.DISABLED,
                                            variable=self.icPart[ptype])
            self.cb[ptype].grid(row=myrow, column=mycol, sticky="nsw")
            myrow += 1

    def disable(self):
        self.cb[Atom]['state'] = tk.DISABLED
        self.cb[Shell]['state'] = tk.DISABLED
        
    def enable(self):
        self.cb[Atom]['state'] = tk.NORMAL
        self.cb[Shell]['state'] = tk.NORMAL

    def bounds(self):
        return self.ics[self.potential()]

    def icParticles(self):
        icp = {}
        for pt in self.icPart:
            icp[pt] = self.icPart[pt].get()
        return icp

    def potential(self):
        return self.icPot.get()

    def nrows(self)->int:
        return len(self.ics)+1

class FFOptions:
    def __init__(self):
        self.shole = '\u03C3-holes'
        self.vsinfo = {
            self.shole+" on halogen atoms": "vsite2_halogen_sigma_holes.csv",
            self.shole+" on water": "vsite2_water_sigma_holes.csv",
            "Site on water bisector": "vsite3_water_bisector.csv",
            "Site on alcohol COH bisector": "vsite3_alcohol_bisector.csv",
            "Lone pairs on water": "vsite3_water_lone_pairs.csv",
            "Lone pairs on alcohol oxygen": "vsite3_alcohol_lone_pairs.csv"
        }
        self.user_vs     = []
        self.user_params = []
    
    def select(self, root):
        self.parent = root
        self.root   = tk.Toplevel(self.parent)
        self.root.title("Force field options")
        content = ttk.Frame(self.root, padding=mypad)
        nrows = 1 + len(self.vsinfo) + 1
        ncolumns = 2
        content.grid(rowspan=nrows, columnspan=ncolumns, sticky="news")
        mylab = ttk.Label(content, text="Select virtual sites", anchor="w", font=labelFont())
        myrow = 0
        mylab.grid(row=myrow, column=0, sticky="nws")
        myrow += 1
        self.vsite_sel = {}
        for vs in self.vsinfo:
            self.vsite_sel[vs] = tk.IntVar()
            cb = ttk.Checkbutton(content, text=vs, command=None,
                                 variable=self.vsite_sel[vs])
            cb.grid(row=myrow, column=0, sticky="nws")
            myrow += 1
        
        but = ttk.Button(content, text="OK", command=self.done)
        but.grid(row=myrow, column=0, sticky="news")
        but = ttk.Button(content, text="Help", command=self.help)
        but.grid(row=myrow, column=1, sticky="news")
        # Second column
        myrow = 0
        mylab = ttk.Label(content, text="Vsite options", anchor="w", font=labelFont())
        mylab.grid(row=myrow, column=1, sticky="nws")
        myrow += 1
        self.exchcorr = tk.IntVar()
        item = tk.Checkbutton(content, text="Exchange correction on "+self.shole, command=None,
                              variable=self.exchcorr)
        item.grid(row=myrow, column=1, sticky="nsw")
        ttp = CreateToolTip(item, "For sigma-holes\nKriz & Van der Spoel, J. Phys. Chem. Lett. 15 (2024) 9974, https://doi.org/10.1021/acs.jpclett.4c02034")
        myrow += 1
        mylab = ttk.Label(content, text="User files", anchor="w", font=labelFont())
        mylab.grid(row=myrow, column=1, sticky="nws")
        myrow += 1
        but1 = ttk.Button(content, text="Virtual sites", command=self.addUserVsites)
        but1.grid(row=myrow, column=1, sticky="news")
        myrow += 1
        ttp1 = CreateToolTip(but1, "Add your own definitions of virtual sites, see ACT manual for details.") 
        but2 = ttk.Button(content, text="Parameters", command=self.addUserParams)
        but2.grid(row=myrow, column=1, sticky="news")
        myrow += 1
        ttp2 = CreateToolTip(but2, "Add your own parameters for selected particles, see ACT manual for details.") 
        for r in range(nrows):
            content.grid_rowconfigure(r, weight=1)
        for c in range(ncolumns):
            content.grid_columnconfigure(c, weight=1)
        self.ready = False
        while not self.ready:
            time.sleep(0.1)
            self.parent.update()

    def done(self):
        self.ready=True
        self.root.destroy()

    def help(self):
        helpstr = f"Virtual sites can be used to make your force field more realistic by spreading charges and other interactions such as exchange over multiple sites. In this manner better correlation with quantum chemistry results can be obtained. You can select some of the predefined virtual site definitions or prepare your own file. See ACT manual for details.\n\nYou can also add a file specifying particular values for parameters that you want to be fixed during training, for instance when you have additional data from experiments or quantum chemistry. See ACT manual for specification of the parameter files.\n\nNote that you can add multiple vsite files and multiple parameter files.\n\nFor more information on handling {self.shole} see Kriz & Van der Spoel, J. Phys. Chem. Lett. 15 (2024) 9974, https://doi.org/10.1021/acs.jpclett.4c02034"
        show_info(helpstr)

    def addUserVsites(self):
        newfn = openasfile("Virtual site definitions", ".csv")
        if newfn:
            self.user_vs.append(newfn)
        
    def addUserParams(self):
        newfn = openasfile("Parameter definitions", ".csv")
        if newfn:
            self.user_params.append(newfn)

    def getParams(self)->dict:
        mydict = {}
        for fn in self.user_params:
            with open(fn, "r") as inf:
                for line in inf:
                    if line.startswith("#"):
                        continue
                    words = line.strip().split("|")
                    if len(words) == 6:
                        interaction = words[0]
                        if not interaction in mydict:
                            mydict[interaction] = {}
                        atp = words[2]
                        param = words[3]
                        if atp in mydict[interaction] and mydict[interaction][atp]["param"] == param:
                            sys.exit("Atomtype '%s' with parameter '%s' is defined multiple times in user specified parameter files for interaction '%s'" % ( atp, param, inter ))
                        mydict[interaction][atp] = { "potential": words[1], "parameter": param,
                                                     "value": float(words[4]), "unit": words[5] }
        return mydict

    def getVsites(self):
        vsites    = []
        atomtypes = {}
        def read_vs(filenm:str):
            if not os.path.exists(filenm):
                print("File %s does not exist, ignoring it." % filenm)
                return
            with open(filenm, "r") as inf:
                for line in inf:
                    if not line.startswith("#"):
                        www = line.strip().split("|")
                        if len(www) > 7:
                            vsites.append(line.strip())
                            exchcorr = False
                            if self.exchcorr.get() and "sigma" in filenm:
                                exchcorr = True
                            atomtypes[www[0]] = { "exchcorr": exchcorr }
                if len(vsites) == 0:
                    show_info(f"No vsites in {filenm}\nCheck formatting")
            
        for vs in self.vsinfo:
            if self.vsite_sel[vs].get():
                vsfn = library_file(self.vsinfo[vs])
                read_vs(vsfn)
        for vs in self.user_vs:
            read_vs(vs)

        return atomtypes, vsites
        
class AtomTypes:
    def __init__(self, frame, myrow, mycol):
        atguifn = "atomtypes_gui.csv"
        atype_gui = library_file(atguifn)
        if not atype_gui:
            sys.exit("Cannot find atom type definitions file '%s'" % atguifn)
        self.atype_props = {}
        with open(atype_gui, "r") as inf:
            lineno = 0
            for line in inf:
                lineno += 1
                if line.startswith("#"):
                    continue
                words = line.strip().split("|")
                if len(words) == 11:
                    try:
                        self.atype_props[words[0]] = {
                            "Element": words[1],
                            "AtomNR": int(words[2]),
                            "Default": int(words[3]),
                            "Bonds": int(words[4]),
                            "Radius": float(words[5]),
                            "Row": int(words[6]),
                            "Charge": int(words[7]),
                            VSite: int(words[8]),
                            Shell: int(words[9]),
                            comment: words[10] }
                    except ValueError:
                        sys.exit(f"Error in file {atype_gui} on line {lineno}")

        maxrow = 6
        ncol = int(len(self.atype_props.keys())/maxrow)+1
        labParticle = tk.Label(frame, text=f"Select atomtypes", anchor="w", font=labelFont())
        labParticle.grid(row=myrow, columnspan=ncol, sticky=tk.N+tk.S+tk.W+tk.E)
        ttp = CreateToolTip(labParticle, "Atomtype definitions based on GAFF\nWang et al. J. Comp. Chem. 25 (2004) 1157")
        myrow += 1
        btnOn  = tk.Button(frame, text="Select all", anchor="w", font=labelFont(), command=self.allOn)
        btnOn.grid(row=myrow+2, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        btnOff = tk.Button(frame, text="Deselect all", anchor="w", font=labelFont(), command=self.allOff)
        btnOff.grid(row=myrow+4, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
        mycol += 1
        self.atypes = {}
        for at in self.atype_props.keys():
            self.atypes[at] = tk.IntVar()
            self.atypes[at].set(self.atype_props[at]["Default"])
            item = tk.Checkbutton(frame, text=at, command=None,
                                  variable=self.atypes[at])
            item.grid(row=myrow, column=mycol, sticky=tk.N+tk.S+tk.W+tk.E)
            ttp = CreateToolTip(item, text=self.atype_props[at][comment])
            myrow += 1
            if myrow == maxrow+1:
                myrow = 1
                mycol += 1
        self.newProps = {}
        self.select   = None

    def allOn(self):
        for at in self.atypes:
            self.atypes[at].set(1)
            self.atype_props[at]["Default"] = 1
            
    def allOff(self):
        for at in self.atypes:
            self.atypes[at].set(0)
            self.atype_props[at]["Default"] = 0

    def allVsite(self):
        status = self.selAll[VSite].get()
        for at in self.atype_props.keys():
            if self.atype_props[at]["Default"]:
                if at in self.newProps and VSite in self.newProps[at]:
                    self.newProps[at][VSite].set(status)
                    self.atype_props[at][VSite] = status

    def allShell(self):
        status = self.selAll[Shell].get()
        for at in self.atype_props.keys():
            if self.atype_props[at]["Default"]:
                if at in self.newProps and Shell in self.newProps[at]:
                    self.newProps[at][Shell].set(status)
                    self.atype_props[at][Shell] = status

    def selectProps(self, parent, qdist:str):
        self.select   = tk.Toplevel(parent)
        self.select.title("Atomtype properties selector")
        self.updateAtypeProps()
        ndef     = 0
        for at in self.atype_props.keys():
            if self.atype_props[at]["Default"]:
                ndef += 1
        maxrow = 15
        ncol   = int(ndef/maxrow)
        if ndef % maxrow > 0:
            ncol += 1
        nrow   = min(ndef, maxrow)+2+1
        self.content = ttk.Frame(self.select, padding=mypad)
        self.content.grid(rowspan=nrow, columnspan=3*ncol, sticky="news")
        # Column headers
        myrow = 0
        headers = [ "Type", VSite, Shell ]
        myfont = labelFont(16)
        for c in range(ncol):
            for lll in range(len(headers)):
                lab = tk.Label(self.content, text=headers[lll], font=myfont)
                lab.grid(row=myrow, column=3*c+lll, sticky="news")
        myrow += 1
        self.selAll = {}
        lab = tk.Label(self.content, text="All")
        lab.grid(row=myrow, column=0, sticky="nsw")
        for c in range(1):
            for lll in range(1, len(headers)):
                self.selAll[headers[lll]] = tk.IntVar()
                if headers[lll] == Shell:
                    mycmd = self.allShell
                elif headers[lll] == VSite:
                    mycmd = self.allVsite
                box = tk.Checkbutton(self.content, variable=self.selAll[headers[lll]], command=mycmd)
                box.grid(row=myrow, column=3*c+lll, sticky="news")
        myrow += 1
        mycol  = 0
        for at in self.atype_props.keys():
            if not self.atype_props[at]["Default"]:
                continue
            self.newProps[at] = {}
            lab = tk.Label(self.content, text=at)
            lab.grid(row=myrow, column=3*mycol, sticky="nsw")
            for lll in range(1, len(headers)):
                self.newProps[at][headers[lll]] = tk.IntVar()
                item = tk.Checkbutton(self.content, command=None,
                                      variable=self.newProps[at][headers[lll]])
                item.grid(row=myrow, column=3*mycol+lll, sticky="news")
            myrow += 1
            if myrow == maxrow+2:
                myrow = 2
                mycol += 1
        # Check whether we have to turn on the vsites at once
        if qdist == PG:
            self.selAll[VSite].set(1)
            self.allVsite()
        # Final buttons
        bwidth = int(3*ncol/2)
        buthelp = tk.Button(self.content, text="Help", command=self.help)
        buthelp.grid(row=nrow-1, column=0, columnspan=bwidth, sticky="news")
        butok   = tk.Button(self.content, text="OK", command=self.doneSelect)
        butok.grid(row=nrow-1, column=bwidth, columnspan=bwidth, sticky="news")
        for r in range(nrow):
            self.content.grid_rowconfigure(r, weight=1)
        for c in range(4*ncol):
            self.content.grid_columnconfigure(c, weight=1)
        self.ready = False
        while not self.ready:
            parent.update()
            time.sleep(0.1)

    def help(self):
        helpstr = "Select VSite for all atomtypes that you want to use an on-atom virtual site - this only makes sense for Gaussian or Slater distributed Coulomb though. In this case a force field will be created with a point charge on the core and a distributed charge virtual site. See Van der Spoel and Hosseini, Phys. Chem. Chem. Phys. 27 (2025) 13817. https://doi.org/10.1039/D5CP01254F\n\nSelect a Shell for all particles that you would like to be polarizable."
        show_info(helpstr)

    def doneSelect(self):
        self.ready = True

    def updateAtypeProps(self):
        for at in self.atypes:
            if self.atypes[at].get():
                self.atype_props[at]["Default"] = 1

    def getAtypes(self)->dict:
        # Not sure whether this does what it is supposed to
        for at in self.newProps:
            for head in [ VSite, Shell ]:
                self.atype_props[at][head] = self.newProps[at][head].get()
        # We should not try to destroy a window we did not (yet) create
        if self.select:
            self.select.destroy()
        atprops = {}
        for at in self.atypes:
            if self.atypes[at].get():
                atprops[at] = copy.deepcopy(self.atype_props[at])
                atprops[at]["Default"] = 1
        return atprops

class ACTLogo:
    def __init__(self, size:int, root):
        actlogo = library_file("ACTlogo2.png")
        if actlogo:
            self.icon = ImageTk.PhotoImage(Image.open(actlogo))
            self.logo = ttk.Label(root, image=self.icon, justify="center",
                                  width=size)
        else:
            # TODO: build in alternative if the logo image is not present
            sys.exit("Cannot find %s" % actlogo)

    def set_icon(self, root):
        root.tk.call('wm', 'iconphoto', root._w, self.icon)

    def set_grid(self, myrow=0, mycol=0):
        # The sticky stuff is incomprehensible...
        self.logo.grid(row=myrow, column=mycol, sticky="ns")

def callback(url:str):
    webbrowser.open_new(url)

class CombRule:
    def __init__(self, verbose:bool):
        self.crules  = {}
        self.ready   = False
        self.verbose = True

    def run(self, parent, functions:list):
        self.root = tk.Toplevel(parent)
        self.root.title("Combination Rule Selector")
        self.all_rules = [ geom, arith, "Volumetric", "InverseSquare", "Kronecker",
                           "HogervorstEpsilon", "HogervorstSigma", 
                           "WaldmanSigma", "WaldmanEpsilon",
                           "HalgrenEpsilon", "QiSigma", "QiEpsilon",
                           "Yang", "MasonGamma" ]

        # Default values according to Kriz et al. J. Chem. Theory Comput. 2024, 20, 2362-2376
        all_params = { "SLATER_ISA_TT": { "A": geom, "bExch": arith, "bDisp": arith,
                                          "c6": geom, "c8": geom, "c10": geom },
                       "TT2b": { "Att2b": geom, "bExchtt2b": arith, "bDisptt2b": arith,
                                 "c6tt2b": geom, "c8tt2b": geom, "c10tt2b": geom },
                       "GENERALIZED_BUCKINGHAM": { "rmin": "WaldmanSigma", "epsilon": "HalgrenEpsilon",
                                                   "gamma": "HogervorstSigma", "delta": arith },
                       "WANG_BUCKINGHAM": { "sigma": "InverseSquare", "epsilon": "HogervorstEpsilon",
                                            "gamma": "MasonGamma" },
                       "LJ14_7": { "sigma": geom, "epsilon": "Volumetric",
                                   "gamma": arith, "delta": arith },
                       "LJ12_6": { "sigma": geom, "epsilon": geom },
                       "LJ8_6": { "sigma": arith, "epsilon": "Volumetric" },
                       "MACDANIEL_SCHMIDT": { "a1dexp": geom, "a2dexp": geom, "bdexp": arith },
                       "MORSE_BONDS": { "bondlength": arith, "De": "Kronecker", "beta": arith, "D0": geom }
                      }
        nfunc     = len(functions)
        nparammax = 0
        for f in range(nfunc):
            potential = functions[f]["potential"]
            if potential not in all_params:
                show_info(f"Potential {potential} is not supported yet for manual selection of combination rules. Defaults will be used.")
                return
            else:
                nparammax = max(nparammax, len(all_params[potential].keys()))
        if self.verbose:
            print(f"There are {nfunc} functions and {nparammax} parameters at most")
        self.content = ttk.Frame(self.root, padding=mypad)
        ncol = 2*nfunc
        nrow = nparammax+3
        self.content.grid(row=0, column=0, columnspan=ncol, rowspan=nrow, sticky="news")
        mycol = 0
        for ff in range(nfunc):
            myrow     = 0
            itype     = functions[ff]["itype"]
            potential = functions[ff]["potential"]
            lab = ttk.Label(self.content, text=f"Interaction: {itype}", font=labelFont(16))
            lab.grid(row=myrow, column=mycol, columnspan=2, sticky="nws")
            myrow += 1
            lab = ttk.Label(self.content, text=f"Potential: {potential}", font=labelFont(16))
            lab.grid(row=myrow, column=mycol, columnspan=2, sticky="nws")
            myrow += 1
            # Variable to store data for this interaction
            self.crules[itype] = {}
            myparam = all_params[potential]
            for p in myparam:
                if self.verbose:
                    print(f"p {p} myparam[p] {myparam[p]}")
                self.crules[itype][p] = tk.StringVar(self.content)
                self.crules[itype][p].set(myparam[p])
                lab = ttk.Label(self.content, text=p)
                lab.grid(row=myrow, column=mycol, sticky="wns")
                menu = tk.OptionMenu(self.content, self.crules[itype][p], *self.all_rules)
                menu.grid(row=myrow, column=mycol+1, sticky="news")
                myrow += 1
            mycol += 2
        # Final two buttons
        myrow = nrow - 1
        hh = ttk.Button(self.content, text="Help", command=self.help)
        hh.grid(column=0, row=myrow, columnspan=nfunc, sticky="nwes")
        bb = ttk.Button(self.content, text="OK", command=self.done)
        bb.grid(column=nfunc, row=myrow, columnspan=nfunc, sticky="nwes")
        myrow += 1
        for r in range(nrow):
            self.content.grid_rowconfigure(r, weight=1)
        for c in range(ncol):
            self.content.grid_columnconfigure(c, weight=1)
        while not self.ready:
            parent.update()
            time.sleep(0.1)

    def help(self):
        helpstr = "Choose the combination rule for each parameter in the potential of your choice. Please be aware that combination rules represent an approximation of the potential between atoms.\n\nThe choice of rules has a large impact on the accuracy of your model. For more detailed information, please refer to Kriz et al. J. Chem. Theory Comput. 20 (2024) 2362. https://doi.org/10.1021/acs.jctc.3c01257. Default values for Van der Waals potentials suggested here come from that paper."
        show_info(helpstr)

    def done(self):
        self.ready = True

    def rules(self)->dict:
        myrules = {}
        if self.crules:
            for itype in self.crules:
                myrules[itype] = {}
                for c in self.crules[itype]:
                    myrules[itype][c] = self.crules[itype][c].get()
        self.root.destroy()
        return myrules

class FFGenerator:
    def __init__(self, root):
        self.width  = 900
        self.height = 800
        self.parent = root
        self.root   = tk.Toplevel(root)
        self.root.title("ACT - Force Field Generator")
        self.ffName        = None
        # User specified things
        self.opt_atomtypes = None
        self.opt_vsites    = None
        self.opt_params    = None

    def rootW(self):
        return self.root

    def doGenFF(self):
        if self.verbose.get():
            self.print()
        # Get file name
        file_path = saveasfile("Force Field filename to save", ".xml")
        if file_path:
            comb_rules = {}
            functions = [ { "itype": "VANDERWAALS", "potential": self.vdwSel.potential() } ]
            if self.icSel.potential() != "NONE":
                functions.append( { "itype": "INDUCTIONCORRECTION", "potential": self.icSel.potential() } )
            comb_rules = CombRule(self.verbose.get())
            comb_rules.run(self.root, functions)
            allrules = comb_rules.rules()
            if self.verbose:
                for itype in allrules:
                    print(f"Here are the combination rules you selected {allrules[itype]}")

            self.atoms.selectProps(self.root, self.qSel.qModel())
            status = self.runACT(file_path, allrules)
            if status == 0:
                msg = ("Succesfully generated a force field in %s" % file_path)
                self.ffName = file_path
                show_info(msg)
            else:
                show_info("Force field generation failed")
            self.close()

    def forceFieldName(self):
        return self.ffName

    def top(self):
        logo_size = 150
        self.logo_frame = ttk.Frame(self.root, width=logo_size,
                                    height=logo_size, padding=mypad)
        actlogo = library_file("ACTlogo2.png")
        if actlogo:
            self.logo     = ImageTk.PhotoImage(Image.open(actlogo))
            self.root.tk.call('wm', 'iconphoto', self.root._w, self.logo)
            mylogo        = tk.Label(self.logo_frame, image=self.logo, width = logo_size, height = logo_size).grid(row=0, column=0, sticky="news")
        else:
            # TODO: build in alternative if the logo image is not present
            sys.exit("Cannot find %s" % actlogo)
        self.atom_frame = ttk.Frame(self.root, padding=mypad, border=1, relief=tk.SOLID)
        self.atoms    = AtomTypes(self.atom_frame, myrow=0, mycol=0)

    def makePots(self):
        self.mid_frame = ttk.Frame(self.root,
                                   border=1, relief=tk.SOLID, padding=mypad)
        self.vdwSel   = VdwSel(self.mid_frame, myrow=0, mycol=0)
        self.qSel     = QSel(self.mid_frame, myrow=0, mycol=1)
        self.bondSel  = BondSel(self.mid_frame, myrow=0, mycol=2)
        self.angleSel = AngleSel(self.mid_frame, myrow=self.bondSel.nrows(), mycol=2)
        self.dihSel   = DihSel(self.mid_frame, myrow=self.bondSel.nrows()+self.angleSel.nrows(), mycol=2)
        self.icSel    = ICSel(self.mid_frame, myrow=self.qSel.nrows(), mycol=1)

    def makeButtons(self):
        self.bot_frame = ttk.Frame(self.root, padding=mypad, border=1, relief=tk.SOLID)
        self.saveIntermediates = tk.IntVar()
        self.saveIntermediates.set(1)
        item = tk.Checkbutton(self.bot_frame,
                              text="Save intermediate files", command=None,
                              variable=self.saveIntermediates).grid(row=0, column=0, sticky="nsw")
        self.verbose = tk.IntVar()
        self.verbose.set(0)
        item = tk.Checkbutton(self.bot_frame,text="Verbose mode", command=None,
                              variable=self.verbose).grid(row=0, column=1, sticky="nsw")
        tk.Button(self.bot_frame,
                  text="OK", default="active", command=self.doGenFF).grid(row=0, column=2, sticky="nsew")
        tk.Button(self.bot_frame,
                  text="Options", default="active", command=self.doOptions).grid(row=0, column=3, sticky="nsew")
        tk.Button(self.bot_frame,
                  text="Cancel", default="normal", command=self.close).grid(row=0, column=4, sticky="nsew")

    def close(self):
        self.done = True
        self.root.destroy()

    def doOptions(self):
        myopts = FFOptions()
        myopts.select(self.root)
        self.opt_atomtypes, self.opt_vsites = myopts.getVsites()
        self.opt_params = myopts.getParams()
        
    def run(self):
        # Build the elements of the window
        self.top()
        self.makePots()
        self.makeButtons()
        # layout all of the main containers
        self.root.grid_rowconfigure(1, weight=1)
        self.root.grid_columnconfigure(1, weight=1)
        # create top widgets
        self.logo_frame.grid(row=0, column=0, sticky="ewn")
        self.atom_frame.grid(row=0, column=1, sticky="ewn")
        # create the center widgets
        self.mid_frame.grid_rowconfigure(0, weight=1)
        for c in range(3):
            self.mid_frame.grid_columnconfigure(c, weight=1)
        self.mid_frame.grid(row=1, columnspan=3, sticky="ew")
        # create the bottom widgets
        self.bot_frame.grid_rowconfigure(1, weight=1)
        for c in range(5):
            self.bot_frame.grid_columnconfigure(c, weight=1)
        self.bot_frame.grid(row=2, columnspan=5, sticky="ews")
        self.done = False
        while not self.done:
            time.sleep(0.1)
            self.parent.update()

    def print(self):
        print(f"VDW potential selected: {self.vdwSel.potential()}")
        vdwPart = self.vdwSel.vdwParticles()
        for ptype in vdwPart.keys():
            print(f"VDW on {ptype}: {vdwPart[ptype]}")
        print(f"Charge model selected: {self.qSel.qModel()}")
        print(f"Bond potential selected: {self.bondSel.potential()}")
        print(f"Angle potential selected: {self.angleSel.potential()}")
        print(f"Dihedral potential selected: {self.dihSel.potential()}")
        print(f"Induction correction potential selected: {self.icSel.potential()}")
        print(f"Selection of atomtypes {self.atoms.getAtypes()}")

    def generateCSV(self)->bool:
        self.csv_file = None
        if self.saveIntermediates.get():
            # Let user decide what file to save atomtypes in
            self.csv_file = saveasfile("File to save atomtypes", ".csv")
            if self.csv_file:
                self.tf = open(self.csv_file, "w")
        else:
            # Open a temporary file
            self.tf = tempfile.NamedTemporaryFile(suffix=".csv", mode='w')
            self.csv_file = self.tf.name
        if not self.csv_file or len(self.csv_file) == 0:
            print("No correct csv file name received or temp file opening failed.")
            return False

        # Fetch the atom types selected by the user
        atype_props = self.atoms.getAtypes()
        if len(atype_props) == 0:
            show_info("No atom types selected!")
            return False

        # Do we need to generate vsite1 definitions?
        self.vsite_file = None
        needVS1 = False
        for atp in atype_props:
            if atype_props[atp][VSite] > 0:
                needVS1 = True
        if needVS1 or (self.opt_vsites and len(self.opt_vsites) > 0):
            # Yes!
            if self.saveIntermediates.get():
                # Let user decide what file to save atomtypes in
                self.vsite_file = saveasfile("File to save vsite definitions", ".csv")
                if self.vsite_file:
                    self.vs1f = open(self.vsite_file, "w")
                else:
                    return False
            else:
                # Open a temporary file
                self.vs1f = tempfile.NamedTemporaryFile(suffix=".csv", mode='w')
                self.vsite_file = self.vs1f.name
                if not self.vsite_file:
                    return False
            # Copy all the vsite info that user selected to a new file.
            # If the user selected vsite1 as well, they will be added later.
            if self.opt_vsites and len(self.opt_vsites) > 0:
                for line in self.opt_vsites:
                    self.vs1f.write("%s\n" % line)

        allData = {}
        # Set some shortcuts
        vdwPart = self.vdwSel.vdwParticles()
        qdist   = self.qSel.qModel()
        # Convenience function
        def setParam(atp:str, inter:str, pname:str, mymin:float, mymax:float, mymut:str, unit:str,
                     nonNegative=True):
            prefix = f"{inter}:{pname}:"
            if (self.opt_params and
                inter in self.opt_params and
                atp in self.opt_params[inter] and
                pname == self.opt_params[inter][atp]["parameter"]):
                value = self.opt_params[inter][atp]["value"]
                mymin = value
                mymax = value
                mymut = Fixed
                unit  = self.opt_params[inter][atp]["unit"]
                nonNegative = value >= 0
                if self.verbose:
                    print("Applying user determined value %g for %s/%s/%s" % ( value, inter, atp, pname ) )
            allData[atp][prefix+"min"]    = mymin
            allData[atp][prefix+"max"]    = mymax
            allData[atp][prefix+"mut"]    = mymut
            allData[atp][prefix+"unit"]   = unit
            allData[atp][prefix+"nonneg"] = str(nonNegative)

        # And another one
        def setVDW(atype_name:str, vdwtp:str):
            bounds = self.vdwSel.bounds()
            vdw_mut = Fixed
            if vdwPart[vdwtp]:
                vdw_mut = Bounded
            for b in bounds:
                if not b == comment:
                    setParam(atype_name, "VANDERWAALS", b, bounds[b][0], bounds[b][1], vdw_mut, bounds[b][2])

        # and a third one
        def setVDWcorr(atp:str, turnOn:bool):
            if self.needVDWcorr:
                vdwcorr = "VDWCORRECTION"
                if turnOn:
                    setParam(atp, vdwcorr, "aexp", 0, 50000, Bounded, "kJ/mol")
                    setParam(atp, vdwcorr, "bexp", 10, 50, Bounded, "1/nm")
                else:
                    setParam(atp, vdwcorr, "aexp", 0, 0, Fixed, "kJ/mol")
                    setParam(atp, vdwcorr, "bexp", 10, 50, Fixed, "1/nm")
            
        # Atomtypes corresponding to virtual sites
        # First check whether we need any VDWCORRECTION at all
        self.needVDWcorr = False
        if self.opt_atomtypes:
            for atp in self.opt_atomtypes.keys():
                if self.opt_atomtypes[atp]["exchcorr"]:
                    self.needVDWcorr = True
            for atp in self.opt_atomtypes.keys():
                allData[atp] = { "element": "VS", "mass": 0,
                                 "bondtype": atp, "poltype": "",
                                 "acmtype": "", "vdwtype": atp,
                                 "atomicnumber": 0, "zetatype": atp+"_z",
                                 "radius": 0, "row": 0 }
                setParam(atp, "", "q", -2, 2, Bounded, "e", False)
                if qdist:
                    setParam(atp, coul, "zeta", 0, 0, Fixed, "1/nm")
                else:
                    setParam(atp, coul, "zeta", 4, 20, Bounded, "1/nm")
                # Determine whether to use VDW
                setVDW(atp, VSite)
                # Some of the vsites may get the van der waals correction
                setVDWcorr(atp, self.opt_atomtypes[atp]["exchcorr"])
            
        # Normal atomtypes
        for atp in atype_props:
            polarizable = atype_props[atp][Shell] > 0
            haveVS1     = atype_props[atp][VSite] > 0
            for vdwtp in [ Atom, Shell, VSite ]:
                if vdwtp == VSite and not haveVS1:
                    continue
                if vdwtp == Shell and not polarizable:
                    continue
                atype_name = atp
                element = atype_props[atp]['Element']

                if vdwtp == Shell:
                    atype_name = atp + "_s"
                    element    = "X"
                elif vdwtp == VSite:
                    atype_name = "v1" + atp
                    element = "VS"
                    vs1btype = atp
                    self.vs1f.write(f"{atype_name}|VSITE1|{vs1btype}|0|1||||\n")
                btype = atype_name
                if vdwtp == Atom and atype_props[atp]["Bonds"] > 0:
                    btype = atype_name + "_b"
                radius  = ""
                row     = 0
                ztype   = atype_name + "_z"
                acmtype = ""
                stype   = ""
                if vdwtp == Atom:
                    acmtype = ztype
                    radius  = str(atype_props[atp]['Radius'])
                    row     = atype_props[atp]['Row']
                    if polarizable:
                        stype = atp + "_s"
                atomNR = atype_props[atp]["AtomNR"]
                # New atomtype, set element and atomic number and subtypes
                allData[atype_name] = { "element": element, "atomicnumber": atomNR,
                                        "bondtype": btype, "zetatype": ztype, "acmtype": acmtype,
                                        "poltype": stype, "radius": radius, "row": row }
                # Highest charge for vsite1 and shells
                if haveVS1 or polarizable:
                    if vdwtp == Atom:
                        setParam(atype_name, "", "q", 0, atomNR, "ACM", "e", False)
                    elif vdwtp == VSite:
                        # Highest charge for vsite1
                        qmax = 0
                        setParam(atype_name, "", "q", -atomNR, qmax, Bounded, "e", False)
                    elif vdwtp == Shell:
                        # Highest charge for shells. Shells with too small charges will move too far
                        # from the core, leading to unstable simulations.
                        qmax = -1
                        setParam(atype_name, "", "q", -atomNR, qmax, Bounded, "e", False)
                else:
                    setParam(atype_name, "", "q", 0, 0, "ACM", "e", False)

                if qdist == Point or (vdwtp == Atom and haveVS1):
                    setParam(atype_name, coul, "zeta", 0, 0, Fixed, "1/nm")
                else:
                    setParam(atype_name, coul, "zeta", 4, 20, Bounded, "1/nm")

                if polarizable and vdwtp == Shell:
                    setParam(atype_name, "POLARIZATION", "alpha", 1e-6, 12, Bounded, "Angstrom3")
                    setParam(atype_name, "POLARIZATION", "rhyper", 0.02, 0.02, Fixed, "nm")
                    setParam(atype_name, "POLARIZATION", "fchyper", 0, 5e8, Fixed, "kJ/mol nm4")

                # Determine whether to use VDW
                setVDW(atype_name, vdwtp)
                # And van der waals corrections if needed.
                setVDWcorr(atype_name, False)

                if vdwtp == Atom:
                    setParam(atype_name, "ELECTRONEGATIVITYEQUALIZATION", "eta", 4, 20, Bounded, "eV")
                    setParam(atype_name, "ELECTRONEGATIVITYEQUALIZATION", "chi", 4, 12, Bounded, "eV/e")

                if self.icSel.potential() != "NONE":
                    bounds = self.icSel.bounds()
                    icp    = self.icSel.icParticles()
                    ic_mut = Fixed
                    if vdwtp in icp:
                        if icp[vdwtp]:
                            ic_mut = Bounded
                        for b in bounds:
                            if not b == comment:
                                setParam(atype_name, "INDUCTIONCORRECTION", b, bounds[b][0], bounds[b][1], ic_mut, bounds[b][2])
                if vdwtp == Atom:
                    allData[atype_name][comment] = atype_props[atp][comment]

        # Done with building the data structure, now store it to a file
        if len(allData.keys()) == 0:
            sys.exit("Did not find any atomtypes")
        self.tf.write("#atomtype")
        mykeys = {}
        for atp in allData:
            for param in allData[atp]:
                mykeys[param] = 1
        for mk in mykeys:
            self.tf.write(f"|{mk}")
        self.tf.write("\n")
        for ad in allData.keys():
            self.tf.write(f"{ad}")
            for mk in mykeys:
                value = ""
                if mk in allData[ad]:
                    value = allData[ad][mk]
                self.tf.write(f"|{value}")
            self.tf.write("\n")

        if self.verbose.get():
            print("Generated file %s" % self.csv_file)
        return True

    def closeCSV(self):
        # Close atomtypes file
        self.tf.close()
        # Close vsite1 only when needed
        if self.vsite_file:
            self.vs1f.close()

    def runACT(self, file_path:str, comb_rules:dict)->int:
        epsr  = self.qSel.epsilonR()
        nexcl = self.vdwSel.nExcl()
        qsymm = " -noqsymm "
        # status = 0 corresponds to everything was fine under Linux / MacOS.
        status = 1
        if self.qSel.symm():
            qsymm = " -qsymm "
        if self.generateCSV():
            qdist = self.qSel.qModel()
            if qdist == PG:
                qdist = Gaussian
            cmd = f"alexandria gen_ff -f {self.csv_file} -nexclqq {nexcl} -nexclvdw {nexcl} -epsilonr {epsr} -vdwfn {self.vdwSel.potential()} -qdist {qdist} {qsymm} -anglefn {self.angleSel.potential()} -dihfn {self.dihSel.potential()} -o {file_path}"
            if self.vsite_file:
                cmd += f" -vs {self.vsite_file} "
            icpot = self.icSel.potential()
            if icpot != "NONE":
                cmd += f" -icfn {icpot} "
            if self.needVDWcorr:
                cmd += " -vdwcorr "
            if len(comb_rules.keys()) > 0:
                cmd += " -cr '"
                for itype in comb_rules:
                    for param in comb_rules[itype]:
                        cmd += f" {itype}:{param}:{comb_rules[itype][param]}"
                if self.needVDWcorr:
                    cmd += " VDWCORRECTION:aexp:Arithmetic VDWCORRECTION:bexp:Arithmetic "
                cmd += " '"
            if self.verbose:
                print(f"Command line: {cmd}")
            # Make sure all info is in the files!
            self.tf.flush()
            if self.vsite_file:
                self.vs1f.flush()
            status = os.system(cmd)
            self.closeCSV()
        return status
    
class GeometryFF:
    def __init__(self, root):
        self.root = root

    def run(self, ffName:str)->int:
        self.tl = tk.Toplevel(self.root)
        self.tl.title("Molecular geometry options")
        tlc = ttk.Frame(self.tl, padding=mypad)
        myrow = 0
        l1  = ttk.Label(tlc, text="Charge algorithm", font=labelFont())
        l1.grid(row=myrow, column=0,  sticky="nws")
        myrow += 1
        mycol  = 0
        # Radiobuttons for the charge algorithm
        qalg = tk.StringVar(tlc, "SQE")
        qalgs = { "SQE": "Split charge equilibration\nVerstraelen et al., J. Chem. Phys. 131 (2009) 044127",
                  "EEM": "Electronegativity equilibration\nRappe & Goddard, J. Phys. Chem. 95 (1991) 3358" }
        for qq in qalgs.keys():
            item = tk.Radiobutton(tlc, text=qq, variable=qalg,
                                  value=qq, command=None)
            item.grid(row=myrow, column=mycol, sticky="nsw")
            tpp = CreateToolTip(item, qalgs[qq])
            myrow += 1
        # Options for boundaries
        myrow = 0
        l1  = ttk.Label(tlc, text="Parameter variation", font=labelFont())
        l1.grid(row=myrow, column=1,  sticky="nws")
        myrow += 1
        mycol  = 1
        label = "label"
        var   = "variable"
        cmd   = "command"
        fff = { "-bfactor": { label:"Bond length", var:tk.DoubleVar(tlc, 0.95) },
                "-afactor": { label:"Angle", var:tk.DoubleVar(tlc, 0.95) },
                "-factor": { label:"Other", var:tk.DoubleVar(tlc, 0.5) } }
        for ff in fff.keys():
            ll = ttk.Label(tlc, text=fff[ff][label])
            ll.grid(row=myrow, column=mycol, sticky="nws")
            ss = ttk.Entry(tlc, textvariable=fff[ff][var])
            ss.grid(row=myrow, column=mycol+1, sticky="nws")
            myrow += 1

        # File buttons
        select = "Select..."
        if not ffName:
            ffName = select
        self.fnms = { "-mp": { label: "Molprop file",  defnm:select, cmd:self.mpfile },
                      "-ff": { label: "Input FF file", defnm:ffName, cmd:self.input_ff },
                      "-o":  { label: "Output FF file", defnm:ffName, cmd:self.output_ff } }
        mycol = 0
        self.fnbut = {}
        for fn in self.fnms.keys():
            ll = ttk.Label(tlc, text=self.fnms[fn][label], font=labelFont())
            ll.grid(row=myrow, column=mycol, sticky="nws")
            # Check whether we have a real file name here or not
            mytext = self.fnms[fn][defnm]
            if mytext != select:
                mytext = os.path.basename(mytext)
            self.fnbut[fn] = ttk.Button(tlc, text=mytext, command=self.fnms[fn][cmd])
            self.fnbut[fn].grid(row=myrow+1, column=mycol, sticky="news")
            mycol += 1
        myrow += 2
        
        # Final OK button
        self.ok     = False
        self.cancel = False
        but = ttk.Button(tlc, text="OK", command=self.done)
        but.grid(row=myrow, column=0, sticky="news")
        but = ttk.Button(tlc, text="Cancel", command=self.stop)
        but.grid(row=myrow, column=2, sticky="news")
        myrow += 1

        tlc.grid(row=0, column=0, rowspan=myrow, sticky="news")
        for r in range(myrow):
            tlc.grid_rowconfigure(r, weight=1)
        for c in range(3):
            tlc.grid_columnconfigure(c, weight=1)
        # Wait for the user to press ok
        while not self.ok and not self.cancel:
            self.root.update()
            time.sleep(0.1)
        if self.cancel:
            return 1

        if not os.path.exists(self.fnms["-ff"][defnm]):
            show_info(f"Force field file {self.fnms['-ff'][defnm]} does not exist")
            return 1
        elif not os.path.exists(self.fnms["-mp"][defnm]):
            show_info(f"Molprop file {self.fnms['-mp'][defnm]} does not exist")
            return 1
        mycmd = f"alexandria geometry_ff "
        for fn in self.fnms:
            mycmd += f" {fn} {self.fnms[fn][defnm]} "
        if qalg.get() == "EEM":
            mycmd += " -nogen_bcc "
        for ff in fff:
            mycmd += f" {ff} {fff[ff][var].get()} "
        print(f"Will run '{mycmd}'")
        status = os.system(mycmd)

        if status == 0:
            show_info(f"Updated bond information and saved {self.fnms['-o'][defnm]}")
        else:
            show_info(f"Something went wrong when updating bond information in {self.fnms['-ff'][defnm]}")
        return status

    def mpfile(self):
        # Get file name
        molprop = openasfile("Molecule Property File", ".xml")
        if molprop:
            # Update button text
            self.fnbut["-mp"].configure(text=os.path.basename(molprop))
            # and filename
            self.fnms["-mp"][defnm] = molprop

    def input_ff(self):
        # Get file name
        inff = openasfile("Input FF File", ".xml")
        if inff:
            # Update button text
            self.fnbut["-ff"].configure(text=os.path.basename(inff))
            self.fnms["-ff"][defnm] = inff

    def output_ff(self):
        # Get file name
        outff = openasfile("Output FF File", ".xml")
        if outff:
            # Update button text
            self.fnbut["-o"].configure(text=os.path.basename(outff))
            self.fnms["-o"][defnm] = outff

    def stop(self):
        self.cancel = True
        self.tl.destroy()

    def done(self):
        self.ok = True
        self.tl.destroy()

class Manager:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("ACT - GUI")
        self.root.configure()
        self.ffName = None

        default_font = tkFont.nametofont("TkDefaultFont")
        default_font.configure(size=16)
        
        # TODO: get this number from the image size
        logo_size = 150
        self.height = logo_size+2*pad1
        self.width = 2*self.height
        self.root.minsize(self.width, self.height)
        self.root.maxsize(2*self.width, 2*self.height)
        self.content = ttk.Frame(self.root, padding=mypad)
        self.content.grid(row=0, column=0, rowspan=1, columnspan=2, sticky="ewns")
        self.logoStuff(self.content, logo_size)
        self.addButtons(self.content, 1)
    
    def logoStuff(self, root, logo_size:int):
        self.logo_frame = ttk.Frame(root, width=self.height, height=self.height, padding=mypad)
        self.logo_frame.grid(row=0, column=0, rowspan=3, sticky="ew")
        self.logo = ACTLogo(logo_size, self.logo_frame)
        self.logo.set_grid()
        self.logo.set_icon(self.root)
        label = tk.Label(self.logo_frame, text="Alexandria Chemistry\nToolkit",
                         justify='center', relief='solid', borderwidth=0,
                         font=labelFont(), fg="blue", cursor="hand2")
        label.grid(row=1, column=0, sticky="ew")
        label.bind("<Button-1>", lambda e: callback("http://github.com/AlexandriaChemistry"))
        lab2 = tk.Label(self.logo_frame, text="(c) 2025 David van der Spoel",
                         justify='center', relief='solid', borderwidth=0)
        lab2.grid(row=2, column=0, sticky="ew")
    
    def run(self):
        # layout all of the main containers
        self.root.rowconfigure(0, weight=1)
        self.root.columnconfigure(0, weight=1)
        for c in range(2):
            self.content.grid_columnconfigure(c, weight=1)
        
        for r in range(2):
            self.logo_frame.grid_rowconfigure(r, weight=1)
        for r in range(len(self.mybuttons)):
            self.bframe.grid_rowconfigure(r, weight=1)
        self.root.mainloop()

    def genff(self):
        ffgen = FFGenerator(self.root)
        ffgen.run()
        self.ffName = ffgen.forceFieldName()

    def geometry(self):
        geomff = GeometryFF(self.root)
        geomff.run(self.ffName)

    def help(self):
        helpstr = ("This is a simple frontend to some the commands available in the Alexandria Chemistry Toolkit.\n\nYou can generate a force field template, pressing the button will pop-up another window where you can make selections of atom types, potentials and some algorithmic options.\n\nThen you can add parameters for bonded functions if you provide a molecule property (molprop) file that will be analysed for bond-lengths, angles, etc. after which the information will be added to your force field file.")
        show_info(helpstr)

    def stop(self):
        self.root.quit()

    def addButtons(self, parent, mycol:int):
        bwidth = int(self.width/2) - pad1
        self.bframe = ttk.Frame(parent, width=bwidth,
                                height=bwidth, border=0, relief=tk.SOLID, padding=mypad)
        self.bframe.grid(row=0, column=mycol, rowspan=3, sticky="wens")
        myrow = 0
        bdict = { "Generate force field": self.genff,
                  "Add bonded parameters": self.geometry,
                  "Help": self.help,
                  "Quit": self.stop }
        deft      = "normal"
        self.mybuttons = []
        for bd in bdict:
            mybut = ttk.Button(self.bframe, text=bd, default=deft, command=bdict[bd])
            mybut.grid(row=myrow, column=mycol, sticky="ew", padx=pad1, pady=pad1)
            self.mybuttons.append(mybut)
            deft   = "normal"
            myrow += 1

if __name__ == "__main__":
    manager = Manager()
    manager.run()
