#!/usr/bin/env python3

import os, argparse
import tkinter, matplotlib
import matplotlib.pyplot as plt
matplotlib.use('TkAgg')
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation
from xvgutils import *

debug = False

def parseArguments():
    parser = argparse.ArgumentParser(
      prog='viewxvg',
      description=
"""
Braindead script to quickly plot xy files produced by e.g. ACT or GROMACS.
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: viewxvg -f filename1 filename2 -follow')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=None)
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s)", action="store_true")
    parser.add_argument("-debug", "--debug", help="Turn on printing of debugging messages", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    axislabelfontsize=12
    parser.add_argument("-alfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=16
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=8
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    linestyle="solid"
    parser.add_argument("-ls", "--linestyle", help="What kind of line style: solid, dash, dashdot, None, default "+linestyle, type=str, default=linestyle)
    parser.add_argument("-mk", "--marker", help="Use markers for data sets", action="store_true")
    parser.add_argument("-pdf", "--pdf", help="Save plot as pdf file", type=str, default=None)
    parser.add_argument("-sq", "--square", help="Make the plot square with equal axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    parser.add_argument("-xmin", "--xmin", help="Minimum width of X-axis. Default = no minimum.", type=float, default=0.0)
    parser.add_argument("-xmax", "--xmax", help="Maximum width of X-axis. Default = no maximum.", type=float, default=0.0)
    parser.add_argument("-ymin", "--ymin", help="Minimum height of Y-axis. Default = no minimum.", type=float, default=0.0)
    parser.add_argument("-ymax", "--ymax", help="Maximum height of Y-axis. Default = no maximum.", type=float, default=0.0)
    parser.add_argument('-ign', '--ignore', help="Labels of the series to ignore", nargs='*', default=[])
    parser.add_argument("-title", "--title", help="User-defined title", type=str, default=None)
    parser.add_argument("-labels", "--labels", help="User-defined labels", nargs="*", type=str, default=None)
    parser.add_argument("-legend_right", "--legend_right", help="Put the legend box on the right side of the graph", action="store_true")
    parser.add_argument("-legend_out", "--legend_out", help="Put the legend box on at the top right outside of the graph", action="store_true")

    return parser.parse_args()

args = parseArguments()
if args.debug:
    debug = True
fig, ax = plt.subplots()

def set_extent(dataset):
    if len(dataset) < 1:
        return 0, 0
    xxmin = dataset[0].xmin
    xxmax = dataset[0].xmax
    yymin = dataset[0].ymin
    yymax = dataset[0].ymax
    for ii in range(len(dataset)):
        xxmin = min(xxmin, dataset[ii].xmin)
        xxmax = max(xxmax, dataset[ii].xmax)
        yymin = min(yymin, dataset[ii].ymin)
        yymax = max(yymax, dataset[ii].ymax)
    if args.square:
        mmin = min(xxmin, yymin)
        mmax = max(xxmax, yymax)
        delta = 5+(mmax-mmin)/20
        mmin -= delta
        mmax += delta
        xxmin = mmin
        xxmax = mmax
        yymin = mmin
        yymax = mmax
    if 0 != args.xmin:
        xxmin = args.xmin
    if 0 != args.xmax:
        xxmax = args.xmax
    if 0 != args.ymin:
        yymin = args.ymin
    if 0 != args.ymax:
        yymax = args.ymax
    # Now effectuate the options
    if args.square:
        if xxmin == yymin and xxmax == yymax:
            ax.set_aspect('equal', adjustable='box')
        elif debug:
            print("Option -sq overruled by min and max options")
    plt.xlim(xxmin, xxmax)
    plt.ylim(yymin, yymax)
    return xxmin, xxmax

def plot_once():
    legends = {}
    ax.clear()
    have_labels = args.labels != None
    arglabel = []
    if args.labels:
        arglabel = []
        for value in args.labels:
            if value is not None:
                arglabel.append(value)
        if debug:
            print("Found the following command-line labels {}".format(arglabel))
    filenumber = 0
    for fn in args.filename:
        label, legend, dataset = read_xvg(fn)
        if len(dataset) == 0:
            print("File %s has no data" % fn)
            continue
        if len(arglabel) > 0:
            # This has to be a list, there can be multiple data sets per file
            label = [ arglabel[filenumber] ]
        filenumber += 1
        xxmin, xxmax = set_extent(dataset)
        if args.logy:
            ax.set_yscale('log')
        for leg in legend.keys():
            legends[leg] = legend[leg]
        have_labels = have_labels or len(label) > 0
        if args.bar:
            print("Doing bar graphs")
            for xy in dataset:
                ax.bar(xy.x, xy.y, width=0.8/len(xy.y), bottom=0.0, align="center", label=fn)
        else:
            print_label = len(label) == len(dataset)
            markers = [ "+", "x", ".", "v", "s", "o" ]
            for n in range(len(dataset)):
                mylabel  = None
                if len(label) > n and label[n] not in args.ignore:
                    if print_label:
                        mylabel = label[n]
                mymarker = None
                if args.marker:
                    mymarker=markers[n % len(markers)]
                if debug:
                    print("mylabel = {}".format(mylabel))
                ax.plot(dataset[n].x, dataset[n].y, label=mylabel, ls=args.linestyle, marker=mymarker)

    if args.title:
        plt.title(args.title, fontsize=args.titlefontsize)
    elif "title" in legends:
        plt.title(legends["title"], fontsize=args.titlefontsize)
    if "xlabel" in legends:
        ax.set_xlabel(legends["xlabel"], fontsize=args.axislabelfontsize)
    if "ylabel" in legends:
        ax.set_ylabel(legends["ylabel"], fontsize=args.axislabelfontsize)
    if args.legendfontsize > 0 and have_labels or args.labels:
        if args.legend_right:
            xlegend = xxmin + 0.8*(xxmax-xxmin)
            ax.legend(loc='upper right', bbox_to_anchor=(xlegend, 1), fontsize=args.legendfontsize)
        elif args.legend_out:
            xlegend = xxmax + 0.02*(xxmax-xxmin)
            box = ax.get_position()
            ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])
            ax.legend(loc='upper left', bbox_to_anchor=(1, 1), fontsize=args.legendfontsize)
        else:
            xlegend = 0.01
            ax.legend(loc='upper left', bbox_to_anchor=(xlegend, 1), fontsize=args.legendfontsize)
    if args.pdf:
        # Print just once!
        fig.savefig(args.pdf, bbox_inches='tight')
        args.pdf = None
        
def animate(t):
    plot_once()
    plt.gcf().autofmt_xdate()
    plt.tight_layout()

if __name__ == '__main__':   
    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    if args.filename:
        if args.follow:
            ani = FuncAnimation(plt.gcf(), animate, interval=5000)
        else:
            plot_once()
        if not args.noshow:
            plt.show()
