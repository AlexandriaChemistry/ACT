#!/usr/bin/env python3

import math, os, argparse, string
import tkinter, matplotlib
import matplotlib.pyplot as plt
import numpy as np
matplotlib.use('TkAgg')
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation
from xvgutils import *

viewDebug = False

# Hardcoded formatting, Yay!
defcolors  = ["#1f77b4", "#ff7f0e", "#2ca02c", "#7f0000", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#aec7e8","#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"]
defmarkers = ["o", "+", "<", ">", "v", "^", "x", "s", "p", "*", ".", "D", "d", "h", "H", "|", "_"]
deflines   = [ 'solid', 'dashed', 'dashdot', 'dotted' ]

def parseArguments():
    parser = argparse.ArgumentParser(
      prog='viewxvg',
      description=
"""
Simple script to quickly plot xy files produced by e.g. ACT or GROMACS.
There is limited support for Grace features such superscripts and subscripts
in labels. Remember to add an argument for each file you want to plot. 
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: viewxvg -f filename1 filename2 -ls solid dashed -follow')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=None)
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s)", action="store_true")
    parser.add_argument("-debug", "--debug", help="Turn on printing of debugging messages", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    axislabelfontsize=18
    parser.add_argument("-alfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=18
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=18
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    tickfontsize=14
    parser.add_argument("-tickfs", "--tickfontsize", help="Tick font size, default "+str(tickfontsize), type=int, default=tickfontsize)
    parser.add_argument("-ls", "--linestyle", help="What kind of line style: solid, dashed, dashdot...", nargs="+", type=str, default=None)
    parser.add_argument("-mk", "--marker", help="Use markers for data sets: o, +, x, <, >...", nargs="+", type=str, default=None)
    parser.add_argument("-mk1st", "--mark1st", help="Use marker for the first of all data sets only", action="store_true")
    defmksize = 12
    parser.add_argument("-mksize", "--markersize", help="Size of filled markers for data sets, default "+str(defmksize), default=defmksize, type=int)
    defmkedgew = 2
    parser.add_argument("-mkwidth", "--markeredgewidth", help="Size of character markers (e.g. +) for data sets, default "+str(defmkedgew), default=defmkedgew, type=int)
    parser.add_argument("-colors", "--colors", help="Colors for the plots. Colors defined by the user will be applied to the datasets in order. If there are more datasets than color inputs, default colors will be used.", nargs="*", type=str, default=None)
    parser.add_argument("-save", "--save", help="Save plot. Please specify saving location and preferred filetype (.pdf, .png...)", type=str, default=None)
    parser.add_argument("-sqfig", "--squarefig", help="Make the figure square", action="store_true")
    parser.add_argument("-eqax", "--equalaxes", help="Make the plot square with equally large axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-res", "--residual", help="Subtract x from y for all data sets - useful for correlation plots", action="store_true")
    parser.add_argument("-fl", "--filelabel", help="Add the filename to the labels in the plot (may yield long labels)", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    parser.add_argument("-xmin", "--xmin", help="Minimum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-xmax", "--xmax", help="Maximum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymin", "--ymin", help="Minimum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymax", "--ymax", help="Maximum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    xframe = 16
    parser.add_argument("-xframe", "--xframe", help="Width of the plot 100 pixels, default "+str(xframe), type=int, default=xframe)
    yframe = 9
    parser.add_argument("-yframe", "--yframe", help="Height of the plot 100 pixels, default "+str(yframe), type=int, default=yframe)
    parser.add_argument("-panels", "--panels", help="Generate different panels to plot in, one file per panel", action="store_true")
    subfigx = -0.1
    subfigy = 1.0
    parser.add_argument("-sfx", "--subfigureX", help="X position of subfigure label when using panels. Default "+str(subfigx), type=float, default=subfigx)
    parser.add_argument("-sfy", "--subfigureY", help="Y position of subfigure label when using panels. Default "+str(subfigy), type=float, default=subfigy)
    parser.add_argument('-ign', '--ignore', help="Labels of the series to ignore. Please specify the whole label.", nargs='*', default=[])
    parser.add_argument("-title", "--title", help="User-defined title", type=str, default=None)
    parser.add_argument("-labels", "--labels", help="User-defined labels", nargs="*", type=str, default=None)
    parser.add_argument("-sharelabel", "--sharelabel", help="Choose to only show the lower x-label (if both subplots would use the same x-label for example)", action="store_true")
    leg_x = 0.02
    parser.add_argument("-legend_x", "--legend_x", help="Put the legend box horizontally on this position, default "+str(leg_x), type=float, default=leg_x)
    leg_y = 0.98
    parser.add_argument("-legend_y", "--legend_y", help="Put the legend box vertically on this position, default "+str(leg_y), type=float, default=leg_y)
    parser.add_argument("-stats", "--stats", help="Print RMSD and R2 values of datasets (x-axis is reference data and y-axis holds the predicted values)", action="store_true")
    return parser.parse_args()

def texify(txt:str)->str:
    return txt.replace("\\S", "$^{").replace("\\s", "$_{").replace("\\N", "}$")
    
class DataSet:
    def __init__(self):
        # Labels for datasets
        self.label   = []
        # Legends for axes
        self.legends = {}
        self.dataset = []
        #viewDebug   = debug

    def calc_rmsd_r2(self, x, y):
        x = np.asarray(x)
        y = np.asarray(y)
        rmsd = np.sqrt(np.mean((x - y) ** 2))
        
        ss_res = np.sum((x - y) ** 2)
        ss_tot = np.sum((x - np.mean(x)) ** 2)
        if ss_tot != 0:
            r2 = 1 - ss_res / ss_tot
        else:
            r2 = 'NaN'
        return rmsd, r2

    def read(self, filenm:str, residual:bool, filelabel:bool, arglabel:str, setcount):
        
        label, legend, dataset = read_xvg(filenm, residual, filelabel)
        if len(dataset) == 0:
            if viewDebug:
                print("File %s has no data" % filenm)
        else:
            if viewDebug:
                print("Read %d labels and %d legends from %d dataset(s) in input file %d\n" % (len(label), len(legend), len(dataset), setcount+1))
            for d in dataset:
                self.dataset.append(d)
            for k in legend:
                self.legends[k] = legend[k]
            # This has to be a list, there can be multiple data sets per file
            #Add labels to axes if there is none in the dataset
            if "xlabel" not in self.legends:
                self.legends["xlabel"] = "x-axis"
            if "ylabel" not in self.legends:
                self.legends["ylabel"] = "y-axis"            
            if len(label) > 0:
                for l in range(len(label)):
                    if arglabel:
                        self.label.append(texify(arglabel + " " + label[l]))
                    else:
                        self.label.append(texify(label[l]))
            elif arglabel:
                self.label.append(texify(arglabel))
            if args.stats:
                #Fetch the dataset without residual
                _,_,ori_dataset = read_xvg(filenm, False, filelabel)
                #Print R2 and RMSD values in legend
                for d in range(len(ori_dataset)):
                    ds = ori_dataset
                    rmsd, r2 = self.calc_rmsd_r2(ds[d].x, ds[d].y)
                    self.label[d] = f"{self.label[d]}, RMSD = {rmsd:.4f}, R2 = {r2:.4f}"

    def have_label(self):
        return len(self.label) > 0

    def set_extent(self, myax, args):
        if len(self.dataset) < 1:
            print("No data in set_extent")
            return 0, 0, 0, 0
        xxmin = self.dataset[0].xmin
        xxmax = self.dataset[0].xmax
        yymin = self.dataset[0].ymin
        yymax = self.dataset[0].ymax
        for data in self.dataset[1:]:
            xxmin = min(xxmin, data.xmin)
            xxmax = max(xxmax, data.xmax)
            yymin = min(yymin, data.ymin)
            yymax = max(yymax, data.ymax)
        if args.equalaxes:
            mmin = min(xxmin, yymin)
            mmax = max(xxmax, yymax)
            delta = 5+(mmax-mmin)/20
            mmin -= delta
            mmax += delta
            xxmin = mmin
            xxmax = mmax
            yymin = mmin
            yymax = mmax
        if args.xmin:
            xxmin = args.xmin
        if args.xmax:
            xxmax = args.xmax
        if args.ymin:
            yymin = args.ymin
        if args.ymax:
            yymax = args.ymax
        # Now effectuate the options
        if xxmin == xxmax or yymin == yymax:
            if viewDebug:
                print("Warning: min and max for x or y are equal, expanding range.")
            xxmin -= xxmin*0.5
            xxmax += xxmax*0.5
            yymin -= yymax*0.5
            yymax += yymax*0.5
        if args.equalaxes:
            if xxmin == yymin and xxmax == yymax:
                myax.set_aspect('equal', adjustable='box')
            elif viewDebug:
                print("Option -eqax overruled by min and max options")
        return xxmin, xxmax, yymin, yymax

    def decorate(self, thisax, args, setcount, first_title, sharelabel_x, sharelabel_y):
        # Now add the fancy stuff
        if args.titlefontsize > 0:
            if args.title and args.panels and setcount==0:
                thisax.set_title(args.title, fontsize=args.titlefontsize)
            elif "title" in self.legends:
                if setcount != 0 and self.legends["title"] == first_title:
                    pass
                else:
                    thisax.set_title(texify(self.legends["title"]), fontsize=args.titlefontsize, pad=args.titlefontsize*0.5)
        if "xlabel" in self.legends and args.panels and sharelabel_x == True: #Print x label for the last row
            pass
        else:
            thisax.set_xlabel(texify(self.legends["xlabel"]), fontsize=args.axislabelfontsize, labelpad=args.axislabelfontsize*0.5)

        if "ylabel" in self.legends and args.panels and sharelabel_y == True: #Print y label for the first column
            pass
        else:
            thisax.set_ylabel(texify(self.legends["ylabel"]), fontsize=args.axislabelfontsize, labelpad=args.axislabelfontsize*0.5)
        # Legend box placement
        if args.squarefig and self.have_label():
            thisax.legend(loc='upper left', bbox_to_anchor=(args.legend_x, args.legend_y), fontsize=args.legendfontsize if args.legendfontsize <= args.axislabelfontsize else args.axislabelfontsize*0.75)
        elif args.legendfontsize > 0 and self.have_label():
            thisax.legend(loc='upper left', bbox_to_anchor=(args.legend_x, args.legend_y), fontsize=args.legendfontsize)

    def do_bars(self, thisax):
        if viewDebug:
            print("Doing bar graphs")
        for n in range(len(self.dataset)):
            xy = self.dataset[n]
            thisax.bar(xy.x, xy.y, width=0.8/len(xy.y), bottom=0.0, align="center", label=self.label[n])

    def do_lines(self, thisax, argcolors, arglines, argmarkers, setcount):
        print_label = False
        if args.labels:
            print_label = True
        else:
            print_label = len(self.label) == len(self.dataset)

        if viewDebug:
            print("%d labels read in file nr %d: %s" % ( len(self.label), setcount+1, self.label ) )
        for n in range(len(self.dataset)):
            mylabel  = None
            if len(self.label) > n and self.label[n] not in args.ignore:
                if print_label:
                    mylabel = self.label[n]
            if args.linestyle:
                myline = arglines[n]
            else:
                myline = "None" #plot function only accepts None as a string
            mymarker = "None"
            if args.marker or (args.mark1st and setcount == 0) or (args.marker is None and args.linestyle is None):
                mymarker = argmarkers[n]
                if args.mark1st and setcount == 0:
                    myline = "None"
            mycolor = argcolors[n]
            if viewDebug:
                print(f"\t mylabel  {n+1} = {mylabel}")
                print(f"\t mymarker {n+1} = {mymarker}")
                print(f"\t mycolor  {n+1} = {mycolor}\n")
            if hasattr(self.dataset[n], "dy") and self.dataset[n].dy is not None:
                thisax.errorbar(self.dataset[n].x, self.dataset[n].y, yerr=self.dataset[n].dy,
                                capsize=3, label=mylabel, markersize=args.markersize, linewidth=2,
                                ls=myline, marker=mymarker, color=mycolor, ecolor=mycolor)
            else:
                thisax.plot(self.dataset[n].x, self.dataset[n].y, markersize=args.markersize, linewidth=4,
                            label=mylabel, ls=myline, marker=mymarker, color=mycolor, markeredgewidth=args.markeredgewidth)
            


def plot_once(axs, args):
    numaxs = axs.size if hasattr(axs, 'size') else 1

    arglabel = []
    if args.labels:
        arglabel = []
        for value in args.labels:
            if value != "None": #If user only wants to add a label to one of the datasets in a file, set None
                arglabel.append(value)
            else:
                arglabel.append("")
        if viewDebug:
            print("Found the following command-line labels {}".format(arglabel), "\n")
    datasets = []

    # Create new dataset for each file BEFORE plotting
    total_datasets = 0
    xmins = []
    xmaxs = []
    ymins = []
    ymaxs = []
    for filenumber in range(len(args.filename)):
        datasets.append(DataSet())
        if len(arglabel) >= filenumber+1:
            mylabel = arglabel[filenumber]
        else:
            mylabel = None
        datasets[-1].read(args.filename[filenumber], args.residual,
                          args.filelabel, mylabel, filenumber)
        total_datasets += len(datasets[-1].dataset)
        
        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]
        #Fetch mininmum and maximum values
        xxmin, xxmax, yymin, yymax = datasets[filenumber].set_extent(thisax, args)
        xmins.append(xxmin)
        xmaxs.append(xxmax)
        ymins.append(yymin)
        ymaxs.append(yymax)
    #Save the global x/y minima and maxima respectively
    xxmin = min(xmins)
    xxmax = max(xmaxs)
    yymin = min(ymins)
    yymax = max(ymaxs)

    if viewDebug:
        print("Total datasets found: ", total_datasets)

    #Define colors markers and linstyles before going in to loop
    colors = args.colors if args.colors else []
    if args.marker:
        marker = args.marker
    elif args.marker is None and args.linestyle is None: #If neither markers nor linestyle is defined, add markers
        marker = []
    else:
        marker = None
    linestyle = args.linestyle if args.linestyle else None
    # Build a color list long enough for all datasets (maximum is the length of defcolors)     
    if len(colors) < total_datasets:
        if viewDebug:
            print("More datasets than color inputs. Adding colors.")
        # Repeat appending from defcolors
        c = 0
        while len(colors) < total_datasets:
            colors.append(defcolors[c % len(defcolors)])
            c += 1

    idx = 0
    # Plot one dataset at a time
    for filenumber in range(len(args.filename)):
        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]

        #number of datasets within a file
        nrdatasets = len(datasets[filenumber].dataset)
        # Assign colors depending on nr of datasets within each file
        if args.panels:
            these_colors = colors[0:nrdatasets]
        else:
            these_colors = colors[idx:idx+nrdatasets]

        if args.marker:
            if len(args.marker) < nrdatasets: #markers will be applied for each dataset in each file
                c = 0
                while len(marker) < nrdatasets:
                    if defmarkers[c % len(defmarkers)] not in marker:
                        marker.append(defmarkers[c % len(defmarkers)])
                    c += 1
            elif len(args.marker) >= total_datasets: #markers will be applied to each dataset in total
                marker = args.marker[idx:idx+nrdatasets]
        elif args.marker is None and args.linestyle is None:
            c = 0
            while len(marker) < nrdatasets:
                if defmarkers[c % len(defmarkers)] not in marker:
                    marker.append(defmarkers[c % len(defmarkers)])
                c += 1
        else:
            marker = None

        if args.linestyle:
            if len(args.linestyle) < nrdatasets:
                c = 0
                while len(linestyle) < nrdatasets:
                    if deflines[c % len(deflines)] not in linestyle:
                        linestyle.append(deflines[c % len(deflines)])
                    c += 1
            elif len(args.linestyle) >= total_datasets:
                linestyle = args.linestyle[idx:idx+nrdatasets]
        else: 
            linestyle = None

        if args.logy:
            thisax.set_yscale('log')

        if args.bar:
            datasets[filenumber].do_bars(
                thisax,
                these_colors,
            )
        else:
            datasets[filenumber].do_lines(
                thisax,
                these_colors,
                linestyle,
                marker,
                filenumber
            )
        idx += nrdatasets

        if args.panels and numaxs > 1:
            sublabel = string.ascii_uppercase[filenumber] #Add letter to each subplot
            if viewDebug:
                print(f"Setting subplot {filenumber+1} to {sublabel}\n")
            thisax.text(args.subfigureX, args.subfigureY, sublabel,
                    transform=thisax.transAxes, 
                    size=args.axislabelfontsize, weight='bold', color='black')
        # Tick font labels
        for aa in ['x', 'y']:
            thisax.tick_params(axis=aa, labelsize=args.tickfontsize)
            
        # Scale the plot such that the content is visible
        deltax = (xxmax-xxmin)*0.05
        thisax.set_xlim(xxmin-deltax, xxmax+deltax)
        deltay = (yymax-yymin)*0.05
        thisax.set_ylim(yymin-deltay, yymax+deltay)

        # Set labels and titles
        if filenumber == 0:
            first_title = datasets[0].legends.get("title")
        if args.sharelabel:
            ncolumn    = int(math.sqrt(len(args.filename)))
            nrow = int(len(args.filename)/ncolumn)
            if nfiles % ncolumn != 0:
                nrow += 1
            rowindex = filenumber // ncolumn #counts rows by taking the division without rest
            columnindex = filenumber % ncolumn #counts columns by teking the rest
            # Define what x- and y-labels to print
            if rowindex == nrow-1 and columnindex == 0: #Last row and forst column (only applies to lower left plot)
                datasets[filenumber].decorate(thisax, args, filenumber, first_title, sharelabel_x=False, sharelabel_y=False)
            elif rowindex == nrow-1: #Last row
                datasets[filenumber].decorate(thisax, args, filenumber, first_title, sharelabel_x=False, sharelabel_y=True)
            elif columnindex == 0: #First column
                datasets[filenumber].decorate(thisax, args, filenumber, first_title, sharelabel_x=True, sharelabel_y=False)
            else:
                datasets[filenumber].decorate(thisax, args, filenumber, first_title, sharelabel_x=True, sharelabel_y=True)            
        else:
            datasets[filenumber].decorate(thisax, args, filenumber, first_title, sharelabel_x=False, sharelabel_y=False)

    # Finally, printing time
    if args.save:
        if viewDebug:
            print(f"Saving to: {args.save}")
        # Print just once!
        fig.savefig(args.save, bbox_inches='tight')
        args.save = None

def animate(t):
    plot_once()
    plt.gcf().autofmt_xdate()
    plt.tight_layout()

if __name__ == '__main__':   
    args = parseArguments()
    if args.debug:
        viewDebug = True

    nfiles  = len(args.filename)
    ncolumn = 1
    
    if args.squarefig:
        if args.panels:
            xframe = args.axislabelfontsize/3
            yframe = xframe*2
        else:
            xframe = args.axislabelfontsize/3
            yframe = xframe
    else:
        xframe = args.xframe
        yframe = args.yframe

    if args.panels:
        nrow    = int(math.sqrt(nfiles))
        ncolumn = int(nfiles/nrow)
        if nfiles % nrow != 0:
            ncolumn += 1
        fig, axs = plt.subplots(ncolumn, nrow, figsize=(xframe, yframe), constrained_layout=True) #constrained_layout=True usually more recommended than plt.tight_layout()
    else:
        fig, axs = plt.subplots(figsize=(xframe, yframe), constrained_layout=True)
        axs = np.array([axs])

    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    if args.filename:
        if args.follow:
            ani = FuncAnimation(plt.gcf(), animate, interval=5000)
        else:
            plot_once(axs, args)
        if not args.noshow:
            plt.show()
