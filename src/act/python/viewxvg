#!/usr/bin/env python3

import math, os, argparse, string
import tkinter, matplotlib
import matplotlib.pyplot as plt
import numpy as np
matplotlib.use('TkAgg')
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation
from xvgutils import *

viewDebug = False

# Hardcoded formatting, Yay!
defcolors  = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#aec7e8","#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"]
defmarkers = ["o", "x", "<", ">", "v", "^", "+", "s", "p", "*", ".", "D", "d", "h", "H", "|", "_"]
deflines   = [ 'solid', 'dashed', 'dashdot', 'dotted' ]

def parseArguments():
    parser = argparse.ArgumentParser(
      prog='viewxvg',
      description=
"""
Simple script to quickly plot xy files produced by e.g. ACT or GROMACS.
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: viewxvg -f filename1 filename2 -follow')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=None)
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s)", action="store_true")
    parser.add_argument("-debug", "--debug", help="Turn on printing of debugging messages", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    axislabelfontsize=18
    parser.add_argument("-alfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=18
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=18
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    tickfontsize=14
    parser.add_argument("-tickfs", "--tickfontsize", help="Tick font size, default "+str(tickfontsize), type=int, default=tickfontsize)
    parser.add_argument("-ls", "--linestyle", nargs="+", help="What kind of line style: solid, dash, dashdot, None", type=str, default=None)
    parser.add_argument("-mk", "--marker", nargs="+", help="Use markers for data sets", type=str, default=None)
    parser.add_argument("-mk1st", "--mark1st", help="Use marker for the first of all data sets only", action="store_true")
    defmksize = 12
    parser.add_argument("-mksize", "--markersize", help="Size of filled markers for data sets, default "+str(defmksize), default=defmksize, type=int)
    defmkedgew = 2
    parser.add_argument("-mkwidth", "--markeredgewidth", help="Size of character markers (e.g. +) for data sets, default "+str(defmkedgew), default=defmkedgew, type=int)
    parser.add_argument("-colors", "--colors", help="Colors for the plots", nargs="*", type=str, default=None)
    parser.add_argument("-pdf", "--pdf", help="Save plot as pdf file", type=str, default=None)
    parser.add_argument("-sq", "--square", help="Make the plot square with equal axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-res", "--residual", help="Subtract x from y for all data sets - useful for correlation plots", action="store_true")
    parser.add_argument("-fl", "--filelabel", help="Add the filename to the labels in the plot (may yield long labels)", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    parser.add_argument("-xmin", "--xmin", help="Minimum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-xmax", "--xmax", help="Maximum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymin", "--ymin", help="Minimum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymax", "--ymax", help="Maximum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    xframe = 16
    parser.add_argument("-xframe", "--xframe", help="Width of the plot 100 pixels, default "+str(xframe), type=int, default=xframe)
    yframe = 9
    parser.add_argument("-yframe", "--yframe", help="Height of the plot 100 pixels, default "+str(yframe), type=int, default=yframe)
    parser.add_argument("-panels", "--panels", help="Generate different panels to plot in, one file per panel", action="store_true")
    parser.add_argument('-ign', '--ignore', help="Labels of the series to ignore", nargs='*', default=[])
    parser.add_argument("-title", "--title", help="User-defined title", type=str, default=None)
    parser.add_argument("-labels", "--labels", help="User-defined labels", nargs="*", type=str, default=None)
    leg_x = 0.02
    parser.add_argument("-legend_x", "--legend_x", help="Put the legend box horizontally on this position, default "+str(leg_x), type=float, default=leg_x)
    leg_y = 0.98
    parser.add_argument("-legend_y", "--legend_y", help="Put the legend box vertically on this position, default "+str(leg_y), type=float, default=leg_y)

    return parser.parse_args()

class DataSet:
    def __init__(self, debug:bool):
        # Labels for datasets
        self.label   = []
        # Legends for axes
        self.legends = {}
        self.dataset = []
        self.debug   = debug

    def read(self, filenm:str, residual:bool, filelabel:bool, arglabel:str):
        label, legend, dataset = read_xvg(filenm, residual, filelabel)
        if len(dataset) == 0:
            if self.debug:
                print("File %s has no data" % filenm)
        else:
            if self.debug:
                print("Read %d labels %d legends and %d datasets from %s" % ( len(label), len(legend), len(dataset), fn ) )
            for d in dataset:
                self.dataset.append(d)
            for k in legend:
                self.legends[k] = legend[k]
            # This has to be a list, there can be multiple data sets per file
            self.label = []
            if len(label) > 0:
                for l in range(len(label)):
                    if arglabel:
                        self.label.append(arglabel + " " + label[l])
                    else:
                        self.label.append(label[l])
            elif arglabel:
                self.label.append(arglabel)

    def have_label(self):
        return len(self.label) > 0

    def set_extent(self, myax, args):
        if len(self.dataset) < 1:
            print("No data in set_extent")
            return 0, 0, 0, 0
        xxmin = self.dataset[0].xmin
        xxmax = self.dataset[0].xmax
        yymin = self.dataset[0].ymin
        yymax = self.dataset[0].ymax
        for ii in range(1, len(self.dataset)):
            xxmin = min(xxmin, self.dataset[ii].xmin)
            xxmax = max(xxmax, self.dataset[ii].xmax)
            yymin = min(yymin, self.dataset[ii].ymin)
            yymax = max(yymax, self.dataset[ii].ymax)
        if args.square:
            mmin = min(xxmin, yymin)
            mmax = max(xxmax, yymax)
            delta = 5+(mmax-mmin)/20
            mmin -= delta
            mmax += delta
            xxmin = mmin
            xxmax = mmax
            yymin = mmin
            yymax = mmax
        if 0 != args.xmin:
            xxmin = args.xmin
        if 0 != args.xmax:
            xxmax = args.xmax
        if 0 != args.ymin:
            yymin = args.ymin
        if 0 != args.ymax:
            yymax = args.ymax
        # Now effectuate the options
        if args.square:
            if xxmin == yymin and xxmax == yymax:
                myax.set_aspect('equal', adjustable='box')
            elif self.debug:
                print("Option -sq overruled by min and max options")
        deltax = (xxmax-xxmin)*0.05
        plt.xlim(xxmin-deltax, xxmax+deltax)
        deltay = (yymax-yymin)*0.05
        plt.ylim(yymin-deltay, yymax+deltay)
        return xxmin, xxmax, yymin, yymax

    def decorate(self, thisax, args):
        # Scale the plot such that the content is visible
        xxmin, xxmax, yymin, yymax = self.set_extent(thisax, args)
        # Now add the fancy stuff
        if args.title:
            plt.title(args.title, fontsize=args.titlefontsize)
        elif "title" in self.legends:
            plt.title(self.legends["title"], fontsize=args.titlefontsize)
        if "xlabel" in self.legends:
            thisax.set_xlabel(self.legends["xlabel"], fontsize=args.axislabelfontsize)
        if "ylabel" in self.legends:
            thisax.set_ylabel(self.legends["ylabel"], fontsize=args.axislabelfontsize)
        # Legend box placement
        if args.legendfontsize > 0 and self.have_label():
            xlegend = xxmin + args.legend_x*(xxmax-xxmin)
            ylegend = yymin + args.legend_y*(yymax-yymin)
            thisax.legend(loc='upper left', bbox_to_anchor=(args.legend_x, args.legend_y), fontsize=args.legendfontsize)

    def do_bars(self, thisax):
        if self.debug:
            print("Doing bar graphs")
        for xy in self.datasets:
            thisax.bar(xy.x, xy.y, width=0.8/len(xy.y), bottom=0.0, align="center", label=fn)

    def do_lines(self, thisax, arglabel:list, argcolors, arglines, argmarkers):
        colors  = argcolors  if argcolors  else defcolors
        markers = argmarkers if argmarkers else defmarkers
        lines   = arglines   if arglines   else deflines
        print_label = False
        if len(arglabel) > 0:
            print_label = True
        else:
            print_label = len(self.label) == len(self.dataset)
        setcount = 0
        for n in range(len(self.dataset)):
            mylabel  = None
            if self.debug:
                print("number of labels read = %d" % ( len(label) ))
            if len(self.label) > n and self.label[n] not in args.ignore:
                if print_label:
                    mylabel = self.label[n]
            mymarker = None
            myline   = lines[setcount % len(lines)]
            if args.marker or (args.mark1st and setcount == 0):
                mymarker = markers[setcount % len(markers)]
                if args.mark1st and setcount == 0:
                    myline = None
            if viewDebug:
                print("mylabel = {}".format(mylabel))
                print("mymarker = {}".format(mymarker))
            mycolor = colors[setcount % len(colors)]
            if hasattr(self.dataset[n], "dy") and self.dataset[n].dy is not None:
                thisax.errorbar(self.dataset[n].x, self.dataset[n].y, yerr=self.dataset[n].dy,
                                capsize=3, label=mylabel, markersize=args.markersize, linewidth=2,
                                ls=myline, marker=mymarker, color=mycolor, ecolor=mycolor)
            else:
                thisax.plot(self.dataset[n].x, self.dataset[n].y, markersize=args.markersize, linewidth=4,
                            label=mylabel, ls=myline, marker=mymarker, color=mycolor, markeredgewidth=args.markeredgewidth)
            setcount += 1

def plot_once(axs, ncolumn:int, args):
    numaxs   = 0
    for ax in axs.flat:
        ax.clear()
        numaxs += 1
    arglabel = []
    if args.labels:
        arglabel = []
        for value in args.labels:
            if value is not None:
                arglabel.append(value)
        if viewDebug:
            print("Found the following command-line labels {}".format(arglabel))
    filenumber = 0
    datasets   = []
    setcount   = 0
    for filenumber in range(len(args.filename)):
        # Do we need to make a new Dataset?
        if filenumber == 0:
            datasets.append(DataSet(viewDebug))
        elif numaxs > 1:
            datasets.append(DataSet(viewDebug))
        mylabel = None
        if filenumber < len(arglabel):
            mylabel = arglabel[filenumber]
        datasets[-1].read(args.filename[filenumber], args.residual,
                          args.filelabel, mylabel)

        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]
        if args.logy:
            thisax.set_yscale('log')

        if args.bar:
            datasets[-1].do_bars(thisax)
        else:
            datasets[-1].do_lines(thisax, arglabel, args.colors, args.linestyle, args.marker)
        # Set subplot labels if there is more than one
        if args.panels and len(axs) > 1:
            sublabel = string.ascii_uppercase[filenumber]
            if viewDebug:
                print(f"Setting subplot {filenumber} label to {sublabel}")
            axs.flat[filenumber].text(-0.1, 0.9, sublabel, transform=thisax.transAxes, 
                                      size=args.axislabelfontsize, weight='bold', color='black')
        # Tick font labels
        for aa in [ 'x', 'y' ]:
            thisax.tick_params(axis=aa, labelsize=args.tickfontsize)
        # Set labels and titles
        datasets[-1].decorate(thisax, args)
        filenumber += 1
        # Resetting this such that the next plot starts with the same color, linestyle etc.
        setcount = 0

    # Finally, printing time
    if args.pdf:
        # Print just once!
        fig.savefig(args.pdf, bbox_inches='tight')
        args.pdf = None
        
def animate(t):
    plot_once()
    plt.gcf().autofmt_xdate()
    plt.tight_layout()

if __name__ == '__main__':   
    args = parseArguments()
    if args.debug:
        viewDebug = True

    nfiles  = len(args.filename)
    ncolumn = 1
    if args.panels:
        nrow    = int(math.sqrt(nfiles))
        ncolumn = int(nfiles/nrow)
        if nfiles % nrow != 0:
            ncolumn += 1
        fig, axs = plt.subplots(ncolumn, nrow, figsize=(args.xframe,args.yframe))
    else:
        fig, axs = plt.subplots(figsize=(args.xframe,args.yframe))
        axs = np.array([axs])

    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    if args.filename:
        if args.follow:
            ani = FuncAnimation(plt.gcf(), animate, interval=5000)
        else:
            plot_once(axs, ncolumn, args)
        if not args.noshow:
            plt.show()
