#!/usr/bin/env python3

import math, os, argparse, string
import tkinter, matplotlib
import matplotlib.pyplot as plt
import numpy as np
matplotlib.use('TkAgg')
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation
from xvgutils import *

viewDebug = False

# Hardcoded formatting, Yay!
defcolors  = ["#1f77b4", "#ff7f0e", "#2ca02c", "#7f0000", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf", "#aec7e8","#ffbb78", "#98df8a", "#ff9896", "#c5b0d5", "#c49c94", "#f7b6d2", "#c7c7c7", "#dbdb8d", "#9edae5"]
defmarkers = ["o", "+", "<", ">", "v", "^", "x", "s", "p", "*", ".", "D", "d", "h", "H", "|", "_"]
deflines   = [ 'solid', 'dashed', 'dashdot', 'dotted' ]

def parseArguments():
    parser = argparse.ArgumentParser(
      prog='viewxvg',
      description=
"""
Simple script to quickly plot xy files produced by e.g. ACT or GROMACS.
There is limited support for Grace features such superscripts and subscripts
in labels. Remember to add an argument for each file you want to plot. 
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: viewxvg -f filename1 filename2 -ls solid dashed -follow')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=None)
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s)", action="store_true")
    parser.add_argument("-debug", "--debug", help="Turn on printing of debugging messages", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    axislabelfontsize=18
    parser.add_argument("-alfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=18
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=18
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    tickfontsize=14
    parser.add_argument("-tickfs", "--tickfontsize", help="Tick font size, default "+str(tickfontsize), type=int, default=tickfontsize)
    parser.add_argument("-ls", "--linestyle", nargs="+", help="What kind of line style: solid, dashed, dashdot, None", type=str, default=None)
    parser.add_argument("-mk", "--marker", nargs="+", help="Use markers for data sets", type=str, default=None)
    parser.add_argument("-mk1st", "--mark1st", help="Use marker for the first of all data sets only", action="store_true")
    defmksize = 12
    parser.add_argument("-mksize", "--markersize", help="Size of filled markers for data sets, default "+str(defmksize), default=defmksize, type=int)
    defmkedgew = 2
    parser.add_argument("-mkwidth", "--markeredgewidth", help="Size of character markers (e.g. +) for data sets, default "+str(defmkedgew), default=defmkedgew, type=int)
    parser.add_argument("-colors", "--colors", help="Colors for the plots", nargs="*", type=str, default=None)
    parser.add_argument("-save", "--save", help="Save plot", type=str, default=None)
    parser.add_argument("-sq", "--square", help="Make the plot square with equal axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-res", "--residual", help="Subtract x from y for all data sets - useful for correlation plots", action="store_true")
    parser.add_argument("-fl", "--filelabel", help="Add the filename to the labels in the plot (may yield long labels)", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    parser.add_argument("-xmin", "--xmin", help="Minimum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-xmax", "--xmax", help="Maximum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymin", "--ymin", help="Minimum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymax", "--ymax", help="Maximum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    xframe = 16
    parser.add_argument("-xframe", "--xframe", help="Width of the plot 100 pixels, default "+str(xframe), type=int, default=xframe)
    yframe = 9
    parser.add_argument("-yframe", "--yframe", help="Height of the plot 100 pixels, default "+str(yframe), type=int, default=yframe)
    parser.add_argument("-panels", "--panels", help="Generate different panels to plot in, one file per panel", action="store_true")
    subfigx = -0.1
    subfigy = 0.9
    parser.add_argument("-sfx", "--subfigureX", help="X position of subfigure label when using panels. Default "+str(subfigx), type=float, default=subfigx)
    parser.add_argument("-sfy", "--subfigureY", help="Y position of subfigure label when using panels. Default "+str(subfigy), type=float, default=subfigy)
    parser.add_argument('-ign', '--ignore', help="Labels of the series to ignore", nargs='*', default=[])
    parser.add_argument("-title", "--title", help="User-defined title", type=str, default=None)
    parser.add_argument("-labels", "--labels", help="User-defined labels", nargs="*", type=str, default=None)
    leg_x = 0.02
    parser.add_argument("-legend_x", "--legend_x", help="Put the legend box horizontally on this position, default "+str(leg_x), type=float, default=leg_x)
    leg_y = 0.98
    parser.add_argument("-legend_y", "--legend_y", help="Put the legend box vertically on this position, default "+str(leg_y), type=float, default=leg_y)

    return parser.parse_args()

def texify(txt:str)->str:
    return txt.replace("\\S", "$^{").replace("\\s", "$_{").replace("\\N", "}$")
    
class DataSet:
    def __init__(self, debug:bool):
        # Labels for datasets
        self.label   = []
        # Legends for axes
        self.legends = {}
        self.dataset = []
        #viewDebug   = debug

    def read(self, filenm:str, residual:bool, filelabel:bool, arglabel:str, setcount):
        label, legend, dataset = read_xvg(filenm, residual, filelabel)
        if len(dataset) == 0:
            if viewDebug:
                print("File %s has no data" % filenm)
        else:
            if viewDebug:
                print("Read %d labels and %d legends from %d dataset(s) in input file %d" % (len(label), len(legend), len(dataset), setcount+1))
            for d in dataset:
                self.dataset.append(d)
            for k in legend:
                self.legends[k] = legend[k]
            # This has to be a list, there can be multiple data sets per file
            #self.label = []
            if len(label) > 0:
                for l in range(len(label)):
                    if arglabel:
                        self.label.append(texify(arglabel + " " + label[l]))
                    else:
                        self.label.append(texify(label[l]))
            elif arglabel:
                self.label.append(texify(arglabel))

    def have_label(self):
        return len(self.label) > 0

    def set_extent(self, myax, args):
        if len(self.dataset) < 1:
            print("No data in set_extent")
            return 0, 0, 0, 0
        for data in range(len(self.dataset)):
            xxmin = self.dataset[data].xmin
            xxmax = self.dataset[data].xmax
            yymin = self.dataset[data].ymin
            yymax = self.dataset[data].ymax
        if args.square:
            mmin = min(xxmin, yymin)
            mmax = max(xxmax, yymax)
            delta = 5+(mmax-mmin)/20
            mmin -= delta
            mmax += delta
            xxmin = mmin
            xxmax = mmax
            yymin = mmin
            yymax = mmax
        if 0 != args.xmin:
            xxmin = args.xmin
        if 0 != args.xmax:
            xxmax = args.xmax
        if 0 != args.ymin:
            yymin = args.ymin
        if 0 != args.ymax:
            yymax = args.ymax
        # Now effectuate the options
        if xxmin == xxmax or yymin == yymax:
            if viewDebug:
                print("Warning: min and max for x or y are equal, expanding range.")
            xxmin -= xxmin*0.5
            xxmax += xxmax*0.5
            yymin -= yymax*0.5
            yymax += yymax*0.5
        if args.square:
            if xxmin == yymin and xxmax == yymax:
                myax.set_aspect('equal', adjustable='box')
            elif viewDebug:
                print("Option -sq overruled by min and max options")
        deltax = (xxmax-xxmin)*0.05
        plt.xlim(xxmin-deltax, xxmax+deltax)
        deltay = (yymax-yymin)*0.05
        plt.ylim(yymin-deltay, yymax+deltay)
        #return xxmin, xxmax, yymin, yymax

    def decorate(self, thisax, args):
        # Scale the plot such that the content is visible
        self.set_extent(thisax, args)
        # Now add the fancy stuff
        if args.titlefontsize > 0:
            if args.title:
                thisax.set_title(args.title, fontsize=args.titlefontsize)
            elif "title" in self.legends:
                thisax.set_title(texify(self.legends["title"]), fontsize=args.titlefontsize)
        if "xlabel" in self.legends:
            thisax.set_xlabel(texify(self.legends["xlabel"]), fontsize=args.axislabelfontsize)
        if "ylabel" in self.legends:
            thisax.set_ylabel(texify(self.legends["ylabel"]), fontsize=args.axislabelfontsize)
        # Legend box placement
        if args.legendfontsize > 0 and self.have_label():
            #xlegend = xxmin + args.legend_x*(xxmax-xxmin)
            #ylegend = yymin + args.legend_y*(yymax-yymin)
            thisax.legend(loc='upper left', bbox_to_anchor=(args.legend_x, args.legend_y), fontsize=args.legendfontsize)

    def do_bars(self, thisax, arglabel:list, argcolors):
        if viewDebug:
            print("Doing bar graphs")
        for xy in self.datasets:
            thisax.bar(xy.x, xy.y, width=0.8/len(xy.y), bottom=0.0, align="center", label=self.label)

    def do_lines(self, thisax, arglabel:list, argcolors, arglines, argmarkers, setcount):
        colors = argcolors
        markers = argmarkers if argmarkers else defmarkers
        lines   = arglines   if arglines   else deflines

        if len(self.dataset) > len(markers):
            if viewDebug:
                print("Adding a different marker to second dataset.")
            for m in defmarkers:
                if m not in markers:
                    markers.append(m)

        print_label = False
        if len(arglabel) > 0:
            print_label = True
        else:
            print_label = len(self.label) == len(self.dataset)

        if viewDebug:
            print("%d labels read in file nr %d: %s" % ( len(self.label), setcount+1, self.label ) )
        for n in range(len(self.dataset)):
            mylabel  = None
            if len(self.label) > n and self.label[n] not in args.ignore:
                if print_label:
                    mylabel = self.label[n]
            myline   = lines[setcount % len(lines)]
            mymarker = None
            if args.marker or (args.mark1st and setcount == 0):
                mymarker = markers[n]
                if args.mark1st and setcount == 0:
                    myline = None
            mycolor = colors[n]
            if viewDebug:
                print(f"\t mylabel  {n+1} = {mylabel}")
                print(f"\t mymarker {n+1} = {mymarker}")
                print(f"\t mycolor  {n+1} = {mycolor}\n")
            if hasattr(self.dataset[n], "dy") and self.dataset[n].dy is not None:
                thisax.errorbar(self.dataset[n].x, self.dataset[n].y, yerr=self.dataset[n].dy,
                                capsize=3, label=mylabel, markersize=args.markersize, linewidth=2,
                                ls=myline, marker=mymarker, color=mycolor, ecolor=mycolor)
            else:
                thisax.plot(self.dataset[n].x, self.dataset[n].y, markersize=args.markersize, linewidth=4,
                            label=mylabel, ls=myline, marker=mymarker, color=mycolor, markeredgewidth=args.markeredgewidth)
            


def plot_once(axs, ncolumn:int, args):
    numaxs = axs.size if hasattr(axs, 'size') else 1

    arglabel = []
    if args.labels:
        arglabel = []
        for value in args.labels:
            if value is not None:
                arglabel.append(value)
        if viewDebug:
            print("Found the following command-line labels {}".format(arglabel), "\n")
    datasets = []

    # Create new dataset for each file BEFORE plotting
    total_datasets = 0
    for filenumber in range(len(args.filename)):
        datasets.append(DataSet(viewDebug))
        mylabel = None
        if filenumber < len(arglabel):
            mylabel = arglabel[filenumber]
        datasets[-1].read(args.filename[filenumber], args.residual,
                          args.filelabel, mylabel, filenumber)
        total_datasets += len(datasets[-1].dataset)
    if viewDebug:
        print("Total datasets found: ", total_datasets)

    # Build a color list long enough for all datasets (maximum is the length of defcolors)
    colors = args.colors if args.colors else []
    if len(colors) < total_datasets:
        if viewDebug:
            print("More datasets than color inputs. Adding colors.")
        for c in defcolors:
            if len(colors) == total_datasets:
                break
            if c not in colors:
                colors.append(c)

    color_idx = 0
    # Plot one dataset at a time
    for filenumber in range(len(args.filename)):
        # Shortcut for the current axis
        thisax = axs.flat[filenumber % numaxs]

        if args.linestyle:
            if len(args.linestyle) > 1:
                linestyle = [args.linestyle[filenumber]]
            else:
                linestyle = args.linestyle
        else: 
            linestyle = None

        if args.marker:
            marker = args.marker
        else: 
            marker = None

        if args.logy:
            thisax.set_yscale('log')

        if args.bar:
            datasets[filenumber].do_bars(thisax)
        else:
            # Assign colors depending on nr of datasets within each file
            nrdatasets = len(datasets[filenumber].dataset)
            these_colors = colors[color_idx:color_idx+nrdatasets]

            datasets[filenumber].do_lines(
                thisax, arglabel[filenumber] if arglabel else '',
                these_colors,
                linestyle,
                marker,
                filenumber
            )
            color_idx += nrdatasets

        if args.panels and numaxs > 1:
            sublabel = string.ascii_uppercase[filenumber]
            if viewDebug:
                print(f"Setting subplot {filenumber} label to {sublabel}\n")
            thisax.text(args.subfigureX, args.subfigureY+0.1, sublabel,
                    transform=thisax.transAxes, 
                    size=args.axislabelfontsize, weight='bold', color='black')
        # Tick font labels
        for aa in ['x', 'y']:
            thisax.tick_params(axis=aa, labelsize=args.tickfontsize)
            
        # Set labels and titles
        datasets[0].decorate(thisax, args)

    # Finally, printing time
    if args.save:
        if viewDebug:
            print(f"Saving to: {args.save}")
        # Print just once!
        fig.savefig(args.save, bbox_inches='tight')
        args.save = None
        
def animate(t):
    plot_once()
    plt.gcf().autofmt_xdate()
    plt.tight_layout()

if __name__ == '__main__':   
    args = parseArguments()
    if args.debug:
        viewDebug = True

    nfiles  = len(args.filename)
    ncolumn = 1
    
    if args.panels:
        nrow    = int(math.sqrt(nfiles))
        ncolumn = int(nfiles/nrow)
        if nfiles % nrow != 0:
            ncolumn += 1
        fig, axs = plt.subplots(ncolumn, nrow, figsize=(args.xframe,args.yframe), constrained_layout=True) #constrained_layout=True usually more recommended than plt.tight_layout()
    else:
        fig, axs = plt.subplots(figsize=(args.xframe,args.yframe), constrained_layout=True)
        axs = np.array([axs])

    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    if args.filename:
        if args.follow:
            ani = FuncAnimation(plt.gcf(), animate, interval=5000)
        else:
            plot_once(axs, ncolumn, args)
        if not args.noshow:
            plt.show()
