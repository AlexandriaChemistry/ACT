#!/usr/bin/env python3

import math, os, argparse
import tkinter, matplotlib
import matplotlib.pyplot as plt
import numpy as np
matplotlib.use('TkAgg')
from matplotlib import rcParams
from matplotlib.animation import FuncAnimation
from xvgutils import *

viewDebug = False

def parseArguments():
    parser = argparse.ArgumentParser(
      prog='viewxvg',
      description=
"""
Braindead script to quickly plot xy files produced by e.g. ACT or GROMACS.
One nice feature is that you can get live updates of plots that
are generated by a running program, using the -follow option.
""",
      epilog= 'Example: viewxvg -f filename1 filename2 -follow')
    parser.add_argument("-f",   "--filename", nargs="*", help="Filename(s) to read and plot", type=str, default=None)
    parser.add_argument("-follow", "--follow", help="Continuously update the plot by re-reading the input file(s)", action="store_true")
    parser.add_argument("-debug", "--debug", help="Turn on printing of debugging messages", action="store_true")
    fontname="Arial"
    parser.add_argument("-font", "--fontname", help="Font for all text.", type=str, default=fontname)
    axislabelfontsize=18
    parser.add_argument("-alfs", "--axislabelfontsize", help="Axis label font size, default "+str(axislabelfontsize), type=int, default=axislabelfontsize)
    titlefontsize=18
    parser.add_argument("-tfs", "--titlefontsize", help="Title font size, set to zero for no title, default "+str(titlefontsize), type=int, default=titlefontsize)
    legendfontsize=18
    parser.add_argument("-lfs", "--legendfontsize", help="Legend font size, set to zero for no legend, default "+str(legendfontsize), type=int, default=legendfontsize)
    tickfontsize=14
    parser.add_argument("-tickfs", "--tickfontsize", help="Tick font size, default "+str(tickfontsize), type=int, default=tickfontsize)
    linestyle="solid"
    parser.add_argument("-ls", "--linestyle", help="What kind of line style: solid, dash, dashdot, None, default "+linestyle, type=str, default=linestyle)
    parser.add_argument("-mk", "--marker", help="Use markers for data sets", action="store_true")
    parser.add_argument("-mk1st", "--mark1st", help="Use marker for the first of all data sets only", action="store_true")
    defmksize = 12
    parser.add_argument("-mksize", "--markersize", help="Size of filled markers for data sets, default "+str(defmksize), default=defmksize, type=int)
    defmkedgew = 2
    parser.add_argument("-mkwidth", "--markeredgewidth", help="Size of character markers (e.g. +) for data sets, default "+str(defmkedgew), default=defmkedgew, type=int)
    parser.add_argument("-colors", "--colors", help="Colors for the plots", nargs="*", type=str, default=None)
    parser.add_argument("-pdf", "--pdf", help="Save plot as pdf file", type=str, default=None)
    parser.add_argument("-sq", "--square", help="Make the plot square with equal axes", action="store_true")
    parser.add_argument("-bar", "--bar", help="Make a bar graph", action="store_true")
    parser.add_argument("-noshow", "--noshow", help="Do not show the figure", action="store_true")
    parser.add_argument("-res", "--residual", help="Subtract x from y for all data sets - useful for correlation plots", action="store_true")
    parser.add_argument("-fl", "--filelabel", help="Add the filename to the labels in the plot (may yield long labels)", action="store_true")
    parser.add_argument("-logy", "--logy", help="Use a log scale on the Y-axis", action="store_true")
    parser.add_argument("-xmin", "--xmin", help="Minimum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-xmax", "--xmax", help="Maximum value of X-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymin", "--ymin", help="Minimum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    parser.add_argument("-ymax", "--ymax", help="Maximum value of Y-axis. Default = defined by data.", type=float, default=0.0)
    xframe = 16
    parser.add_argument("-xframe", "--xframe", help="Width of the plot 100 pixels, default "+str(xframe), type=int, default=xframe)
    yframe = 9
    parser.add_argument("-yframe", "--yframe", help="Height of the plot 100 pixels, default "+str(yframe), type=int, default=yframe)
    parser.add_argument("-panels", "--panels", help="Generate different panels to plot in, one file per panel", action="store_true")
    parser.add_argument('-ign', '--ignore', help="Labels of the series to ignore", nargs='*', default=[])
    parser.add_argument("-title", "--title", help="User-defined title", type=str, default=None)
    parser.add_argument("-labels", "--labels", help="User-defined labels", nargs="*", type=str, default=None)
    leg_x = 0.02
    parser.add_argument("-legend_x", "--legend_x", help="Put the legend box horizontally on this position, default "+str(leg_x), type=float, default=leg_x)
    leg_y = 0.98
    parser.add_argument("-legend_y", "--legend_y", help="Put the legend box vertically on this position, default "+str(leg_y), type=float, default=leg_y)

    return parser.parse_args()

def set_extent(dataset):
    if len(dataset) < 1:
        print("No data in set_extent")
        return 0, 0, 0, 0
    xxmin = dataset[0][0].xmin
    xxmax = dataset[0][0].xmax
    yymin = dataset[0][0].ymin
    yymax = dataset[0][0].ymax
    for ii in range(1, len(dataset)):
        xxmin = min(xxmin, dataset[ii][0].xmin)
        xxmax = max(xxmax, dataset[ii][0].xmax)
        yymin = min(yymin, dataset[ii][0].ymin)
        yymax = max(yymax, dataset[ii][0].ymax)
    if args.square:
        mmin = min(xxmin, yymin)
        mmax = max(xxmax, yymax)
        delta = 5+(mmax-mmin)/20
        mmin -= delta
        mmax += delta
        xxmin = mmin
        xxmax = mmax
        yymin = mmin
        yymax = mmax
    if 0 != args.xmin:
        xxmin = args.xmin
    if 0 != args.xmax:
        xxmax = args.xmax
    if 0 != args.ymin:
        yymin = args.ymin
    if 0 != args.ymax:
        yymax = args.ymax
    # Now effectuate the options
    if args.square:
        if xxmin == yymin and xxmax == yymax:
            ax.set_aspect('equal', adjustable='box')
        elif viewDebug:
            print("Option -sq overruled by min and max options")
    deltax = (xxmax-xxmin)*0.05
    plt.xlim(xxmin-deltax, xxmax+deltax)
    deltay = (yymax-yymin)*0.05
    plt.ylim(yymin-deltay, yymax+deltay)
    return xxmin, xxmax, yymin, yymax

def plot_once(axs, ncolumn:int, args):
    legends = {}
    numaxs   = 0
    for ax in axs.flat:
        ax.clear()
        numaxs += 1
    have_labels = args.labels != None
    arglabel = []
    if args.labels:
        arglabel = []
        for value in args.labels:
            if value is not None:
                arglabel.append(value)
        if viewDebug:
            print("Found the following command-line labels {}".format(arglabel))
    filenumber = 0
    datasets   = []
    setcount   = 0
    ipanel     = 0
    colors = args.colors if args.colors else ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b"]

    markers = [ "o", "+", "x", ".", "v", "s" ]
    for fn in args.filename:
        label, legend, dataset = read_xvg(fn, args.residual, args.filelabel)
        if len(dataset) == 0:
            print("File %s has no data" % fn)
            continue
        datasets.append(dataset)
        if len(arglabel) > 0:
            # This has to be a list, there can be multiple data sets per file
            if len(label) > 0:
                for l in range(len(label)):
                    label[l] = arglabel[filenumber] + " " + label[l]
            else:
                label = [ arglabel[filenumber] ]
        thisax = axs.flat[filenumber % numaxs]
        filenumber += 1
        if args.logy:
            thisax.set_yscale('log')
        for leg in legend.keys():
            legends[leg] = legend[leg]
        have_labels = have_labels or len(label) > 0
        if args.bar:
            print("Doing bar graphs")
            for xy in dataset:
                thisax.bar(xy.x, xy.y, width=0.8/len(xy.y), bottom=0.0, align="center", label=fn)
                setcount += 1
        else:
            print_label = False
            if len(arglabel) > 0:
                print_label = True
            else:
                print_label = len(label) == len(dataset)
            for n in range(len(dataset)):
                mylabel  = None
                if viewDebug:
                    print("n = %d" % ( len(label) ))
                if len(label) > n and label[n] not in args.ignore:
                    if print_label:
                        mylabel = label[n]
                mymarker = None
                myline   = args.linestyle
                if args.marker or (args.mark1st and setcount == 0):
                    mymarker  = markers[setcount % len(markers)]
                    if args.mark1st and setcount == 0:
                        myline = None
                if viewDebug:
                    print("mylabel = {}".format(mylabel))
                    print("mymarker = {}".format(mymarker))
                thisax.plot(dataset[n].x, dataset[n].y, markersize=args.markersize, linewidth=4, label=mylabel, ls=myline, marker=mymarker, color=colors[setcount % len(colors)], markeredgewidth=args.markeredgewidth)
                setcount += 1
        for aa in [ 'x', 'y' ]:
            thisax.tick_params(axis=aa, labelsize=args.tickfontsize)
        if args.panels:
            ipanel += 1
        xxmin, xxmax, yymin, yymax = set_extent(datasets)
        if args.title:
            plt.title(args.title, fontsize=args.titlefontsize)
        elif "title" in legends:
            plt.title(legends["title"], fontsize=args.titlefontsize)
        if "xlabel" in legends:
            thisax.set_xlabel(legends["xlabel"], fontsize=args.axislabelfontsize)
        if "ylabel" in legends:
            thisax.set_ylabel(legends["ylabel"], fontsize=args.axislabelfontsize)
        if args.legendfontsize > 0 and have_labels or args.labels:
            xlegend = xxmin + args.legend_x*(xxmax-xxmin)
            ylegend = yymin + args.legend_y*(yymax-yymin)
            thisax.legend(loc='upper left', bbox_to_anchor=(args.legend_x, args.legend_y), fontsize=args.legendfontsize)
    if args.pdf:
        # Print just once!
        fig.savefig(args.pdf, bbox_inches='tight')
        args.pdf = None
        
def animate(t):
    plot_once()
    plt.gcf().autofmt_xdate()
    plt.tight_layout()

if __name__ == '__main__':   
    args = parseArguments()
    if args.debug:
        viewDebug = True

    nfiles  = len(args.filename)
    ncolumn = 1
    if args.panels:
        ncolumn = int(math.sqrt(nfiles))
        nrow    = int(nfiles/ncolumn)
        if nfiles % ncolumn != 0:
            nrow += 1
        fig, axs = plt.subplots(ncolumn, nrow)
    else:
        fig, axs = plt.subplots(figsize=(args.xframe,args.yframe))
        axs = np.array([axs])

    rcParams['font.family'] = 'sans-serif'
    rcParams['font.sans-serif'] = [args.fontname]

    if args.filename:
        if args.follow:
            ani = FuncAnimation(plt.gcf(), animate, interval=5000)
        else:
            plot_once(axs, ncolumn, args)
        if not args.noshow:
            plt.show()
